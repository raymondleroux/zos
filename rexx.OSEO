//* Generated by rexx PDS2SEQ
//* CHANGE userid to your userid
//* change PDS if desired
//* put jobcard at top, submit
//*DELETE  EXEC PGM=IEFBR14
//*DD1     DD DSN=STE58.OSEO.REXX,
//*        DISP=(MOD,DELETE),UNIT=SYSDA,SPACE=(TRK,0)
//*
//LOAD    EXEC PGM=IEBUPDTE,PARM='NEW'
//SYSPRINT DD SYSOUT=*
//SYSUT2  DD DSN=STE58.OSEO.REXX,
//        DISP=(NEW,CATLG,DELETE),
//        DCB=(DSORG=PO,LRECL=80,BLKSIZE=8000,RECFM=FB),
//        UNIT=SYSDA,
//        SPACE=(TRK,(10,05,20),RLSE)
//*
//SYSIN  DD DATA,DLM='!!'

./ ADD NAME=$DOC
$smpe   copy to S28P.CEPME1.SYSEXEC

./ ADD NAME=$SMPE
/* rexx */
ADDRESS TSO
"ALTLIB ACT APPLICATION(EXEC) DSNAME('GIM.SGIMCLS0')"
ADDRESS ISPEXEC
"LIBDEF ISPMLIB DATASET ID('GIM.SGIMMENU')"
"LIBDEF ISPPLIB DATASET ID('GIM.SGIMPENU')"
"LIBDEF ISPSLIB DATASET ID('GIM.SGIMSENU')"
"LIBDEF ISPTLIB DATASET ID('GIM.SGIMTENU')"
"SELECT PANEL(GIM‡PRIM) NEWAPPL(SMPE) PASSLIB"
ISPEXEC LIBDEF ISPPLIB /* free plib */
ISPEXEC LIBDEF ISPMLIB /* free mlib */
ISPEXEC LIBDEF ISPSLIB /* free slib */
ISPEXEC LIBDEF ISPTLIB /* free tlib */
ADDRESS TSO
"ALTLIB DEA APPLICATION(EXEC)" /* deactivate EXEC library */
"END"

./ ADD NAME=$SMPE$
/* rexx */                                                              00010001
TRACE ALL                                                               00011013
ADDRESS TSO                                                             00020007
"ALTLIB ACT APPLICATION(EXEC) DSNAME(GIM.SGIMCLS0)"                     00030014
GIM.SGIMCLS0                                                            00040006
ADDRESS ISPEXEC                                                  -      00050006
'LIBDEF 'ISPMLIB'  DATASET                                     -        00060008
                   ID('GIM.SGIMMENU')                          -        00070008
                   UNCOND                                               00080008
ADDRESS ISPEXEC                                                  -      00090010
'LIBDEF 'ISPPLIB'  DATASET                                     -        00100008
                   ID('GIM.SGIMPENU')                          -        00110008
                   UNCOND                                               00120008
ADDRESS ISPEXEC                                                  -      00130010
'LIBDEF 'ISPSLIB'  DATASET                                     -        00140008
                   ID('GIM.SGIMSENU')                          -        00150008
                   UNCOND                                               00160008
ADDRESS ISPEXEC                                                  -      00170010
'LIBDEF 'ISPTLIB'  DATASET                                     -        00180008
                   ID('GIM.SGIMTENU')                          -        00190008
                   UNCOND                                               00200008
ADDRESS ISPEXEC SELECT PANEL(GIMPRIM)                                   00210010

./ ADD NAME=AIZBLK
//AIZBLK   JOB  MSGCLASS=A                                              00010400
//** START OF SPECIFICATIONS ****************************************** 00010900
//*SYS1.SAMPLIB(AIZBLKE)                                                00011000
//*                                                                     00011400
//*01* PART NAME: AIZBLK                                                00011900
//*                                                                     00012400
//*01* DESCRIPTIVE NAME = ZAWARE BULK LOAD CLIENT SAMPLE JCL            00012900
//*                                                                     00013400
//*01* PROPRIETARY STATEMENT=                                           00013900
//*                                                                     00014400
//*    LICENSED MATERIALS - PROPERTY OF IBM                             00014900
//*    5650-ZOS COPYRIGHT IBM CORP. 2013                                00015300
//*                                                                     00015800
//* STATUS = HBB7790                                                    00016300
//*                                                                     00016800
//*01* FUNCTION: THIS SAMPLE JCL INVOKES THE ZAWARE BULK LOAD CLIENT    00017300
//*              TO IMPORT HCL/HCR SYSLOG RECORDS TO A ZAWARE SERVER.   00017800
//*                                                                     00018300
//*02* OPERATION:                                                       00018800
//*                                                                     00019300
//*     DEFINE STEP:                                                    00019800
//*       DEFINE A MODEL LOGSTREAM                                      00020200
//*                                                                     00020700
//*     BULKLOAD STEP:                                                  00021200
//*       RUN TSO/E TO DO THE FOLLOWING:                                00021700
//*          A. ALLOCATE THE CONTROL DATASET                            00022200
//*          B. ADD ONE OR MORE SYSLOG DATASETS TO THE CONTROL DATASET  00022700
//*          C. DISPLAY THE CONTROL DATASET CONTENTS                    00023200
//*          D. IMPORT THE SYSLOG RECORDS TO THE TARGET LOGSTREAM       00023700
//*                                                                     00024200
//*     DELETE STEP:                                                    00024700
//*       DELETE THE MODEL LOGSTREAM                                    00025100
//*       DELETE THE TARGET LOGSTREAM                                   00025600
//*                                                                     00026100
//*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-* 00026600
//*                                                                     00027100
//*02* CUSTOMIZATIONS:                                                  00027600
//*                                                                     00028100
//*     JOB STATEMENT:                                                  00028600
//*       - CUSTOMIZE THE JOB STATEMENT TO MEET LOCAL REQUIREMENTS.     00029100
//*                                                                     00029600
//*     DEFINE STEP:                                                    00030000
//*       - CHOOSE A MODEL LOGSTREAM NAME.                              00030500
//*         + CHANGE ALL OCCURRENCES OF TSOUSER.ZAI.LSMODEL TO THE      00031000
//*           CHOSEN NAME.                                              00031500
//*                                                                     00032000
//*       - CUSTOMIZE THE MODEL LOGSTREAM DEFINITION:                   00032500
//*         + A DASD-ONLY LOG STREAM IS RECOMMENDED, TO MINIMIZE USE    00033000
//*           OF SHARED SYSTEM RESOURCES AND FOR EASE OF USE UNDER A    00033500
//*           MONOPLEX CONFIGURATION.                                   00034000
//*                                                                     00034500
//*         + SELECT A STG_DATACLAS THAT DEFINES A CISIZE OF 4K,        00034900
//*           WHICH IS REQUIRED FOR A DATA-ONLY LOG STREAM.             00035400
//*           IBM RECOMMENDS 24K CI SIZE FOR LS_DATACLAS.               00035900
//*           SEE Z/OS DFSMS: USING DATA SETS, SC26-7410 FOR MORE       00036400
//*           INFORMATION ABOUT SMS.                                    00036900
//*                                                                     00037400
//*         + DASD-ONLY LOG STREAMS ARE UNCONDITIONALLY DUPLEXED TO     00037900
//*           STAGING DATA SETS. THE SIZE OF A STAGING DATASET IS       00038400
//*           CHOSEN TO MINIMIZE THE TIME SPENT CREATING STAGING        00038900
//*           DATASETS.                                                 00039400
//*                                                                     00039800
//*         + HCL/HCR RECORDS MAY BE FROM 55 BYTES UP TO 133 BYTES.     00040300
//*                                                                     00040800
//*         + THE IBM-SUGGESTED MINIMUM STAGING DATASET SIZE OF         00041300
//*           10MB, STG_SIZE(2560), ALLOWS FOR 78,320 133 BYTE          00041800
//*           RECORDS.  AS NOT ALL SYSLOG RECORDS ARE 133 BYTES,        00042300
//*           THIS IS A MIMIMUM SIZE, MORE RECORDS WILL PROBABLY        00042800
//*           FIT.                                                      00043300
//*                                                                     00043800
//*         + REFER TO 'PLANNING FOR SYSTEM LOGGER APPLICATIONS' IN     00044300
//*           'MVS SETTING UP A SYSPLEX' FOR MORE INFORMATION.          00044700
//*                                                                     00045200
//*     BULKLOAD STEP:                                                  00045700
//*       - CUSTOMIZE THE ZAWARE BULK LOAD CLIENT REXX EXEC. REFER      00046200
//*         TO 'SYS1.SAMPLIB(AIZBLKE)'.                                 00046700
//*                                                                     00047200
//*       - CHOOSE THE PDS NAME THAT CONTAINS THE CUSTOMIZED ZAWARE     00047700
//*         BULK LOAD CLIENT REXX EXEC.                                 00048200
//*         + CHANGE ALL OCCURRENCES OF TSOUSER.ZAI.REXX TO THE         00048700
//*           CHOSEN NAME.                                              00049200
//*                                                                     00049600
//*       - CHOOSE A CONTROL DATASET NAME.                              00050100
//*         + CHANGE ALL OCCURRENCES OF TSOUSER.ZAI.CONTROL TO THE      00050600
//*           CHOSEN NAME.                                              00051100
//*                                                                     00051600
//*       - CHOOSE A CONTROL DATASET NAME.                              00052100
//*         + CHANGE TSOUSER.ARCHIVE.SYSLOG TO THE FIRST SYSLOG         00052600
//*           DATASET NAME.                                             00053100
//*                                                                     00053600
//*       - INSERT ADDITIONAL ADDSYSLOGDSN CALLS, IF REQUIRED, TO ADD   00054100
//*         ADDITIONAL SYSLOG DATASET NAMES TO THE CONTROL DATASET.     00054500
//*                                                                     00055000
//*       - CHOOSE A TARGET LOGSTREAM NAME.                             00055500
//*         + CHANGE ALL OCCURRENCES OF TSOUSER.ZAI.LSTREAM TO THE      00056000
//*           CHOSEN NAME.                                              00056500
//*                                                                     00057000
//*       - UPDATE WITH THE MODEL LOGSTREAM NAME CHOSEN IN THE DEFINE   00057500
//*         STEP                                                        00058000
//*         + CHANGE ALL OCCURRENCES OF TSOUSER.ZAI.LSMODEL TO THE      00058500
//*           CHOSEN NAME.                                              00059000
//*                                                                     00059400
//*     DELETE STEP:                                                    00059900
//*       - UPDATE WITH THE MODEL LOGSTREAM NAME CHOSEN IN THE DEFINE   00060400
//*         STEP                                                        00060900
//*         + CHANGE ALL OCCURRENCES OF TSOUSER.ZAI.LSMODEL TO THE      00061400
//*           CHOSEN NAME.                                              00061900
//*       - UPDATE WITH THE TARGET LOGSTREAM NAME CHOSEN IN THE         00062400
//*         THE BULKLOAD STEP                                           00062900
//*         + CHANGE ALL OCCURRENCES OF TSOUSER.ZAI.LSMODEL TO THE      00063400
//*           CHOSEN NAME.                                              00063900
//*                                                                     00064300
//*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-* 00064800
//*                                                                     00065300
//*01* CHANGE ACTIVITY:                                                 00065800
//*                                                                     00066300
//* $L0=ME23640 HBB7790  120228  PDEV: ZAWARE BULK LOAD CLIENT          00066800
//* $P0=ME23990 HBB7790  120419  PDEV: ADD ZAI PARMS TO MODEL LS        00067300
//* $P1=ME24600 HBB7790  120814  PDEV: ADD PARMS TO MODEL LS            00067800
//*                                                                     00068300
//** END OF SPECIFICATIONS ******************************************** 00068800
//*-------------------------------------------------------------------- 00069200
//*                                                                     00069700
//*01* STEPNAME: DEFINE                                                 00070200
//*                                                                     00070700
//*02* OPERATION: DEFINE THE MODEL LOGSTREAM                            00071200
//*                                                                     00071700
//*01* EXIT-NORMAL: MODEL LOGSTREAM DEFINED                             00072200
//*02* RETURN-CODES: 0                                                  00072700
//*                                                                     00073200
//*01* EXIT-ERROR:  MODEL LOGSTREAM NOT DEFINED. THE JOBLOG CONTAINS    00073700
//*                 INFORMATIONAL MESSAGES ABOUT THE ERROR.             00074100
//*02* RETURN-CODES: NON-ZERO VALUE                                     00074600
//*                                                                     00075100
//*-------------------------------------------------------------------- 00075600
//DEFINE   EXEC PGM=IXCMIAPU                                            00076100
//SYSPRINT DD SYSOUT=*                                                  00076600
//SYSABEND DD SYSOUT=*                                                  00077100
//SYSIN    DD *                                                         00077600
 DATA TYPE (LOGR) REPORT(NO)                                            00078100
    DEFINE LOGSTREAM NAME(TSOUSER.ZAI.LSMODEL)                          00078600
           MODEL(YES)                                                   00079000
           ZAI(YES)                                                     00079500
           ZAIDATA('SYSLOG')                                            00080000
           DASDONLY(YES)                                                00080500
           MAXBUFSIZE(65532)                                            00081000
           AUTODELETE(YES)                                              00081500
           LS_SIZE(2560)                                                00082000
           STG_SIZE(2560)                                               00082500
           HIGHOFFLOAD(60)                                              00083000
           LOWOFFLOAD(30)                                               00083500
           STG_DATACLAS(LOGR4K)                                         00083900
           LS_DATACLAS(LOGR24K)                                         00084400
    LIST   LOGSTREAM NAME(TSOUSER.ZAI.LSMODEL)                          00084900
/*                                                                      00085400
//*-------------------------------------------------------------------- 00085900
//*                                                                     00086400
//*01* STEPNAME: BULKLOAD                                               00086900
//*                                                                     00087400
//*01* ENTRY: STEP BYPASSED IF DEFINE RETURN CODE IS NON-ZERO           00087900
//*                                                                     00088400
//*02* OPERATION: INVOKE THE ZAWARE BULK LOAD CLIENT UNDER TSO/E:       00088800
//*                                                                     00089300
//*      AIZBLKE CNTLDSN REQUEST NAME LSNAME LSMODEL                    00089800
//*                                                                     00090300
//*01* EXIT-NORMAL: ALL SYSLOG RECORDS WRITTEN TO ZAI LOGSTREAM         00090800
//*02* RETURN-CODES: 0                                                  00091300
//*                                                                     00091800
//*01* EXIT-ERROR:  ONE OF THE AIZBLKE REXX CALLS FAILED. SYSLOG        00092300
//*                 RECORDS MAY OR MAY NOT HAVE BEEN WRITTEN. THE       00092800
//*                 JOBLOG CONTAINS INFORMATIONAL MESSAGES ABOUT        00093300
//*                 ABOUT THE ERROR.                                    00093700
//*02* RETURN-CODES: NON-ZERO VALUE                                     00094200
//*                                                                     00094700
//*-------------------------------------------------------------------- 00095200
//BULKLOAD EXEC PGM=IKJEFT01,COND=(0,NE,DEFINE),REGION=0M               00095700
//SYSEXEC  DD DISP=SHR,DSN=TSOUSER.ZAI.REXX                             00096200
//SYSTSPRT DD SYSOUT=*                                                  00096700
//SYSABEND DD SYSOUT=*                                                  00097200
//SYSTSIN  DD *                                                         00097700
 AIZBLKE TSOUSER.ZAI.CONTROL CREATECNTLS                                00098200
 WHEN SYSRC(EQ 0) +                                                     00098600
     AIZBLKE TSOUSER.ZAI.CONTROL ADDSYSLOGDSN +                         00099100
             TSOUSER.ARCHIVE.SYSLOG                                     00099600
 WHEN SYSRC(EQ 0) +                                                     00100100
     AIZBLKE TSOUSER.ZAI.CONTROL DISPLAYCNTLS                           00100600
 WHEN SYSRC(EQ 0) +                                                     00101100
     AIZBLKE TSOUSER.ZAI.CONTROL IMPORT DUMMY +                         00101600
             TSOUSER.ZAI.LSTREAM TSOUSER.ZAI.LSMODEL                    00102100
/*                                                                      00102600
//*-------------------------------------------------------------------- 00103100
//*                                                                     00103500
//*01* STEPNAME: DELETE                                                 00104000
//*                                                                     00104500
//*01* ENTRY: STEP BYPASSED IF DEFINE RETURN CODE IS NON-ZERO           00105000
//*                                                                     00105500
//*02* OPERATION: DELETE THE MODEL LOGSTREAM                            00106000
//*               DELETE THE TARGET LOGSTREAM                           00106500
//*                                                                     00107000
//*01* EXIT-NORMAL: MODEL LOGSTREAM DELETED                             00107500
//*02* RETURN-CODES: 0                                                  00108000
//*                                                                     00108400
//*01* EXIT-ERROR:  MODEL LOGSTREAM NOT DELETED. THE JOBLOG CONTAINS    00108900
//*                 INFORMATIONAL MESSAGES ABOUT THE ERROR.             00109400
//*02* RETURN-CODES: NON-ZERO VALUE                                     00109900
//*                                                                     00110400
//*-------------------------------------------------------------------- 00110900
//DELETE   EXEC PGM=IXCMIAPU,COND=(0,NE,DEFINE)                         00111400
//SYSPRINT DD SYSOUT=*                                                  00111900
//SYSABEND DD SYSOUT=*                                                  00112400
//SYSIN    DD *                                                         00112900
 DATA TYPE (LOGR) REPORT(NO)                                            00113300
    DELETE LOGSTREAM NAME(TSOUSER.ZAI.LSMODEL)                          00113800
    DELETE LOGSTREAM NAME(TSOUSER.ZAI.LSTREAM)                          00114300
/*                                                                      00114800

./ ADD NAME=AIZBLKE
/* REXX **************************************************************/
/*                                                                   */
/*01* Name: AIZBLKE                                                  */
/*                                                                   */
/*01* Descriptive Name = Sample zAware Bulk Load Client REXX exec    */
/*                                                                   */
/*01* PROPRIETARY STATEMENT=                                         */
/*                                                                   */
/*    LICENSED MATERIALS - PROPERTY OF IBM                           */
/*    5650-ZOS COPYRIGHT IBM CORP. 2013,2015                         */
/*                                                                   */
/* STATUS = HBB77A0                                                  */
/*                                                                   */
/*01* Function:  Import archived SYSLOG records to zAware server     */
/*                                                                   */
/*02* Operation:                                                     */
/*                                                                   */
/*      - Validate the request value                                 */
/*      - If CREATECNTLS, allocate a new control dataset             */
/*      - If DISPLAYCNTLS, display the list of SYSLOG datasets       */
/*      - If ADDSYSLOGDSN, add the given dataset name to the         */
/*           control dataset                                         */
/*      - If REMOVESYSLOGDSN, remove the given dataset name from the */
/*           control dataset                                         */
/*      - If IMPORT, read each dataset in the control dataset and    */
/*           queue the SYSLOG records to a zAware server via a       */
/*           ZAI log stream. As written, there is a limit of 1024MB  */
/*           on the amount of data imported.                         */
/*                                                                   */
/*02* Usage:                                                         */
/*                                                                   */
/*      - AIZBLKE control-dsn CREATECNTLS                            */
/*      - AIZBLKE control-dsn ADDSYSLOGDSN syslog-dsn                */
/*      - ... more adds if needed                                    */
/*      - AIZBLKE control-dsn DISPLAYCNTLS                           */
/*      - AIZBLKE control-dsn IMPORT dummy stream-name model-name    */
/*                                                                   */
/*02* Modifications:                                                 */
/*                                                                   */
/*      Block comments containing '*-*-*-*-*-*' are used to          */
/*      highlight areas that may require modifications.              */
/*                                                                   */
/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
/*                                                                   */
/*02* Dependencies:                                                  */
/*                                                                   */
/*      (1) The archived SYSLOG records are in HCL/HCR format. If    */
/*          not, routine Read_Syslog must be modifed to transform    */
/*          each record into the HCL/HCR SYSLOG format. Refer to MVS */
/*          Planning: Operations, The Hardcopy Medium.  Also, refer  */
/*          to 'SYS1.MODGEN(IHAHCLOG)'.                              */
/*                                                                   */
/*      (2) The datasets containing the archived SYSLOG records are  */
/*          sequential datasets.  If not, routine Read_Syslog must   */
/*          be modified to appropriately allocate the datasets.      */
/*          Note that GDG generations that are sequential data sets  */
/*          can be referenced by absolute names also.                */
/*                                                                   */
/*      (3) DFSMShsm must be available. If not, routines RecallDsn   */
/*          and MigrateDsn must be modified to use the available     */
/*          product interfaces.                                      */
/*                                                                   */
/*      (4) zAware does not expect SYSLOG data to contain ANSI       */
/*          carriage control characters in column 1. If the data set */
/*          to be imported contains ANSI carriage control characters */
/*          the data set's RECFM must include A (e.g. VBA, FBA).     */
/*          Otherwise, the ANSI characters are not removed and the   */
/*          zAware server will not be able to process the data.      */
/*                                                                   */
/*      (5) zAware does not expect SYSLOG data to contain machine    */
/*          control characters in column 1. If the data set to be    */
/*          imported contains machine control characters the data    */
/*          set's RECFM must include M (e.g. VBM, FBM). Otherwise,   */
/*          the machine characters are not removed and the           */
/*          zAware server will not be able to process the data.      */
/*                                                                   */
/*      (6) This exec provides for terminating the IMPORT when a     */
/*          predefined limit on the number of bytes written is       */
/*          reached. Refer to g.MaxImportBytes.  The limit applies   */
/*          for each IMPORT request.  If you import a large number   */
/*          of SYSLOG data sets (say, 90 days in one IMPORT), you    */
/*          may need to increase the limit. If you import from a     */
/*          large dataset (say, a 8-way SYSPLEX), you may need to    */
/*          increase the limit.                                      */
/*                                                                   */
/*      (7) This exec provides for very large SYSLOG datasets by     */
/*          reading a fixed number of records from the dataset.      */
/*          Refer to g.Chunk. Increasing the size of this value      */
/*          may improve performance, at a cost of requiring more     */
/*          private storage usage in the address space where the     */
/*          exec is run (TSO or initiator).                          */
/*                                                                   */
/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
/*                                                                   */
/*02* Character Code Dependencies: EBCDIC                            */
/*                                                                   */
/*02* Restrictions:                                                  */
/*      - Must be run in a TSO/E address space, interactive or batch */
/*      - AIZBLKR must be in the linklist concatenation              */
/*      - AIZBLKM must be in the linklist concatenation              */
/*                                                                   */
/*02* Invocation:                                                    */
/*                                                                   */
/*    AIZBLKE CntlDsn Request Name LSname LSmodel                    */
/*                                                                   */
/*        CntlDsn   - Contains a list of datasets containing         */
/*                    archived SYSLOG records to be imported to a    */
/*                    zAware server.                                 */
/*                                                                   */
/*        Request   - One of the following:                          */
/*                    CREATECNTLS                                    */
/*                    DISPLAYCNTLS                                   */
/*                    ADDSYSLOGDSN                                   */
/*                    REMOVESYSLOGDSN                                */
/*                    IMPORT                                         */
/*                                                                   */
/*        Name      - A dataset name to be added to or removed from  */
/*                    the dataset specified by CntlDsn.              */
/*                                                                   */
/*        LSname    - A 1-26 character log stream name, to be        */
/*                    defined as the conduit for importing records.  */
/*                                                                   */
/*        LSmodel   - A 1-26 character model log stream name, to be  */
/*                    used to define the log stream named by LSname. */
/*                    The model log stream must be preallocated with */
/*                    the desired log stream characteristics.        */
/*                                                                   */
/*01* Module Type: TSO REXX command                                  */
/*                                                                   */
/*02* Processor: REXX                                                */
/*                                                                   */
/*-------------------------------------------------------------------*/
/*                                                                   */
/*01* Entry-Point: AIZBLKE                                           */
/*                                                                   */
/*01* Input:                                                         */
/*           - Function:  CREATECNTLS                                */
/*             - CntlDsn  - A valid sequential data set name         */
/*                                                                   */
/*           - Function:  DISPLAYCNTLS                               */
/*             - CntlDsn  - A valid sequential data set name         */
/*                                                                   */
/*           - Function:  ADDSYSLOGDSN                               */
/*             - CntlDsn  - A valid sequential data set name         */
/*             - Name     - An existing data set name containing     */
/*                          archived SYSLOG records. May contain a   */
/*                          * for a single level (e.g. TSOUSER.*.A)  */
/*                          to add multiple datasets.                */
/*                                                                   */
/*           - Function:  REMOVESYSLOGDSN                            */
/*             - CntlDsn  - A valid sequential data set name         */
/*             - Name     - A data set name in the CntlDsn dataset,  */
/*                          no * allowed                             */
/*                                                                   */
/*           - Function:  IMPORT                                     */
/*             - CntlDsn  - A valid sequential data set name         */
/*                          containing one or more archived          */
/*                          SYSLOG datasets                          */
/*             - LSname   - Name of the log stream to be created,    */
/*                          is deleted if its already exists         */
/*             - LSmodel  - Name of a prexisting model log stream    */
/*                                                                   */
/*01* Output: None                                                   */
/*                                                                   */
/*01* Exit-Normal:  Return                                           */
/*                                                                   */
/*02* Return-Codes: 0                                                */
/*                                                                   */
/*           - Function:  CREATECNTLS                                */
/*                        Data set is created                        */
/*                                                                   */
/*           - Function:  DISPLAYCNTLS                               */
/*                        Data set contents are displayed            */
/*                                                                   */
/*           - Function:  ADDSYSLOGDSN                               */
/*                        Data set is added to the CntlDsn           */
/*                                                                   */
/*           - Function:  REMOVESYSLOGDSN                            */
/*                        Data set is removed from the CntlDsn       */
/*                                                                   */
/*           - Function:  IMPORT                                     */
/*                        SYSLOG records from the CntlDsn data       */
/*                        sets are written to the log stream and     */
/*                        queued for processing by a zAware server.  */
/*                                                                   */
/*01* Exit-Error:   Return                                           */
/*                                                                   */
/*02* Return-Codes: 4 - Invalid Request value.                       */
/*    Return-Codes: 8 - The requested operation failed.              */
/*    Return-Codes:12 - The requested operation exceeded the         */
/*                      maximum bytes specified in the field         */
/*                      g.maxImportBytes                             */
/*                                                                   */
/*-------------------------------------------------------------------*/
/*                                                                   */
/*01* External References:                                           */
/*                                                                   */
/*02*   Routines:                                                    */
/*        AIZBLKR  - zAware Bulk Load Client Command Processor       */
/*                                                                   */
/*01* Change Activity:                                               */
/*                                                                   */
/* $L0=ME23640 HBB7790  120228  PDEV: zAware Bulk Load Client        */
/* $P1=ME24062 HBB7790  120503  PDEV: Handle ANSI control chars      */
/* $P2=ME24077 HBB7790  120503  PDEV: Handle large datasets better   */
/* $P3=ME24153 HBB7790  120516  PDEV: Handle multi-volume datasets   */
/* $P4=ME24600 HBB7790  120820  PDEV: numeric digits 15              */
/* $P5=OA40388 HBB7790  121115  PDEV: total lines sent, max rc       */
/* $01=OA42095 HBB7790  130613  PDFY: Handle Machine control chars   */
/* $P6=ME28985 HBB77A0  150305  PDFY: Non-zero RC for byte limit     */
/*                                                                   */
/*********************************************************************/
parse upper arg CntlDsn Request Name LSName LSModel .
parse source . . g.ThisExec .
numeric digits 15

/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
/* Dataset allocation variables that may need to change for local    */
/* conventions.                                                      */
/*                                                                   */
g.DDNAME = 'TEMP' /* The DD name used on TSO ALLOCATE calls */
g.CNTLDSNOPT = 'NEW CATALOG TRACKS SP(1 1) BLKSIZE(80) LRECL(80) '!!,
               'RECFM(F) UNIT(SYSALLDA)' /* Control dataset attrs */

/* IMPORT control variables that may need to change, based on the    */
/* size of the SYSLOG data sets or the number of SYSLOG data sets.   */
/*                                                                   */
g.Chunk = 2500000       /* Limit, in records, read at one time       */
g.MaxImportBytes = 1024 /* Limit, in Megabytes, written during the
                           job.                                      */
/*                                                                   */
/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/

/* Read_Syslog values
*/
g.ReadFailure = 0 /* dataset records not read          */
g.ReadSuccess = 1 /* dataset records read successfully */
g.ReadEOF     = 2 /* EOF reached                       */

/* RecallDsn return values
*/
g.RecallFailed     = -1 /* Recall attempted but did not complete */
g.MigrateNeeded    =  1 /* Recall attempted and was successful   */
g.MigrateNotNeeded =  0 /* Dataset was not migrated              */

/* AIZBLKE Return codes
*/
g.RcSuccess        = 0 /* Successful operation     */
g.RcInvalidRequest = 4 /* An invalid request value */
g.RcFailure        = 8 /* Unsuccessful operation   */
g.RcImportByteLimitExceeded = 12 /* g.MaxImportBytes exceeded ‡P6A*/

trace o

/* Process the request
*/
Select
 /* Allocate the control data set */
 When Request = 'CREATECNTLS' then
   g.ZaiRc = CreateControlDataset(CntlDsn)

 /* Display the contents of the control data set */
 When Request = 'DISPLAYCNTLS' then
   g.ZaiRc = DisplayControlDataset(CntlDsn)

 /* Add a SYSLOG data set from the control data set */
 When Request = 'ADDSYSLOGDSN' then
   g.ZaiRc = AddSyslogDataset(CntlDsn,Name)

 /* Remove a SYSLOG data set from the control data set */
 When Request = 'REMOVESYSLOGDSN' then
   g.ZaiRc = RemoveSyslogDataset(CntlDsn,Name)

 /* Send SYSLOG records to zAware */
 When Request = 'IMPORT' Then
   g.ZaiRc = Import(CntlDsn,LSModel,LSName)

 /* Unrecognized request value */
 Otherwise
  Do
   g.ZaiRc = g.RcInvalidRequest

   If Request = '' Then
     Say 'A request value is required.'
   Else
     Say Request 'is an unsupported request value.'
  End
End /* Process the request */

Say g.ThisExec 'ended with a return code of' g.ZaiRc'.'

Return g.ZaiRc

/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
/* Routine: Read_Syslog                                              */
/*                                                                   */
/* Inputs: theDsn - the dataset to be read, fully qualified and      */
/*                  unquoted                                         */
/*                                                                   */
/* Operation: Reads archived SYSLOG dataset records into storage     */
/*            and prepares each record for importing into zAware.    */
/*                                                                   */
/* Outputs: g.ReadSuccess - dataset records read successfully        */
/*          g.ReadFailure - unable to allocate or read the dataset   */
/*                                                                   */
/* Restrictions: zAware requires variable length HCL/HCR format      */
/*               SYSLOG records terminated by a '15'x character.     */
/*               IBM zAware requires that all ANSI and machine       */
/*               machine characters in column 1 be removed.          */
/*                                                                   */
/* Customizations: If HCL/HCR SYSLOG datasets are not targeted,      */
/*                 modify this routine to transform each dataset     */
/*                 record into HCL/HCR format. See MVS macro         */
/*                 'SYS1.MODGEN(IHAHCLOG)'.                          */
/*                                                                   */
/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
Read_Syslog: Procedure expose g.
  parse arg theDsn .
  theDsn = strip(theDsn) /* eliminate leading/trailing blanks */

  g.RecordArray.  = '' /* Clear the stem variable */
  g.RecordArray.0 = 0  /* Assume nothing is found */

  wasRead = g.ReadFailure /* Assume the worst */

  /* EXECIO for REXX ignores trailing blanks, so each record
     will have a varying length.
  */
  Address MVS "EXECIO" g.Chunk "DISKR" g.DDName "(STEM g.RecordArray."
  readRC = rc

  /* We read the next chunk
  */
  If readRC = 0 ! readRC = 2 Then
   Do
    wasRead = g.ReadSuccess /* All is well */

    /* We reached the end of the file, process the data and tell the
       caller to stop reading
    */
    If readRC = 2 Then
      wasRead = g.ReadEOF

    /* Ignore column 1 when there are control characters, otherwise
       pass all columns                                          ‡01C*/
    If g.control = 1 Then                                     /* ‡01C*/
      Do i = 1 To g.RecordArray.0
        g.RecordArray.i = substr(g.RecordArray.i,2)!!'15'x
      End
    Else
      Do i = 1 To g.RecordArray.0
        g.RecordArray.i = g.RecordArray.i!!'15'x
      End
   End
  Else /* A problem was encountered */
    Say "EXECIO DISKR of '"theDsn"' failed, RC ="!!readRC

Return wasRead

/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
/* Routine: RecallDsn                                                */
/*                                                                   */
/* Inputs: theDsn - the dataset to be recalled, fully qualified and  */
/*                  unquoted                                         */
/*                                                                   */
/* Operation: Recall a migrated dataset                              */
/*                                                                   */
/* Outputs: g.MigrateNotNeeded - Dataset not migrated                */
/*          g.MigrateNeeded    - Dataset recalled                    */
/*          g.RecallFailed     - Unable to recall dataset            */
/*                                                                   */
/* Requirements: The Import routine expects that the dataset has     */
/*               been recalled on return. Therefore, this routine    */
/*               must wait for the recall to complete.               */
/*                                                                   */
/* Customizations: If DFSMShsm not available, modify this routine to */
/*                 use the installed product interfaces.             */
/*                                                                   */
/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
RecallDsn: Procedure expose g.
  parse arg theDsn .
  theDsn = strip(theDsn) /* Get rid of leading/trailing blanks */

  isMigrated = g.MigrateNotNeeded

  /* Extract the data set information without a recall
  */
  dsiRC = LISTDSI("'"theDsn"' NORECALL")

  /* If the data set is migrated, attempt a recall
     The exec must wait for the recall to complete.
  */
  If dsiRC=16 & SYSREASON=9 Then /* dataset is migrated */
   Do;
    isMigrated = g.MigrateNeeded

    Say "Recalling '"theDsn"'"
    cmd = 'HRECALL' /* Recall command */
    Address TSO cmd "'"!!theDsn!!"' WAIT"
    If rc ^= 0 Then
     Do
      isMigrated = g.RecallFailed
      Say cmd "of '"!!theDsn!!"' failed, RC="!!rc
     End
   End;

Return isMigrated

/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
/* Routine: MigrateDsn                                               */
/*                                                                   */
/* Inputs: theDsn - the dataset to be migrated, fully qualified and  */
/*                  unquoted                                         */
/*                                                                   */
/* Operation: Performs a DFSMShsm Migrate for a dataset              */
/*                                                                   */
/* Outputs: None                                                     */
/*                                                                   */
/* Customizations: If DFSMShsm not available, modify for the         */
/*                 installed product                                 */
/*                                                                   */
/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
MigrateDsn: Procedure expose g.
  parse arg theDsn .
  theDsn = strip(theDsn) /* Get rid of leading/trailing blanks */

  /* Attempt a migrate
  */
  Say "Migrating '"theDsn"'"
  cmd = 'HMIGRATE' /* Migrate command */
  Address TSO cmd "'"!!theDsn!!"' WAIT"
  If rc ^= 0 Then
    Say cmd "of '"!!theDsn!!"' failed, RC="!!rc

Return

/*-------------------------------------------------------------------*/
/* Routine: Import                                                   */
/*                                                                   */
/* Inputs: ControlDsn - Control dataset name                         */
/*         LSModel    - model log stream name                        */
/*         LSName     - log stream name                              */
/*                                                                   */
/* Operation:                                                        */
/*                                                                   */
/*   1 Initialize a AIZBLKR session                                  */
/*   2 For each SYSLOG dataset name                                  */
/*     - Read the SYSLOG dataset records                             */
/*     - For each SYSLOG record                                      */
/*       o If the write buffer is full, write the buffer via AIZBLKR */
/*       o Add the record to the write buffer                        */
/*     - Write the remaining records via AIZBLKR                     */
/*   3 Cleanup the AIZBLKR session                                   */
/*                                                                   */
/* Outputs: Highest AIZBLKE error encountered                        */
/*                                                                   */
/*-------------------------------------------------------------------*/
Import: Procedure expose g.
 parse upper arg ControlDsn,LSModel,LSName

 /* AIZBLKR request values
 */
 AIZBLKR_INIT    = 'INIT'
 AIZBLKR_WRITE   = 'WRITE'
 AIZBLKR_CLEANUP = 'CLEANUP'

 /* Limit the amount of data written to the log stream
 */
 aMB = 1024*1024
 ByteLimit = g.MaxImportBytes*aMB

 InitRc  = g.RcSuccess
 ReadRc  = g.RcSuccess
 WriteRc = g.RcSuccess

 /* Return code for request
 */
 ReadRc_request  = g.RcSuccess
 WriteRc_request = g.RcSuccess

 /* Allocate the dataset, leave if we can not
 */
 Say "Reading control dataset '"!!ControlDsn!!"'."
 If AllocCntlDsn(ControlDsn,'SHR') ^= g.RcSuccess Then
   Return g.RcFailure

 /* Read the list of SYSLOG data set names from the
    control data set and free the DD
 */
 Address MVS "EXECIO * DISKR" g.DDName "(FINIS STEM dsns."
 InitRc = rc
 Address TSO "FREE F("g.DDName")"

 /* If the read failed, say so and return
 */
 If CheckExecIoResult(ControlDsn,InitRc) ^= g.RcSuccess Then
   Return g.RcFailure

 /* Initialize a AIZBLKR session.

    The REXX variables used on the LINKMVS call for output
    values must be the proper size to allow return of the values.

    The returned value for BufferPtr must not be modified by this
    exec and must be provided on a subsequent AIZBLKR CLEANUP call,
    otherwise the storage will not be freed.

    The returned value for BufferLen denotes the maximum amount of
    data, in bytes, that can be provided on a single AIZBLKR WRITE
    request.

    The returned value for LSToken represents the log stream
    connection for this AIZBLKR session, it must not be modified by
    this exec. This value must be provided on all subsequent AIZBLKR
    calls.
 */
 BufferPtr = right(0,8,'0')        /* 8 char value, do not modifyß   */
 BufferLen = right(0,8,'0')        /* 8 char value, do not modifyß   */
 LSToken   = copies('00'X,16)      /* 16 byte value, do not modifyß  */
 Address LINKMVS 'AIZBLKR AIZBLKR_INIT '!!,
                 'BufferPtr BufferLen LSToken LSModel LSName'
 InitRC = CheckAizBlkrResult(AIZBLKR_INIT,rc)

 /* No worries...
 */
 If InitRc = g.RcSuccess Then
  Do /* AIZBLKR INIT ok */
   /* For later consumption, we track the total number of bytes
      written to the target log stream. This information will
      be useful to validate the amount of data imported to zAware
   */
   BytesWritten = 0
   TotalRecordsWritten = 0

   /* Loop thru the list of SYSLOG dataset names
   */
   Do i = 1 To dsns.0,
      While BytesWritten < ByteLimit
    dsns.i = strip(dsns.i) /* get rid of any leading/trailing blanks */

    /* skip any comment lines, note that line remarks are not allowed
    */
    If index(dsns.i,'/*')^=0 & index(dsns.i,'*/')^=0 &,
       index(dsns.i,'/*') < index(dsns.i,'*/') Then
      Iterate

    /* Ensure that the dataset is not migrated. Skip if the
       recall fails.
    */
    RecallOutcome = RecallDsn(dsns.i)
    If RecallOutcome = g.RecallFailed Then
     Do
      ReadRc = g.RcFailure
      ReadRc_request = MAX(ReadRc_request,g.RcFailure)
      Iterate
     End

    /* Determine whether or not the dataset has control chars
       and remember, Read_Syslog will need to deal with them later.
    */
    dsiRC = LISTDSI("'"dsns.i"' NORECALL")

    /* LISTDSI 4/19 simply means you have a multi-volume dataset,
       treat as a successfull call
    */
    If dsiRC = 0 ! (dsiRC = 4 & SYSREASON = 19) Then
     Do
      If pos('A',SYSRECFM) > 0 Then /* Has ANSI in column 1 */
       Do
        g.control = 1                                         /* ‡01C*/
        Say "'"dsns.i"' is a data set with ANSI control characters,"!!,
            " stripping off column 1."                        /* ‡01C*/
       End
      Else If pos('M',SYSRECFM) > 0 Then /* Has Machine control chars
                                            in column 1          ‡01A*/
       Do
        g.control = 1                                         /* ‡01A*/
        Say "'"dsns.i"' is a data set with machine control "!!,
            "characters, stripping off column 1."             /* ‡01A*/
       End
      Else /* No control chars */
       Do
        g.control = 0                                         /* ‡01C*/
        Say "'"dsns.i"' does not contain control characters." /* ‡01C*/
       End
     End
    Else /* LISTDSI unexpected error */
     Do
      Say "LISTDSI of '"dsns.i"' failed, RC="!!dsiRC!!", SYSREASON="!!,
          SYSREASON
      ReadRc = g.RcFailure
      ReadRc_request = MAX(ReadRc_request,g.RcFailure)
      Iterate
     End

    /* Allocate the SYSLOG dataset, skipping if we are unable to
       do so
    */
    address TSO "ALLOC F("g.DDName") DA('"dsns.i"') SHR REUS"
    If rc ^= 0 Then
     Do
      Say "ALLOCATE of '"dsns.i"' failed, RC="!!rc
      ReadRc = g.RcFailure
      ReadRc_request = MAX(ReadRc_request,g.RcFailure)
      Iterate
     End

    /* Open the dataset for reading
    */
    Address MVS "EXECIO 0 DISKR" g.DDName "(OPEN"

    Do Until readDone = g.readEOF
      /* Read the SYSLOG records into g.RecordArray. Skip if the
         read fails.
      */
      readDone = Read_SysLog(dsns.i)
      If readDone = g.ReadFailure Then
       Do
        ReadRc = g.RcFailure
        ReadRc_request = MAX(ReadRc_request,g.RcFailure)
        Iterate
       End

      If g.RecordArray.0 > 0 Then
        Say "Importing" AddCommas(g.RecordArray.0)!!,
            " records from '"dsns.i"'."
      Else
        Say "Skipping empty dataset '"dsns.i"'."

      RecordsWritten = 0

      /* Start filling the buffer from the beginning
      */
      NextEntry = x2d(BufferPtr) /* must do decimal math */
      BufferDataSize = 0

      /* Loop thru the SYSLOG records, filling the buffer with
         records and writing the buffer when full.
      */
      Do j = 1 To g.RecordArray.0,
         While BytesWritten < ByteLimit
        /* See where this record will land in the buffer
        */
        Lrecl = length(g.RecordArray.j)
        NextWriteEnd = BufferDataSize + Lrecl

        /* The record won't fit in the buffer, time to do a write
        */
        If NextWriteEnd > BufferLen Then
         Do /* Buffer full */
          BufferDataSize = right(BufferDataSize,8,'0')
          Address LinkMVS 'AIZBLKR AIZBLKR_WRITE '!!,
                          'BufferPtr BufferDataSize LSToken'
          WriteRC = CheckAizBlkrResult(AIZBLKR_WRITE,rc)
          WriteRC_request = MAX(WriteRC,WriteRC_request)

          /* Reset the buffer controls
          */
          NextEntry = x2d(BufferPtr) /* must do decimal math */
          BufferDataSize = 0
         End /* Buffer full */

        RecordsWritten = RecordsWritten + 1

        /* Append the record to the write buffer
        */
        x = Storage(d2x(NextEntry),lrecl,g.RecordArray.j)
        BufferDataSize = BufferDataSize + Lrecl
        BytesWritten = BytesWritten + Lrecl

        /* Move past the record just copied
        */
        NextEntry = NextEntry + Lrecl
      End /* RecordArray loop */

      If BytesWritten >= ByteLimit Then
       Do                                                    /* ‡P6A*/
        Say 'Limit of' ByteLimit/aMB 'MB reached, '!!,
            'IMPORT ending.'
        WriteRC_request = MAX(WriteRC_request,
                              g.RcImportByteLimitExceeded)   /* ‡P6A*/
       End                                                   /* ‡P6A*/

      /* Flush the buffer
      */
      If BufferDataSize > 0 Then
       Do /* Last write buffer */
        BufferDataSize = right(BufferDataSize,8,'0')
        Address LinkMVS 'AIZBLKR AIZBLKR_WRITE '!!,
                        'BufferPtr BufferDataSize LSToken'
        WriteRC = CheckAizBlkrResult(AIZBLKR_WRITE,rc)
        WriteRC_request = MAX(WriteRC,WriteRC_request)
       End /* Last write buffer */

      /* Check that we wrote all the records
      */
      If g.RecordArray.0 > 0 Then
       Do
        TotalRecordsWritten = TotalRecordsWritten + RecordsWritten
        If RecordsWritten = g.RecordArray.0 Then
          Say 'All' AddCommas(g.RecordArray.0) 'records written.'
        Else
          Say 'Expected to write' AddCommas(g.RecordArray.0)!!,
              ' records, actually wrote' AddCommas(RecordsWritten)!!,
              ' records.'
       End
    End /* Read Chunk loop */

    /* Close and free the SYSLOG dataset
    */
    Address MVS "EXECIO 0 DISKR" g.DDName "(FINIS"
    Address TSO "FREE F("g.DDName")"

    /* If data set was recalled, migrate it back again
    */
    If RecallOutcome = g.MigrateNeeded Then
      Call MigrateDsn(dsns.i)
   End  /* data set loop */

   Say '--------------------------------------' /* separator */
   Say AddCommas(BytesWritten) "bytes queued to zAware."
   Say AddCommas(TotalRecordsWritten) "records queued to zAware."

   /* Cleanup our AIZBLKR session
   */
   Address LINKMVS "AIZBLKR AIZBLKR_CLEANUP "!!,
                   "BufferPtr BufferLen LSToken"
   x = CheckAizBlkrResult(AIZBLKR_CLEANUP,rc)
  End  /* AIZBLKR INIT ok */

Return Max(InitRc,ReadRc_request,WriteRC_request)

/*-------------------------------------------------------------------*/
/* Routine: CheckAizBlkrResult                                       */
/*                                                                   */
/* Inputs: Func       - AIZBLKR function requested                   */
/*         linkmvsRC  - LINKMVS/AIZBLKR return code                  */
/*                                                                   */
/* Operation:                                                        */
/*                                                                   */
/*   1 A negative value is a LINKMVS return code, issue the          */
/*     appropriate messages                                          */
/*   2 Any other value is a AIZBLKR return code, issue the           */
/*     appropriate messages                                          */
/*                                                                   */
/* Outputs: g.RcSuccess - the AIZBLKR call returned a zero rc        */
/*          g.RcFailure - LINKMVS or AIZBLKR return a non-zero rc    */
/*                                                                   */
/*-------------------------------------------------------------------*/
CheckAizBlkrResult: Procedure expose g.
  parse arg Func,linkmvsRC

  outRC = g.RcFailure /* Assume the worst */

  Select
   When(linkmvsRC = 0) Then
     outRC = g.RcSuccess

   When(linkmvsRC = -3) Then
     Say 'LINKMVS is unable to locate AIZBLKR.'

   When(linkmvsRC = -2) Then
     Say 'LINKMVS is unable to process its parameters.'

   When(linkmvsRC = 4) Then
     Say 'The AIZBLKR request' Func 'is not known.'

   When(linkmvsRC = 8) Then
     Say 'The AIZBLKR' Func 'failed, look for AIZxxxI messages.'

   When(linkmvsRC = 12) Then
     Say 'Invalid parameters were passed to AIZBLKR' Func !!,
         ' look for AIZxxxI messages.'

   When(linkmvsRC = 16) Then
     Say 'AIZBLKR' Func 'failed unexpectedly, '!!,
         'look for a SYSABEND dump or a SYMPTOM DUMP message.'

   When(linkmvsRC = 20) Then
     Say 'AIZBLKR' Func 'failed unexpectedly, '!!,
         'unable to create an ESTAE recovery environment.'

   Otherwise
     Say 'An unexpected AIZBLKR' Func 'failure, RC='!!linkmvsRC
  End /* select */

Return outRC

/*-------------------------------------------------------------------*/
/* Routine: CreateControlDataset                                     */
/*                                                                   */
/* Inputs: ControlDsn - Control dataset name                         */
/*                                                                   */
/* Operation:                                                        */
/*                                                                   */
/*   1 Delete any existing dataset                                   */
/*   2 Allocate a new dataset                                        */
/*   3 Add a comment line                                            */
/*                                                                   */
/* Outputs: g.RcSuccess - control dataset allocated                  */
/*          g.RcFailure - control dataset not allocated, an existing */
/*                        control dataset may have been deleted      */
/*                                                                   */
/*-------------------------------------------------------------------*/
CreateControlDataset: Procedure expose g.
 parse arg ControlDsn

 /* Delete any existing dataset, quietly.
    If delete fails, try an uncatalog.
 */
 x = outtrap('lines.')
 Address TSO "DELETE '"ControlDsn"'"
 allocrc = rc
 x = outtrap('OFF')

 If allocrc=0 Then
   Say "An old copy of '"ControlDsn"' has been deleted."
 Else
  If allocrc>8 Then
    Address TSO "DELETE '"ControlDsn"' NOSCR"

 /* Allocate a new dataset
 */
 address TSO "ALLOC F("g.DDName") DA('"ControlDsn"')" g.CNTLDSNOPT
 If rc^=0 Then
  Do
   Say "ALLOCATE of control dataset '"ControlDsn"' failed, RC="rc
   Return g.RcFailure
  End

 /* Add a comment line so the dataset is not empty
 */
 queue left("/* List of SYSLOG files to be imported to zAware */",80)
 Address MVS "EXECIO" queued() "DISKW" g.DDName "(FINIS"
 allocrc = rc
 Address TSO "FREE F("g.DDName")"

 /* It didn't work...
 */
 If CheckExecIoResult(ControlDsn,allocrc) ^= g.RcSuccess Then
   Return g.RcFailure

 /* It worked
 */
 Say "Control dataset '"ControlDsn"' created."

Return g.RcSuccess

/*-------------------------------------------------------------------*/
/* Routine: DisplayControlDataset                                    */
/*                                                                   */
/* Inputs: ControlDsn - Control dataset name                         */
/*                                                                   */
/* Operation:                                                        */
/*                                                                   */
/*   1 Allocate the dataset                                          */
/*   2 Read the dataset                                              */
/*   3 Display each line from the dataset                            */
/*                                                                   */
/* Outputs: g.RcSuccess - control dataset displayed                  */
/*          g.RcFailure - control dataset not displayed              */
/*                                                                   */
/*-------------------------------------------------------------------*/
DisplayControlDataset: Procedure expose g.
 parse arg ControlDsn

 /* Allocate the dataset, leave if we can not
 */
 If AllocCntlDsn(ControlDsn,'SHR') ^= 0 Then
   Return g.RcFailure

 /* Read the dataset and free the dataset
 */
 Address MVS "EXECIO * DISKR" g.DDName "(FINIS STEM data."
 allocrc = rc
 Address TSO "FREE F("g.DDName")"

 /* The read failed
 */
 If CheckExecIoResult(ControlDsn,allocrc) ^= g.RcSuccess Then
   Return g.RcFailure

 /* Display the dataset lines
 */
 Do i=1 to data.0
  If strip(data.i) ^= '' Then
    Say 'Line' right(i,3,' ') '-' strip(data.i)
 End

return g.RcSuccess

/*-------------------------------------------------------------------*/
/* Routine: AddSyslogDataset                                         */
/*                                                                   */
/* Inputs: ControlDsn - Control dataset name                         */
/*         dsn        - SYSLOG dataset name to be added              */
/*                                                                   */
/* Operation:                                                        */
/*                                                                   */
/*   1 Allocate the dataset                                          */
/*                                                                   */
/* Outputs: g.RcSuccess - dataset name added to control dataset      */
/*          g.RcFailure - dataset name not added to control dataset  */
/*                                                                   */
/*-------------------------------------------------------------------*/
AddSyslogDataset: Procedure expose g.
 parse upper arg ControlDsn,dsn

 dsn = strip(dsn) /* eliminate leading/trailing blanks */

 /* Allocate the dataset, leave if we can not
 */
 If AllocCntlDsn(ControlDsn,'OLD') ^= 0 Then
   Return g.RcFailure

 /* Read the dataset and reset the file pointer to 0
 */
 address MVS "EXECIO * DISKR" g.DDName "(FINIS STEM dsns."
 AddRC = CheckExecIoResult(ControlDsn,rc)

 If AddRC = g.RcSuccess Then
  Do /* Read ok */
   /* Assemble all the dataset names into a blank-delimited string
   */
   alldsns = ''
   Do j = 1 To dsns.0
     alldsns = alldsns' 'strip(dsns.j)
   End

   /* The user provided dataset might contain a wildcard, get the
      real list
   */
   Call GetDsnList(dsn)

   /* Found some datasets to be added
   */
   If g.dsnlist.0 > 0 Then
    Do /* Add some datasets */
      AddRC = g.RcSuccess

      /* We need to combine the two lists into one and update
         the control data set
      */
      Do i = 1 To dsns.0
        CompleteList.i = dsns.i
      End

      /* While adding the new dataset, looks for duplicates
      */
      k = dsns.0
      Do i = 1 To g.dsnlist.0
       If wordpos(g.dsnlist.i,alldsns)^=0 Then
        Do
          AddRC = g.RcFailure
          Say "'"g.dsnlist.i"' already exists in the control dataset."
        End
       Else
        Do
         k = k + 1
         CompleteList.k = g.dsnlist.i
         CompleteList.0 = k
        End
      End

      If AddRC = g.RcSuccess Then /* No duplicates found */
       Do
        address MVS "EXECIO" CompleteList.0 "DISKW" g.DDNAME!!,
                            " (FINIS STEM CompleteList."
        AddRC = CheckExecIoResult(ControlDsn,rc)
        If AddRc = g.RcSuccess Then
          outmsg = 'added'
        Else
          outmsg = 'not added'

        Do i = 1 To g.dsnlist.0
          Say "Dataset '"g.dsnlist.i"'" outmsg "to '"ControlDsn"'"
        End
       End
    End /* Add some datasets */
   Else
    Do
     AddRC = g.RcFailure
     Say "No datasets found for '"dsn"'"
    End
  End /* Read ok */

 /* Free the dataset
 */
 address TSO "FREE F("g.DDName")"

Return AddRC

/*-------------------------------------------------------------------*/
/* Routine: RemoveSyslogDataset                                      */
/*                                                                   */
/* Inputs: ControlDsn - Control dataset name                         */
/*         dsn        - SYSLOG dataset name to be removed            */
/*                                                                   */
/* Operation:                                                        */
/*                                                                   */
/*   1 Allocate the dataset                                          */
/*   2 Read the dataset                                              */
/*   3 Display each line from the dataset                            */
/*                                                                   */
/* Outputs: g.RcSuccess - control dataset displayed                  */
/*          g.RcFailure - control dataset not displayed              */
/*                                                                   */
/*-------------------------------------------------------------------*/
RemoveSyslogDataset: Procedure expose g.
 parse upper arg ControlDsn,dsn
 dsn = strip(dsn)

 /* Allocate the dataset, leave if we can not
 */
 If AllocCntlDsn(ControlDsn,'OLD') ^= 0 Then
   Return g.RcFailure

 /* Read the dataset and reset the file pointer to 0
 */
 address MVS "EXECIO * DISKR" g.DDName "(FINIS STEM dsns."
 RemoveRC = CheckExecIoResult(ControlDsn,rc)

 If RemoveRC = g.RcSuccess Then
  Do /* Read ok */
   /* Find the list entry containing the dataset to be deleted
   */
   FoundIt = 0
   Do i=1 to dsns.0
    If index(dsns.i,dsn)^=0 Then
      FoundIt = i
   End

   /* We found a match, process the remove
   */
   If FoundIt > 0 Then
    Do
     /* Copy the last entry into the list entry to be removed and
        clear the last entry. It's possible the last entry is the
        one to be removed. In that case, we're doing some extra
        work but no big deal
     */
     i = dsns.0
     dsns.FoundIt = dsns.i
     dsns.0 = dsns.0 - 1
     dsns.i = ''

     /* Write the updated dataset name list
     */
     address MVS "EXECIO * DISKW" g.DDName "(FINIS STEM dsns."
     RemoveRC = CheckExecIoResult(ControlDsn,rc)

     If RemoveRC = g.RcSuccess Then
       Say "Dataset '"dsn"' removed from '"ControlDsn"'"
    End
   Else /* no match */
    Do
     RemoveRC = g.RcFailure
     Say "Dataset '"dsn"' not found in '"ControlDsn"'"
    End
  End /* Read ok */

 /* Free the dataset
 */
 address TSO "FREE F("g.DDName")"

Return RemoveRC

/*-------------------------------------------------------------------*/
/* Routine: GetDsnList                                               */
/*                                                                   */
/* Inputs: dsn - a dataset name, where a single level may contain *  */
/*                                                                   */
/* Operation:                                                        */
/*                                                                   */
/*   1 Get a list of datasets matching the provided dataset name     */
/*     pattern.  A single level may contain a * (A.*.C)              */
/*   2 Update g.dsnlist with the list of dataset names               */
/*                                                                   */
/* Outputs: g.dsnlist stem variable updated to contain the dataset   */
/*          names to be added                                        */
/*                                                                   */
/*-------------------------------------------------------------------*/
GetDsnList: Procedure expose g.
 parse arg dsn
 dsn = strip(dsn)

 g.dsnlist. = '' /* Clear the stem variable */
 g.dsnlist.0 = 0 /* Assume nothing is found */

 /* List matching dataset names to a REXX stem variable
    The dataset name may or may not have a '*' for one of the levels
 */
 x = outtrap('lines.')
 Address TSO "LISTCAT ENTRIES('"dsn"')"
 listc_rc = rc
 x = outtrap('OFF')

 /* We got a list of datasets matching the ENTRIES specification,
    return then all. Must parse the output from LISTCAT...

    NONVSAM ------- TSOUSER.ZAI.CONTROL
         IN-CAT --- ICFCAT.UCAT29
 */
 If listc_rc = 0 Then
  Do
   z = 0

   Do i = 1 to lines.0
    If index(lines.i,'NONVSAM') Then
     Do
      z = z + 1
      g.dsnlist.z = word(lines.i,3)
     End
   End

   g.dsnlist.0 = z /* Set the number of dataset names in the stem */
  End
 Else
   Say "LISTCAT for dataset '"dsn"' failed, RC="listc_rc

Return

/*-------------------------------------------------------------------*/
/* Routine: AllocCntlDsn                                             */
/*                                                                   */
/* Inputs: theDsn - the Control dataset name                         */
/*                                                                   */
/* Operation: Allocate the dataset shared                            */
/*                                                                   */
/* Outputs: ALLOCATE return code                                     */
/*                                                                   */
/*-------------------------------------------------------------------*/
AllocCntlDsn: Procedure expose g.
 parse arg theDsn,mode

 address TSO "ALLOC F("g.DDName") DA('"theDsn"')" mode "REUSE"
 allocrc = rc
 If allocrc^=0 Then
   Say "ALLOCATE of control dataset '"theDsn"' failed, RC="allocrc

Return allocrc

/*-------------------------------------------------------------------*/
/* Routine: CheckExecIoResult                                        */
/*                                                                   */
/* Inputs: theDsn - the Control dataset name                         */
/*         execioRC - the EXECIO return code                         */
/*                                                                   */
/* Operation: issue an appropriate error messsage                    */
/*                                                                   */
/* Outputs: g.RcSuccess - EXECIO successfull                         */
/*          g.RcFailure - EXECIO unsuccessfull                       */
/*                                                                   */
/*-------------------------------------------------------------------*/
CheckExecIoResult: Procedure expose g.
 parse arg theDsn,execioRC

 outRC = g.RcSuccess
 If execioRC ^= 0 Then
  Do
   outRC = g.RcFailure
   Say "EXECIO of control dataset '"theDsn"' "!!,
       " failed, RC="execioRC
  End

Return outRC

/*-------------------------------------------------------------------*/
/* Routine: AddCommas                                                */
/*                                                                   */
/* Inputs: bytes - decimal number to be processed                    */
/*                                                                   */
/* Operation: add commas to the number as needed ( 1,234 )           */
/*                                                                   */
/* Outputs: the number w/commas added                                */
/*                                                                   */
/*-------------------------------------------------------------------*/
AddCommas: Procedure
  parse arg bytes

  bytes = bytes+0 /* get rid of leading zeros */
  size = length(bytes)

  numcomma = size%3   /* groups of 3 numbers */
  If size//3 = 0 Then /* But an exact multiple of 3 needs 1 less */
    numcomma = numcomma - 1

  line = ''
  Do i = 1 to numcomma
    line = ',' !! substr(bytes,size-((3*i)-1),3) !! line
  End
  line = substr(bytes,1,size-(numcomma*3)) !! line

Return line

./ ADD NAME=ALLOC
ALLOCATE   DATASET('DSNAME'/'LIST OF DSNAMES'/*)
              OR
           DUMMY
           FILE('DDNAME') ALTFILE('DDNAME')
           DEST('DESTINATION' OR 'NODE.USERID')
           NEW/OLD/MOD/SHR/SYSOUT('CLASS')
           VOLUME('SERIAL'/SERIAL LIST)/MSVGP('IDENTIFIER')
           SPACE('QUANTITY','INCREMENT') DIR('INTEGER')
           BLOCK('VALUE')/AVBLOCK('VALUE')/TRACKS/CYLINDERS
           USING('ATTR-LIST-NAME')
              OR
           LIKE('MODEL-DATASET-NAME')
           HOLD/NOHOLD
           UNIT('UNIT-TYPE')  UCOUNT('COUNT')/PARALLEL
           LABEL('LABEL-TYPE') POSITION('SEQUENCE-NUMBER')
           MAXVOL('VOL-COUNT') PRIVATE RELEASE
           VSEQ('VOL-SEQ-NUMBER') ROUND  REUSE
           KEEP/DELETE/CATALOG/UNCATALOG
           BFALN('BUFFER BOUNDARY ALIGNMENT')
           BFTEK('BUFFER TECHNIQUE')  BLKSIZE('BLOCK SIZE')
           BUFL('BUFFER LENGTH')  BUFNO('NUMBER OF BUFFERS')
           BUFOFF('BUFFER OFFSET')
           DEN('MAGNETIC TAPE DENSITY')
           DIAGNS('TRACE OPTION')
           DSORG('DATA SET ORGANIZATION')
           EROPT('ERROR OPTION')  KEYLEN('KEY LENGTH')
           LIMCT('LIMCT LENGTH')
           LRECL('LOGICAL RECORD LENGTH')
           NCP('MAX. NO. R/W MACROS')
           RECFM('RECORD FORMAT') TRTCH('RECORDING TECHNIQUE')
           INPUT  OUTPUT  RETPD('NNNNN')
           EXPDT('YYDDD' OR 'YYYY/DDD')
           FCB(IMAGE-ID,ALIGN/VERIFY)
           PROTECT
           ACCODE('CODE')
           BURST/NOBURST
           CHARS('CHARACTER SET','CHARACTER SET',...)
           COPIES('NNN',('GROUP VALUE','GROUP VALUE'...))
           FLASH('NAME','COPIES')
           MODIFY('NAME','TRC')
           OPTCD('OPTIONAL SERVICES CODES')
           FORMS('FORMS NAME')
           OUTDES('OUTPUT DESCRIPTOR NAME', ...)
           UCS('UCS NAME')
           WRITER('EXTERNAL WRITER NAME')

./ ADD NAME=ALTLIB
  ALTLIB-.-ACTIVATE  -QUIET-.-USER(EXEC)
         !            blank !     (CLIST)
         !                  !     (*)
         !                  !-APPLICATION(EXEC)
         !                  !   !        (CLIST)
         !                  !   !
         !                  !   '--.-DATASET(dslist)-.-UNCOND
         !                  !      !-DSNAME(dslist)  '-COND
         !                  !      !-FILE(ddname)
         !                  !      !-DDNAME(ddname)
         !                  !      '-LIBRARY(ddname)
         !                  !
         !                  '-SYSTEM(EXEC)
         !                          (CLIST)
         !                          (*)

./ ADD NAME=ALTLIB$
/* rexx */
ADDRESS TSO
"ALTLIB ACT APPLICATION(EXEC) DA('GIM.SGIMCLS0')"
ADDRESS ISPEXEC
"ISPEXEC LIBDEF ISPMLIB DATASET ID('GIM.SGIMMENU')"
"ISPEXEC LIBDEF ISPPLIB DATASET ID('GIM.SGIMPENU')"
"ISPEXEC LIBDEF ISPSLIB DATASET ID('GIM.SGIMSENU')"
"ISPEXEC LIBDEF ISPTLIB DATASET ID('GIM.SGIMTENU')"
"ISPEXEC SELECT PANEL(GIM‡PRIM))"
ISPEXEC LIBDEF ISPPLIB /* free plib */
ISPEXEC LIBDEF ISPMLIB /* free mlib */
ISPEXEC LIBDEF ISPSLIB /* free slib */
ISPEXEC LIBDEF ISPTLIB /* free tlib */
ADDRESS TSO
"ALTLIB DEA APPLICATION(EXEC)" /* deactivate EXEC library */
"END"

./ ADD NAME=ALTLIB1
"ALTLIB   ACTIVATE    USER(EXEC) DATASET('GIM.SGIMCLS0')  UNCOND"       02350000

./ ADD NAME=ASCB
/* Rexx */
/* --- Get Address of ASCB ----------------------- */
ASCB_Addr = C2D(Storage(224,4))  /* Get address of ASCB */

/* --- First check ASCBJBNI for Jobname ------------------- */
Interpret "JobAddr = Storage("D2X(ASCB_ADDR+172)",4)"

If C2D(JobAddr) = 0 Then
   /* --- Not in initiator, so get jobname from ASCBJBNS -- */
   Interpret "JobAddr = Storage("D2X(ASCB_ADDR+176)",4)"

Interpret "Job = Storage("C2X(JobAddr)",8)"
say "Jobname: " Job
exit
Figure 5: REXX Code Fragment

./ ADD NAME=BATCHCL
//BATCHCL  JOB (ACCT),MVS,MSGCLASS=S,
//      NOTIFY=&SYSUID,CLASS=A,MSGLEVEL=(1,1),TIME=(0,10)
//MYLIB JCLLIB ORDER=SYS1.SACBCNTL
//ALCISPFL EXEC PGM=IKJEFT01
//SYSPROC  DD DSN=&SYSUID..OSEO.REXX,DISP=SHR
//*CAVIEW STE58.SARPREXT.PDS(SARPREXT)
//         DD DSN=STE58.SARPREXT.PDS,DISP=SHR
//         DD DSN=IDI.SIDIEXEC,DISP=SHR
//SYSTSPRT DD SYSOUT=*
//SYSTSIN  DD *
  SARPREXT 20220625 20220626
//
  CTMAPI00
//
  IDISFA S28P.IDISHIST
//
  JOBNAME
//
  IOAVERFY STEPLID(SYS4.IOA920.LOAD) ILPREFA(SYS4.IOA920)
//
  PDS2SEQ STE58.OSEO.REXXSTE58.OSEO.REXX.SEQ
//
  IPLINFO
//
  SETRRCVT
//*FAULT ANALYZER
  IDI.SIDIEXEC(IDISFA)

./ ADD NAME=BLSCLIB$
        /*** Start of specifications for BLSCLIBD ********************/
        /*                                                           */
        /* $MAC(BLSCLIBD) COMP(SC132) PROD(HBB7790): Define IPCS     */
        /*                libraries to ISPF for use in dialog.       */
        /*                                                           */
        /* PROPRIETARY STATEMENT =                                   */
        /*                                                           */
        /* LICENSED MATERIALS  PROPERTY OF IBM                       */
        /* 5650-ZOS COPYRIGHT IBM CORP. 1986, 2013                   */
        /*                                                           */
        /* STATUS = HBB7790                                          */
        /*                                                           */
        /* ========================================================= */
        /*                                                           */
        /* Change Activity =                                         */
        /*                                                           */
        /*   Products =                                              */
        /* $L0=OY26596,JBB2220,90115,PFN1: LIBDEF services for IPCS  */
        /*     dialog                                                */
        /*    =OY32859,HBB3310,90193,PFN1: Move text so that it      */
        /*     did not exceed column 72                              */
        /*                                                           */
        /* --------------------------------------------------------- */
        /*                                                           */
        /*   Design changes = none                                   */
        /*                                                           */
        /* --------------------------------------------------------- */
        /*                                                           */
        /*   PTMs =                                                  */
        /*    =ME24977,HBB7790,12310,PDTY: Copyright updates         */
        /*                                                           */
        /* --------------------------------------------------------- */
        /*                                                           */
        /*   Maintenance =                                           */
        /*    =OY36082,JBB2220,90264,PFKA: Remove APAR flagging      */
        /*     after clist + concat symbol.  Added logic for IPCS    */
        /*     secondary tutorial panels.                            */
        /*    =OY37847,HBB3310,90317,PFKA: Fixed comment line in     */
        /*     in prolog                                             */
        /*    =OY43500,JBB2220,910514,PDAX: Determine if BLSGCMDS is */
        /*     available prior to invocation of LIBDEF for ISPTLIB   */
        /*    =OY46507,HBB3310,910821,PDAX: REXX support             */
        /* $01=OY50646,HBB3310,92280,PDE1: Preserve the return code  */
        /*     from the IPCS dialog and use it as the return code    */
        /*     from this CLIST.  This allows return code 0 to be     */
        /*     passed through, causing the display of the panel that */
        /*     asks the ISPF user to decide how the LIST and LOG     */
        /*     should be processed on exit.  It also allows return   */
        /*     code 4 to be passed through, causing the default      */
        /*     disposition of those objects to be used.              */
        /* $02=OY50646,HBB3310,92280,PDE1: Reduce confusion          */
        /*     (somewhat) by making MVS/SP IPCS command procedures   */
        /*     visible to both IPCS and ISPF.                        */
        /* $03=OW00866,HBB3310,94024,PDXP: Prevent BLSMB002 from     */
        /*     overriding BLSMD101, which is set by BLSG             */
        /* $04=OA31453,HBB7790,11262,RSTLDK: Issue FREE to remove    */
        /*     TIOT entry before allocating DDIR (OA36942 rollup)    */
        /*                                                           */
        /*** End of specifications for BLSCLIBD **********************/

        PROC 0
        CONTROL NOLIST ASIS

        /* ========================================================= */
        /* Table, Message, Skeleton, and Panel Libraries             */
        /* ========================================================= */

        ALTLIB ACTIVATE APPLICATION(CLIST) DATASET('SYS1.SBLSCLI0') /* +
                                                                 ‡02P*/
        LISTDSI IPCSDDIR FILE NORECALL /* Dump directory file    ‡02A*/
        IF &LASTCC>4 THEN DO        /*                           ‡04C*/
          FREE DDNAME(IPCSDDIR)     /* Remove TIOT entry         ‡04A*/
          %BLSCDDIR
          END                       /*                           ‡04A*/
        ISPEXEC LIBDEF ISPMLIB DATASET ID('SYS1.SBLSMSG0') COND
        ISPEXEC LIBDEF ISPPLIB DATASET ID('SYS1.SBLSPNL0') COND
        ISPEXEC LIBDEF ISPSLIB DATASET ID('SYS1.SBLSKEL0') COND

        /* ========================================================= */
        /* Invoke LIBDEF for ISPTLIB only if BLSGCMDS is not         */
        /* available.                                                */
        /* ========================================================= */

        ISPEXEC TBOPEN BLSGCMDS LIBRARY(ISPTLIB) NOWRITE SHARE
        IF &LASTCC^=0 THEN DO
          ISPEXEC LIBDEF ISPTLIB DATASET ID('SYS1.SBLSTBL0') COND
          SET TLIBSET=YES
          END
        ELSE ISPEXEC TBCLOSE BLSGCMDS LIBRARY(ISPTLIB)

        /* ========================================================= */
        /* Start the IPCS dialog and setup the IPCS CLIST and REXX   */
        /* library SYS1.SBLSCLI0 as an ALTLIB application CLIST      */
        /* library.                                                  */
        /* ========================================================= */

        ISPEXEC SELECT PGM(BLSG) NEWAPPL(BLSG) PASSLIB PARM(PGM(+
            BLSGSCMD) PARM(EXEC 'SYS1.SBLSCLI0(BLSCALTL)')) /*   ‡02C*/

        /* ========================================================= */
        /* Logic for IPCS secondary tutorial panels.                 */
        /* ========================================================= */

        SET &MYCC=&LASTCC
        IF &MYCC>=8 THEN DO
          ISPEXEC SETMSG MSG(BLSMB002) COND /*                   ‡03C*/
          IF &LASTCC<=4 THEN EXIT CODE(&MYCC) /*                 ‡03C*/
          WRITE Dialog program BLSG ended with Return Code &MYCC
          EXIT CODE(&MYCC)          /*                           ‡01C*/
          END

        /* ========================================================= */
        /* Cancel the definition after the IPCS dialog is terminated */
        /* ========================================================= */

        ISPEXEC LIBDEF ISPMLIB
        ISPEXEC LIBDEF ISPPLIB
        ISPEXEC LIBDEF ISPSLIB
        ALTLIB DEACTIVATE APPLICATION(CLIST) /*                  ‡02P*/

        /* ========================================================= */
        /* Cancel the LIBDEF for ISPTLIB only if it was set.         */
        /* ========================================================= */

        IF &TLIBSET=YES THEN ISPEXEC LIBDEF ISPTLIB /*           ‡02C*/
        EXIT CODE(&MYCC)            /*                           ‡02C*/

./ ADD NAME=BLSCLIBD
PROC 0
CONTROL NOLIST ASIS
/* Table, Message, Skeleton, and Panel Libraries             */
ALTLIB ACTIVATE APPLICATION(CLIST) DATASET('SYS1.SBLSCLI0') /* +
ISPEXEC LIBDEF ISPMLIB DATASET ID('SYS1.SBLSMSG0') COND
ISPEXEC LIBDEF ISPPLIB DATASET ID('SYS1.SBLSPNL0') COND
ISPEXEC LIBDEF ISPSLIB DATASET ID('SYS1.SBLSKEL0') COND
ISPEXEC SELECT PGM(BLSG) NEWAPPL(BLSG) PASSLIB PARM(PGM(+
    BLSGSCMD) PARM(EXEC 'SYS1.SBLSCLI0(BLSCALTL)')) /*   ‡02C*/
SET &MYCC=&LASTCC
IF &MYCC>=8 THEN DO
  ISPEXEC SETMSG MSG(BLSMB002) COND /*                   ‡03C*/
  IF &LASTCC<=4 THEN EXIT CODE(&MYCC) /*                 ‡03C*/
  WRITE Dialog program BLSG ended with Return Code &MYCC
  EXIT CODE(&MYCC)          /*                           ‡01C*/
  END
ISPEXEC LIBDEF ISPMLIB
ISPEXEC LIBDEF ISPPLIB
ISPEXEC LIBDEF ISPSLIB
ALTLIB DEACTIVATE APPLICATION(CLIST) /*                  ‡02P*/

./ ADD NAME=CAVXTRT
        /* --------------------  rexx procedure  -------------------- */
        ver = "1.27"
        /* Name:      CAVXTRT                                         *
         *                                                            *
         * Function:  Display reports from CA-View and allow user to: *
         *            - Extract to a dataset                          *
         *            - Extract for mailing (via xmitip)              *
         *            - Extract for viewing or browsing               *
         *            - Delete a report from disk (not the d/b)       *
         *            - Print a report                                *
         *            - Transfer a report to workstation              *
         *            - Load the report for processing                *
         *                                                            *
         *            - display statistics for the selected db        *
         *                                                            *
         * Syntax:    %cavxtrt option(s)                              *
         *                                                            *
         *            Valid Options:                                  *
         *            database - invoke using this specified          *
         *                       CA-View database                     *
         *            /CA     - Invoke the Computer Associates        *
         *                      CA-View ISPF Interface for all        *
         *                      selections.                           *
         *            /LAST   - Use the last CA-View Database         *
         *                      and bypass the database prompt        *
         *                                                            *
         * Customization: see CAVXTRTD for local customizations       *
         *                                                            *
         * Dependencies:                                              *
         *    1. SARBCH must be in the Linklist                       *
         *    2. SYS1.PARMLIB(IKJTSOxx) must have SARBCH in the       *
         *       AUTHPGM section                                      *
         *    3. The list of CA-View databases and descriptions at    *
         *       the end of this code must be updated using the       *
         *       NJE Nodename to identify which databasea are         *
         *       available.                                           *
         *    4. The LIBDEF's in the DO_CADialog must be updated      *
         *       for the CA-View Panel and Table Libraries.           *
         *    5. External routine CAVXTRTD accessed for many local    *
         *       customization settings.                              *
         *                                                            *
         * Notes:                                                     *
         *   1. if the user enters a command other than L (load) and  *
         *      the report is not on disk then a LOAD will be         *
         *      implied and the user informed to wait for the batch   *
         *      load to complete.                                     *
         *   2. If there is only one database then the database       *
         *      selection display will be bypassed.                   *
         *                                                            *
         * History:                                                   *
         *      01/23/19 - Version 1.27                               *
         *               - Update from Anthony Cieri to handle        *
         *                 CA-View 14.x                               *
         *      03/24/10 - Version 1.26                               *
         *               - Update from Lane Thorne to handle          *
         *                 CA-View 11.x                               *
         *      12/04/07 - Version 1.25                               *
         *               - Make code more dynamic for /LIST           *
         *      05/14/07 - Version 1.24                               *
         *               - Update to work with R11 of CA-View         *
         *                 (thx to Andy White)                        *
         *               - For R11 changed Reports to 133 lrecl       *
         *               - Changed Blksize to system determined (0)   *
         *               - Change parsing of records and offsets      *
         *      07/27/05 - Version 1.23                               *
         *               - Fine tune location of dloc and prtlines    *
         *               - Change space allocation for work file to   *
         *                 use secondary size                         *
         *      05/05/04 - Version 1.22                               *
         *               - Enable use in multiple ISPF sessions       *
         *      09/09/03 - Version 1.21                               *
         *               - Change space allocation for DD CAVXTRT     *
         *                 to reduce the primary and increase the     *
         *                 secondary.  Also add Unit Count (UCOUNT)   *
         *                 to the allocation to help ensure that      *
         *                 space will be found for large files,       *
         *                 only if the primary is > 1000 tracks       *
         *      07/08/03 - Version 1.20                               *
         *               - Correct JOBCard for Reorg message          *
         *      06/17/03 - Version 1.19                               *
         *               - If Admin and only 1 data base still display*
         *                 the data base selection list to allow the  *
         *                 R, V, and VF selections.                   *
         *               - Support sort sequence (e.g. sort field,x   *
         *                 where x is A (ascend) or D (descend)       *
         *               - New Administration setup (see CAVXTRTD)    *
         *               - on d/b table list improve redisplay        *
         *               - Build Jobcard in CAVXTRTD                  *
         *               - Add Data base selection R to submit a      *
         *                 batch JOB to REORG the data base - ASYNCH  *
         *               - Make d/b selection V Status and add VF for *
         *                 STATUS FULL                                *
         *               - Add report selection option of DD to delete*
         *                 the online copy of the report              *
         *               - Use Admin to validate use of               *
         *                 - Data base selection R                    *
         *      06/02/03 - Version 1.18                               *
         *               - Add V (verify) option on the data base     *
         *                 list to display data base stats            *
         *      01/08/03 - Version 1.17                               *
         *               - Fix REFRESH (was failing on 2nd use)       *
         *      01/06/03 - Version 1.16                               *
         *               - Fix sort for ARCHDATE to correct sort order*
         *      11/21/02 - Version 1.15                               *
         *               - Allow Todate of TODAY                      *
         *      10/29/02 - Version 1.14                               *
         *               - Add TIME to job card                       *
         *      09/30/02 - Version 1.13                               *
         *               - Allow sorting of columns                   *
         *      06/18/02 - Version 1.12                               *
         *               - delete work datasets when complete for     *
         *                 all returns                                *
         *      03/11/02 - Version 1.11                               *
         *               - set suffix for temp d/s to .CAV            *
         *               - fix if user prefix is null                 *
         *               - translate database dsns to upper case      *
         *      02/28/02 - Version 1.10                               *
         *               - fix jobclass on 2nd + submits              *
         *               - Fix to delete temp datasets before alloc   *
         *      02/28/02 - Version 1.9                                *
         *               - change to browse SARBCH results if rc>0    *
         *      02/26/02 - Version 1.8                                *
         *               - change from /PRINT to /LOAD which avoids   *
         *                 the banner pages in the report.            *
         *      02/26/02 - Version 1.7                                *
         *               - fix missing end statement in extract       *
         *               - add display save/restore in mail           *
         *      02/25/02 - Version 1.6                                *
         *               - Move a lot of the customizations to the    *
         *                 CAVXTRTD external rexx routine.            *
         *               - Test validity of user specified database   *
         *               - If last action is L then don't redo it     *
         *               - Save jobclass for last database to use if  *
         *                 /LAST is requested                         *
         *      02/25/02 - Version 1.5                                *
         *               - Correct extract dsn when prefix <> userid  *
         *      02/24/02 - Version 1.4                                *
         *               - Sort database list table by description    *
         *               - Add /LAST Option                           *
         *               - Change CA option to /CA                    *
         *               - Allow a CA-View database to be specified   *
         *                 as the first option                        *
         *               - Make patience window a popup               *
         *      02/23/02 - Version 1.3                                *
         *               - fix file transfer                          *
         *      02/22/02 - Version 1.2                                *
         *               - add support for generic REPORT-ID selection*
         *               - add new File Transfer selection option     *
         *      02/21/02 - Version 1.1                                *
         *               - add date format option for international   *
         *                 formats                                    *
         *      02/19/02 - Version 1.0                                *
         *       ....    - numerous enhancements/changes              *
         *      02/11/02 - Creation                                   *
         *                                                            *
         * ---------------------------------------------------------- *
         * Author:    Lionel B. Dyck                                  *
         *            Kaiser Permanente Information Technology        *
         *            Walnut Creek, CA 94598                          *
         *            (925) 926-5332                                  *
         *            Internet: lionel.b.dyck‡kp.org                  *
         *            AIM nickname: lbdyck                            *
         * ---------------------------------------------------------- */
         arg options

        /* -------------------------------------------------- *
         * Test for our ISPF Applid and if not then:          *
         * - create an ISPF Commands Table so we can change   *
         *   RFIND to PASSTHRU so we can process it           *
         * - re-invoke ourselves with our APPLID              *
         * - upon return end the ISPF Commands Table and exit *
         * -------------------------------------------------- */
         Address ISPExec
         "Vget (Zapplid)"
         "Control Errors Return"
         if zapplid <> "CAVX" then do
             "TBCreate cavxcmds names(zctverb zcttrunc zctact zctdesc)",
               "replace share nowrite"
             zctverb = "RFIND"
             zcttrunc = 0
             zctact = "&CAVXFIND"
             zctdesc = "RFIND for CAView Dialog"
             "TBAdd cavxcmds"
             "Select CMD(%"sysvar('sysicmd') options ") Newappl(CAVX)" ,
                 "Passlib SCRName(CAVXTRT)"
             "TBEnd cavxcmds"
            Address TSO
            exit 0
            end

        /* ------------------------------------------------------ *
         * Setup the Global variables that will be used elsewhere *
         * in this code.                                          *
         * - turn messages off                                    *
         * - set the table name for the list of reports           *
         * - set several variables to "" (null)                   *
         * - set the name of the /LIST work dataset               *
         * ------------------------------------------------------ */
         call msg "Off"
         table_name = cavlist
         parse value "" with null refresh first_pass rptmask ,
                             lastdb slash_last userdb final
         tu = random(9999)
         if sysvar('syspref') <> sysvar('sysuid') then do
            tmp_dsn = sysvar('sysuid')".CAVXTRT.TEMP"tu".LIST"
            prt_dsn = sysvar('sysuid')".CAVXTRT.TEMP"tu".LISTS"
            end
         else do
            tmp_dsn = "CAVXTRT.TEMP"tu".LIST"
            prt_dsn = "CAVXTRT.TEMP"tu".LISTS"
            end
         Address TSO
         "Delete" tmp_dsn
         "Delete" prt_dsn
         Address ISPExec
         zerralrm = "NO"
         zerrhm   = "CAVXTRTH"

        /* ----------------------------------------------------- *
         * Call the CAVXTRTD external rexx routine for the local *
         * customization settings.                               *
         * ----------------------------------------------------- */
         call cavxtrtd
         c = queued()
         do i = 1 to c
            parse pull in
            in.i = in
            end
         in.0 = c
         db   = 0
         drop tab.
         parse value "" with datefmt jobclass jobcard ,
                             panels tables admin
         do i = 1 to in.0
            test = word(in.i,1)
            Select
              When test = "ADMIN" then
                   admin = word(in.i,2)
              When test = "DATEFMT" then
                   datefmt = word(in.i,2)
              When test = "DB" then do
                   parse var in.i x dbase desc
                   db = db + 1
                   tab.db = dbase desc
                   end
              When test = "JOBCLASS" then
                   jobclass = word(in.i,2)
              When test = "JOBCARD" then
                   jobcard = subword(in.i,2)
              When test = "PANELS" then
                   panels = word(in.i,2)
              When test = "TABLES" then
                   tables = word(in.i,2)
              Otherwise nop
              end
            end
            tab.0 = db

        /* ---------------------------------------------- *
         * Test for options and set variables.            *
         *    /CA - Invoke the Computer Associates Dialog *
         *    /LAST - Use the last used database          *
         * ---------------------------------------------- */
         if options <> null then do
            if left(word(options,1),1) <> "/" then do
               slash_last = 1
               userdb     = 1
               cavdb  = word(options,1)
               testdb = "'"cavdb".SARDBASE.D0000001'"
               if sysdsn(testdb) <> "OK" then do
                  zerrsm = "Errorß"
                  zerrlm = "Requested database" cavdb ,
                           "was not found. Try again."
                  "Setmsg msg(isrz002)"
                  exit 12
                  end
               lastdb = cavdb
               "Vput (lastdb) Profile"
               end
            If wordpos("/CA",options) > 0 then UseCA = 1
                                          else UseCA = 0
            If wordpos("/LAST",options) > 0 then do
               "Vget (lastdb) Profile"
               slash_last = 1
               cavdb = lastdb
               end
            end

        /* ---------------------------------- *
         * Test for UseCA (/CA) Specification *
         * ---------------------------------- */
         if UseCA = 1 then
            if slash_last <> null then do
               call do_cadialog
               return
               end

        /* ---------------------------- *
         * Test for /LAST Specification *
         * ---------------------------- */
         if lastdb <> null then signal start

        /* --------------------------------------------------- *
         * First:                                              *
         * Build the selection table list of available CA-View *
         * databases.                                          *
         * --------------------------------------------------- */
         First:
            call Get_DB

         Start:
        /* --------------------------------------------------------- *
         * Display the prompting panel for the:                      *
         *   rptid    Report ID                                      *
         *   rptgen   Report Generation                              *
         *   fromdate Starting date for report selection             *
         *   todate   Ending date for report selection               *
         *                                                           *
         * fromdate may be null or TODAY, WEEK, or MONTH or mm/dd/yy *
         * todate may be null or TODAY or mm/dd/yy                   *
         *                                                           *
         * On Exit return to label FIRST for DB selection            *
         * --------------------------------------------------------- */
         Do Forever
            if rptmask <> null then do
               rptid   = rptmask
               rptmask = null
               end
            if refresh = 1 then call restart
            else do
               "Display Panel(cavxtrt)"
               if rc > 4 then do
                   if slash_last = null then signal first
                       else return
                   end
               "Vput (rptid rptgen fromdate todate) Profile"
               call start_it
               end
            end

        /* ------------------------ *
         * Now Start the processing *
         * ------------------------ */
         Start_It:
         cav_server = cavdb
         parse value "" with stat

        /* ---------------------------- *
         * Test for FROMDATE and TODATE *
         *  - Today is today's date     *
         *  - Week is the last 7 days   *
         *  - Month is the last 31 days *
         * ---------------------------- */
         parse value "" with from to
        /* ----------------- *
         * Test the FROMDATE *
         * ----------------- */
         Select
         when translate(FROMDATE) = "TODAY" then do
            from = date('b')
            end
         when translate(FROMDATE) = "WEEK" then do
            date = date('b')
            from = date('b',date-7,'b')
            end
         when translate(FROMDATE) = "MONTH" then do
            date = date('b')
            from = date('b',date-31,'b')
            end
         otherwise do
            if fromdate <> null then do
              call valid_date fromdate
              if drc > 0 then return
              from = date('b',fromdate,datefmt)
              end
          end
         end

        /* --------------- *
         * Test the TODATE *
         * --------------- */
         Select
         when translate(TODATE) = "TODAY" then do
            to = date('b')
            end
         otherwise do
            if todate <> null then do
              call valid_date todate
              if drc > 0 then return
              to   = date('b',todate,datefmt)
              end
          end
         end

        /* ---------------------------------------------- *
         * If Fromdate and Todate then Gen is * (for all) *
         * ---------------------------------------------- */
         if length(from) + length(to) > 0 then rptgen = "*"

        /* ----------------------------- *
         * If Gen is ALL then reset to * *
         * ----------------------------- */
         if translate(rptgen) = "ALL" then rptgen = "*"

        /* -------------------------------------------------------- *
         * Test for a Generic ReportID. If so then build a testrpt  *
         * variable with all non wild-card (*) characters.          *
         *                                                          *
         * Set the nogen variable to 1 to cause the generic routine *
         * to be invoked.                                           *
         * -------------------------------------------------------- */
         if pos("*",rptid) = 0 then nogen = 0
            else do
                 nogen   = 1
                 rptmask = rptid
                 p       = pos("*",rptid)
                 rptid   = left(rptid,p)
                 testrpt = null
                 do i = 1 to length(rptmask)
                    if substr(rptmask,i,1) = "*" then iterate
                    testrpt = strip(testrpt""substr(rptmask,i,1))
                    end

                 end

        /* ------------------------------------ *
         * Set Selection Info for display later *
         * ------------------------------------ */
         selinfo = "Report id:" rptid "Gen:" rptgen
         if from <> null then
            selinfo = selinfo "From:" date(datefmt,from,'b')
         if to <> null then
            selinfo = selinfo "To:" date(datefmt,to,'b')

        /* -------------------------------------- *
         * Now Setup allocations for initial list *
         * -------------------------------------- */
         ReStart:
         if pos("*",rptid) > 0 then rptmask = rptid
         Address TSO
        "Delete" prt_dsn
        "Delete" tmp_dsn
        "Alloc f(sysprint) ds("prt_dsn") new spa(15,15)" ,
           "tr recfm(f b a) lrecl(133) blksize(0) reuse"
        "Alloc f(report) ds("tmp_dsn") new" ,
            "spa(30,30) tr reuse"
        "Alloc f(sysin)  new spa(1,1) tr reuse" ,
           "recfm(f b) lrecl(80) blksize(800)"

        /* ----------------------- *
         * Setup List control card *
         * ----------------------- */
         if refresh <> 1 then
            cc.1 = "/LIST ID="rptid" GEN="rptgen
         else cc.1 = save_cc
         save_cc = cc.1

        "Execio * diskw sysin (finis stem cc."

        /* --------------------------- *
         * Now Call SAR Batch (SARBCH) *
         * --------------------------- */
         call sarbch_pgm
         if sar_rc <> 0 then do
           "Delete" tmp_dsn
           "Delete" prt_dsn
            return
            end

        /* ----------------------------------------- *
         * Read in the list and free the allocations *
         * ----------------------------------------- */
         drop in.
        "Execio * Diskr report (finis stem in."
        "Free f(sysprint report sysin)"
      /* Check for new release of Ca-View */
        If pos('(11.)',in.1) > 0 then release_lvl = 11
                                  else release_lvl = 2
        If pos('(14.',in.1) > 0 then release_lvl = 14
        "Delete" tmp_dsn
        "Delete" prt_dsn

        /* ------------------------- *
         * Now create the ISPF Table *
         * ------------------------- */
        Address ISPExec
        "TBCreate" table_name " names(stat rpt jname jid gen seq" ,
                 "archdate archtime prtlines xcode pages dloc" ,
                 "prtdate)" ,
                 "Nowrite"

        /* ----------------------------------- *
         * Process the list to build the table *
         * ----------------------------------- */
        added = 0
        hit   = 0
        do i = 1 to in.0
           if left(in.i,1) = "1" then hit = 0
           if hit <> 1 then do
              if left(in.i,4) = " ---" then hit = 1
              if left(in.i,3) = "0ID" then do
                 if release_lvl > 2 then do
                      locpos   = pos("Loc ",in.i)
                      xcodepos = pos("Xcode ",in.i)
                      tseqpos  = pos(" Tseq",in.i)
                    end
                 else do
                      locpos   = pos("LOC ",in.i)
                      xcodepos = pos("XCODE ",in.i)
                      tseqpos  = pos(" TSEQ",in.i)
                      end
                 tseqpos  = tseqpos + 1
                 end
              iterate
              end

        /* ----------------------------------------------------- *
         * This only needs to change if the CA-View report format*
         * for the SARBCH /LIST report changes.                  *
         * ----------------------------------------------------- */
           parse var in.i 2 rpt jname jid gen seq ,
                 archdate archtime ,
                 =(locpos) dloc prtlines pages blocks ,
                 =(xcodepos) xcode =(tseqpos) tseq .
           jid = left(jid,1)right(jid,5)
           /* Create two digit year */
         parse var archdate mm '/' dd '/' YY
         if yy > 100 then
            YY = substr(yy,3,2)
         archdate = mm!!'/'!!dd!!'/'!!YY
           tdate = date('b',archdate,datefmt)
           if from <> null then do
              if tdate < from then iterate
              end
           if to <> null then do
              if tdate > to then iterate
              end
           xrc = 0
           prtdate = tdate
           if nogen = 1 then call test_generic
           if xrc = 1 then iterate
           "TBAdd" table_name
           added = added + 1
           end
         if added < 1 then do
            zerrsm = "Error"
            zerrlm = "The selection critera resulted in no",
                     "reports found.  Try again."
            "Setmsg msg(isrz002)"
            return
            end
         "TBTop" table_name
         if refresh = 1 then do
            zerrsm = "Refreshed"
            zerrlm = "Refresh completed."
            "Setmsg msg(isrz002)"
            refresh = null
            end

        /* ---------------------------------------- *
         * Now display the list of avilable reports *
         * ---------------------------------------- */
         mult_sels = 0
         crp = 1
         rowcrp = 0
         src    = 0
         drop load.
         load.0 = 0
         disp:
         do forever
            if refresh = 1 then return
            cavxfind = "PASSTHRU"
            sel = null
            if mult_sels = 0 then do
              tm.0 = 0
              "TBTop" table_name
              "TBSkip" table_name "Number("crp") "
                 "TBDispl" table_name "Panel(cavxtrtl)" ,
                         "Csrrow("rowcrp") AutoSel(No)"
              end
            else
              "TBDispl" table_name
            t_rc = rc
            crp = ztdtop
            mult_sels = ztdsels
            if rc > 7 then do
               "TBEnd" table_name
                return
                end
             cavxfind = null
             call do_it
           end

        /* -------------------------- *
         * Now Process the Selections *
         * -------------------------- */
         Do_It:
            act = null
            if abbrev("REFRESH",zcmd,3) = 1 then do
               "TBEnd" table_name
               refresh = 1
               return
               end
            osel = null
            Select
              When abbrev("FIND",word(zcmd,1),1)  = 1 then call do_find
              When abbrev("RFIND",word(zcmd,1),1) = 1 then call do_find
              When abbrev("SORT",word(zcmd,1),2) = 1 then call do_sort
              When left(zcmd,4) = "SORT" then call do_sort
              When left(sel,1) = "B" then call do_browse
              When left(sel,1) = "C" then call do_copy
              When left(sel,2) = "DD" then call do_delete
              When left(sel,1) = "M" then call do_mail
              When left(sel,1) = "P" then call do_print
              When left(sel,1) = "T" then call do_transfer
              When left(sel,1) = "V" then call do_view
              When sel = "L" then call do_load
              otherwise do
                        if load.0 > 0 then call quick_refresh
                        end
              end
            if act <> null then do
               stat = sel
               "TBPut" table_name
               end
            return

        /* -------------------------------------------------------- *
         * Mail the Report.                                         *
         *                                                          *
         * Extract the report from CA-View and then invoke the      *
         * XMITIP ISPF dialog using the XMITIP Front-End interface. *
         *                                                          *
         * The report will be e-mailed using the SMTP protocol.     *
         * -------------------------------------------------------- */
         Do_Mail:
            call Extract_It
            if osel <> null then return
            if sar_rc <> 0 then return
            "Control Display Save"
            Address TSO
            "%xmitipfe File("ext_dsn")" ,
              "Subject(Report from CA-View)"
            "Delete" ext_dsn
            Address ISPExec
            "Control Display Restore"
            act = sel
            return

        /* ---------------------------------------------------- *
         * Copy the Report to a standard dataset.               *
         *                                                      *
         * Prompt the user for a target dataset and then do the *
         * report extraction from CA-View.                      *
         * ---------------------------------------------------- */
         Do_Copy:
            call Extract_It 'file'
            if osel <> null then return
            if sar_rc <> 0 then return
            zerrsm = "Complete"
            zerrlm = "Selected Report has been saved",
                     "in dataset:" ext_dsn
            "Setmsg msg(isrz002)"
            act = sel
            return

        /* ------------------------ *
         * Sort the Report          *
         *                          *
         * Sort by column headings. *
         * ------------------------ */
         Do_Sort:
            parse value zcmd with o1 opt
            if pos(",",opt) > 0 then
               parse value opt with opt","sortseq
            sortseq = translate(sortseq)
            if pos(sortseq,"AD") = 0
               then sortseq = "A"
            opt = translate(opt)
            sort = null
            Select
              When abbrev("ARCHDATE",opt,5)  = 1 then sort = "prtdate"
              When abbrev("ARCHTIME",opt,5)  = 1 then sort = "archtime"
              When abbrev("GEN",opt,1)       = 1 then sort = "gen"
              When abbrev("JOBID",opt,4)     = 1 then sort = "jid"
              When abbrev("JOBNAME",opt,4)   = 1 then sort = "jname"
              When abbrev("LINES",opt,2)     = 1 then sort = "prtlines"
              When abbrev("LOC",opt,2)       = 1 then sort = "dloc"
              When abbrev("REPORT-ID",opt,1) = 1 then sort = "rpt"
              When abbrev("XCODE",opt,1)     = 1 then sort = "xcode"
              Otherwise do
                        zerrsm = "Error"
                        zerrlm = "Selected sort value invalid" opt ,
                                 "try again with any of the column" ,
                                 "headings."
                        "Setmsg msg(isrz002)"
                        return
                        end
              end
            if wordpos(sort,"gen prtlines") > 0 then stype = "N"
                                                else stype = "C"
            if sort = "prtdate" then
               "TBSort" table_name ,
               "fields(prtdate,C,"sortseq",archtime,C,"sortseq")"
            else
               "TBSort" table_name ,
               "fields("sort","stype","sortseq")"
            return

        /* ---------------------------------------------------- *
         * Browse the Report.                                   *
         *                                                      *
         * Extract the report then invoke ISPF Browse.          *
         *                                                      *
         * Upon completion delete the temporary report dataset. *
         * ---------------------------------------------------- */
         Do_Browse:
            call Extract_It
            if osel <> null then return
            if sar_rc <> 0 then return
            "Control Display Save"
            "Browse dataset("ext_dsn")"
            "Control Display Restore"
            Address TSO,
               "Delete" ext_dsn
            act = sel
            return

        /* ---------------------------------------------------- *
         * View the Report.                                     *
         *                                                      *
         * Extract the report then invoke ISPF View.            *
         *                                                      *
         * Upon completion delete the temporary report dataset. *
         * ---------------------------------------------------- */
         Do_View:
            call Extract_It
            if osel <> null then return
            if sar_rc <> 0 then return
            "Control Display Save"
            "View dataset("ext_dsn")"
            "Control Display Restore"
            Address TSO,
               "Delete" ext_dsn
            act = sel
            return

        /* ------------------------------------------------------ *
         * Setup the JCL for submission for batch processing.     *
         *                                                        *
         * If multiple rows were selected then build one job with *
         * all LOAD selections for submission.                    *
         * ------------------------------------------------------ */
         Do_Load:
        /* ----------------------------------------------- *
         * If the Report is currently online then skip it. *
         * ----------------------------------------------- */
         if stat = "L" then do
            zerrsm = "Warning"
            zerrlm = "The last action on this report was a Load",
                     "thus a second Load is prevented." ,
                     "Be patient."
            "Setmsg msg(isrz002)"
            return
            end
         if wordpos(dloc,"DISK PDSK PERM TEMP PTMP") > 0 then do
            zerrsm = "Error"
            zerrlm = "The requested report is currently",
                     "in location" dloc "and does not",
                     "need to be restored from tape."
            "Setmsg msg(isrz002)"
            return
            end
         c      = load.0 + 1
         load.c = "/LIST ID="rpt "GEN="gen
         load.0 = c
         if mult_sels <> 1 then do
            tm = tm.0 + 1
            tm.tm = "/LOAD GEN="gen "ID="rpt "SEQ="seq
            tm.0 = tm
            act = sel
            return
            end

        /* ---------------------------------------------------- *
         * Construct JOB Card and JCL                           *
         * ---------------------------------------------------- */
         call build_job_card
         drop t.0
         t.4 = "//STEP1    EXEC PGM=SARBCH,PARM='"cav_server"'"
         t.5 = "//SYSPRINT DD SYSOUT=*"
         t.6 = "//SYSIN    DD  *"
         t.7 = "/LOAD GEN="gen "ID="rpt "SEQ="seq
         t.0 = 7
         if tm.0 > 0 then do
            c = t.0
            do i = 1 to tm.0
               c = c + 1
               t.c = tm.i
               end
            t.0 = c
            end
         function = "to restore the requested report",
                    "from tape to disk. When the job",
                    "ends you may use the other options",
                    "to process the report. Press ENTER",
                    "to refresh the Load requested report",
                    "status."
         call Submit_JCL
         act = sel
         return

        /* -------------------------------------------------------- *
         * Print the Report.                                        *
         *                                                          *
         * Extract the report to a standard dataset.                *
         *                                                          *
         * Prompt the user for the PRINTDS command options and then *
         * build the PRINTDS command.                               *
         * -------------------------------------------------------- */
         Do_Print:
         call Extract_It
         if osel <> null then return
         "Control Display Save"
         "Display Panel(cavxtrts)"
         prc = rc
         "Control Display Restore"
         if prc > 0 then return
         "Vput (spc spcp spfm spdest spfcb spucs sppm sppdef" ,
               "spfdef spodes schr) Profile"

        /* --------------------- *
         * Setup PRINTDS options *
         * --------------------- */
         Address TSO
         parse value time() with hh":"mm":"ss
         ddn  = "cx"hh""mm""ss
         if spc <> null then
            propt = "Class("spc")"
         if spcp <> null then
            propt = propt "Copies("spcp")"
         if schr <> null then
            propt = propt "Chars("schr")"
         if spfm <> null then
            propt = propt "Forms("spfm")"
         if spdest <> null then
            propt = propt "Dest("spdest")"
         if spfcb <> null then
            propt = propt "Fcb("spfcb")"
         if spucs <> null then
            propt = propt "UCS("spucs")"
        /* ----------------------- *
         * Test for OUTDES options *
         * ----------------------- */
         od = null
         if sppm <> null then
            od = "PRMode("sppm")"
         if sppdef <> null then
            od = od "Pagedef("sppdef")"
         if spfdef <> null then
            od = od "Formdef("spfdef")"
         if spodes =  null then
            if od <> null then do
               "Outdes" ddn "New" od
               end
               else ddn = null
         if spodes <>  null then do
              ddn = spodes
              end
         if ddn <> null then
            odes = "Outdes("ddn")"
         else odes = null

        /* ---------------------------------- *
         * Issue the PRINTDS command to print *
         * ---------------------------------- */
         "Pr dsn("ext_dsn")" odes propt

         if spodes =  null then
            if od <> null then
               "Free outdes("ddn")"
         "Delete" ext_dsn

         zerrsm = "Printed"
         zerrlm = "Requested Report printed to:" spdest
         Address ISPExec
         "Setmsg msg(isrz002)"
         act = sel
         return

        /* ------------------------------------------------------- *
         * Do File Transfer                                        *
         *   - support IND$FILE (normal terminal emulator tranfer) *
         *   - support FTP (from the users workstation)            *
         * ------------------------------------------------------- */
         Do_Transfer:
            call Extract_It
            if osel <> null then return
            if sar_rc <> 0 then return
            call get_tcpip
            Address TSO ,
              "Rename" ext_dsn xferdsn
            "Control Display Save"
            do forever
               "Display panel(cavxtrtx)"
               xrc = rc
               if zcmd <> null then do
                  Address TSO zcmd
                  xrc = 1
                  end
               if xrc > 0 then leave
               end
            "Control Display Restore"
            Address TSO,
              "Delete" xferdsn
            if xrc = 1 then do
               zerrsm = "Complete."
               zerrlm = "File transfer request for" ext_dsn ,
                        "has been completed."
               end
            else do
               zerrsm = "Cancelled"
               zerrlm = "File transfer request for" ext_dsn ,
                        "has been cancelled."
               end
            Address ISPExec
            "Setmsg msg(isrz002)"
            act = sel
            return

        /* ----------------------------------- *
         * Get current TCP/IP Host information *
         * ----------------------------------- */
         Get_Tcpip:
            res    = Socket('Initialize','ANYNAME')
            host   = Socket('GetHostId')
            name   = word(Socket('GetHostname'),2)
            domain = word(Socket('GetDomainName'),2)
            res    = Socket('Terminate')
            ftphost = name"."domain
            return

        /* -------------------------------------------------------- *
         * Quick Refresh: This routine will refresh the Location of *
         * all reports which have had a LOAD request performed. If  *
         * the location changes then the entry will be updated in   *
         * the table and removed from the load.x stem               *
         * -------------------------------------------------------- */
         Quick_Refresh:
         load_count = 0
         Address TSO
         "Delete" prt_dsn
         "Alloc f(sysprint) ds("prt_dsn") new spa(15,15)" ,
            "tr recfm(f b a) lrecl(133) blksize(0) reuse"
         "Delete" tmp_dsn
         "Alloc f(report) ds("tmp_dsn") mod" ,
           "spa(30,30) tr"
         "Alloc f(sysin)  new spa(1,1) tr reuse" ,
            "recfm(f b) lrecl(80) blksize(800)"
         "Execio * diskw sysin (finis stem load."
         call sarbch_pgm
         drop in.
         "Execio * diskr report (finis stem in."
         "Free f(sysprint report sysin)"
         "Delete" tmp_dsn
         "Delete" prt_dsn
         Address ISPExec
         do i = 1 to in.0
            if left(in.i,1) = "1" then hit = 0
            if hit <> 1 then do
               if left(in.i,4) = " ---" then hit = 1
               iterate
               end
          /* ----------------------------------------------------- *
           * This only needs to change if the CA-View report format*
           * for the SARBCH /LIST report changes.                  *
           * ----------------------------------------------------- */
           parse var in.i 2 $rpt x x $gen $seq . =(locpos) $dloc .
           call update_row
           end
         c = 0
         do i = 1 to load.0
            if load.i <> "xx" then do
               c = c + 1
               temp.c = load.i
               end
            end
         temp.0 = c
         drop load.
         do i = 1 to temp.0
            load.i = temp.i
            end
         load.0 = temp.0
         drop temp.
         return

        /* ------------------------- *
         * Update report information *
         * ------------------------- */
         Update_Row:
         "TBTop" table_name
         row = 0
         do forever
         "TBSkip" table_name
         if rc > 0 then return
         row = row + 1
         if rpt = $rpt then
            if gen = $gen then
               if seq = $seq then
               if dloc <> $dloc then do
                  dloc = $dloc
                  stat = "*"
                  load_count = load_count + 1
                  "TBPut" table_name
                  if sel /= "DD" then do
                     zerrsm = "Loaded"
                     zerrlm = load_count "of" load.0 "reports",
                              "have been loaded and the Act",
                              "has been changed from L to *."
                     end
                  else do
                     zerrsm = "Deleted"
                     zerrlm = "The selected report has been",
                              "deleted from disk and the Act",
                              "has been changed to *."
                     end
                  "Setmsg msg(isrz002)"
                  do c = 1 to load.0
                     parse value load.c with x "ID="id "GEN="gen
                     if id = rpt then
                        if gen = $gen then
                           load.c = "xx"
                     end
               end
         end
         return

        /* ----------------------------------------------------------- *
         * Generalized Report Extraction routine.                      *
         *                                                             *
         * This routine will extract the requested report from CA-View *
         * as long as it currently resides on DISK, PDSK, PERM, PTMP,  *
         * or TEMP storage.                                            *
         *                                                             *
         * If the report is not then convert the action to a LOAD.     *
         *                                                             *
         * ----------------------------------------------------------- */
         Extract_It:
           if wordpos(dloc,"DISK PDSK PERM TEMP PTMP") = 0 then do
              osel = sel
              sel  = "L"
              call do_load
              if stat = "L" then return
              zerrsm = "Submitted"
              zerrlm = "Selection changed from" osel "to" ,
                       sel "as the report resides on Tape." ,
                       "Job" jobname "has been submitted",
                       "to restore the requested report",
                       "from tape to disk. When the job",
                       "ends you may use the other options",
                       "to process the report. Press ENTER",
                       "to refresh the Load requests location.",
                       "The ACT field will change from L to *",
                       "when the report has been loaded."
              "Setmsg msg(isrz002)"
              return
              end
           arg opt
           if opt = "FILE" then do
              "Addpop"
              "Display Panel(cavxtrtp)"
              xrc = rc
              "Rempop"
              if xrc > 0 then do
                 zerrsm = "Cancelled"
                 zerrlm = "Extract cancelled."
                 "Setmsg msg(isrz002)"
                 return
                 end
              ext_dsn = cavxtdsn
              end
           else do
                if sysvar('syspref') <> sysvar('sysuid') then do
                   if sysvar('syspref') <> null then
                      hlq = sysvar('syspref')"."sysvar('sysuid')
                   else
                      hlq = sysvar('sysuid')
                   ext_dsn = "'"hlq".CAVXTRT."jname".G"gen".CAV'"
                   xferdsn = "'"hlq".CAV.REPORT'"
                   end
                else do
                   ext_dsn = "CAVXTRT."jname".G"gen".CAV"
                   xferdsn = "CAV.REPORT"
                   end
                end

          /* -------------------------------------------------------- *
           * Build the SARBCH /LOAD control card that will extract    *
           * the CA-View report and place it into a standard dataset. *
           * -------------------------------------------------------- */
            Address TSO
            cc.1 = "/LOAD GEN="gen "ID="rpt ,
                   "SEQ="seq "DDNAME=CAVXTRT"
            "Delete" ext_dsn
            if wordpos(dloc,"DISK PDSK PERM TEMP PTMP") = 0 then
               say "Report is located on Tape.",
                   "Please be patient."
            "Delete" prt_dsn
            "Alloc f(sysprint) ds("prt_dsn") new spa(15,15)" ,
              "tr recfm(f b a) lrecl(133) blksize(0) reuse"
             space = ((prtlines * 255)%54000)%4
             if space > 1000 then ucount = "ucount(4)"
                             else ucount = null
             sec   = (space%2) + 1
            "Alloc f(cavxtrt) ds("ext_dsn") new" ,
                "spa("space","sec") tr" ucount ,
                "recfm(f b) lrecl(133) blksize(0)"
            "Alloc f(sysin)  new spa(1,1) tr reuse" ,
               "recfm(f b) lrecl(80) blksize(800)"
            "Execio * diskw sysin (finis stem cc."
            Address ISPExec
            "Control Display Save"
            "Addpop"
            "Control Display Lock"
            "Display Panel(cavxtrtw)"
            "Rempop"
            "Control Display Restore"
            Address TSO
            call sarbch_pgm
            "Free f(sysin sysprint cavxtrt)"
            "Delete" prt_dsn
            Address ISPExec
           return

           /* ----------------------------------- *
            * Perform a Delete of the Online Copy *
            * of the specified report.            *
            * If the Location is DISK then bypass.*
            * ----------------------------------- */
            Do_Delete:
            if dloc = "DISK" then do
               zerrsm = "Error"
               zerrlm = "The requested report is on DISK and has not",
                        "yet had an archive copy made in the CA-View",
                        "data base. Delete action cancelled for now",
                        "until an archive copy has been created."
               "Setmsg Msg(isrz002)"
               return
               end
            if wordpos(dloc,"PDSK TEMP PTMP PERM") = 0 then do
               zerrsm = "Error"
               zerrlm = "The requested report is not on disk and thus",
                        "there is no need for this delete action.",
                        "This application does not support doing a full",
                        "delete of the report."
               "Setmsg Msg(isrz002)"
               return
               end
            drop c.0
            cc.1 = "/DELETE ID="rpt "GEN="gen "SEQ="seq "DISK"
            act = sel
            Address TSO
            "Delete" ext_dsn
            "Delete" prt_dsn
            "Alloc f(sysprint) ds("prt_dsn") new spa(1,1)" ,
              "tr recfm(f b a) lrecl(133) blksize(0) reuse"
            "Alloc f(sysin)  new spa(1,1) tr reuse" ,
               "recfm(f b) lrecl(80) blksize(800)"
            "Execio * diskw sysin (finis stem cc."
            call sarbch_pgm
            "Free f(sysin sysprint)"
            "Delete" prt_dsn
            Address ISPExec
            c      = load.0 + 1
            load.c = "/LIST ID="rpt "GEN="gen
            load.0 = c
            call quick_refresh
            return

        /* ---------------------------------------------- *
         * Call the CA-View batch utility program SARBCH. *
         * ---------------------------------------------- */
         Sarbch_PGM:
        "Call *(SARBCH) '"cav_server"'"
         sar_rc = rc
         if sar_rc > 0 then do
            Address ISPExec
            "Control Display Save"
            "Browse dataset("prt_dsn")"
            "Browse dataset("tmp_dsn")"
            "Control Display Restore"
            Address TSO
            end
         return

        /* ------------------ *
         * Validate the Dates *
         * ------------------ */
         Valid_Date: Procedure expose null drc zerralrm zerrhm
         arg date
         drc = 0
         parse value date with mm"/"dd"/"yy
         if datatype(mm) <> "NUM" then drc = 4
         if datatype(dd) <> "NUM" then drc = 4
         if datatype(yy) <> "NUM" then drc = 4
         if mm < 1 ! mm > 12 then drc = 4
         if dd < 1 ! dd > 31 then drc = 4
         if drc = 0 then return
         zerrsm = "Date Error"
         zerrlm = "Error in date" date". Try again."
         "Setmsg msg(isrz002)"
         return

        /* --------------------------------------- *
         * Process the Generic ReportID selection: *
         *   * = single wild character             *
         *  ** = any number of wild characters     *
         * --------------------------------------- */
         Test_Generic: Procedure Expose xrc rpt rptmask null testrpt ,
                                        zerralrm zerrhm
         j   = 1
         xrc = 1
         test = null
         do i = 1 to length(rptmask)
         Select
            When j > length(rpt) then nop
            When substr(rptmask,i,1) <> "*" then do
                 test = strip(test""substr(rpt,j,1))
                 j = j + 1
                 end
            When substr(rptmask,i,2) = "**" then do
                 if pos("*",substr(rptmask,i+2)) = 0 then do
                      tmp = substr(rptmask,i+2)
                      if right(rpt,length(tmp)) = tmp
                         then j = length(rpt)
                         test = strip(test""tmp)
                         end
                 else do
                      tc = substr(rptmask,i+2,1)
                      j  = pos(tc,rpt,j)
                      if j = 0 then return
                      i  = i + 1
                      end
                 end
            When substr(rptmask,i,1) = "*" then j = j + 1
            end
         end
         if testrpt = test then xrc = 0
         return

        /* ----------------------------------------------------- *
         * Find sub-routine                                      *
         * ----------------------------------------------------- */
        Do_Find:
              parse value zcmd with o1 argument
              upper argument
              argument = strip(argument)
              zsel = ''
              hit  = 1
              hcc  = 0
              crp  = ztdtop
              find_loop = ''
              search    = ''
              rowid     = crp
              if o1     = "RFIND" then do
                 argument = save_arg
                 last_find = last_find + 1
                 "TBTOP " table_name
                 "TBSKIP" table_name "Position(ROWID) Number("Last_find")"
                 end
                 else do
                      if rowid > 1 then
                      "TBSKIP" table_name "Position(rowid)"
                      end
              if rc = 8 then do
                             "TBTop" table_name
                             "TBSKIP" table_name "Position(ROWID)"
                             s_smsg = "Wrapped"
                             end
                        else s_smsg = "Found"

              /* ---------------------- *
               * Now perform the Search *
               * ---------------------- */

              save_arg = argument
              do forever
                 search = rpt jname
                 if pos(argument,search) > 0 then do
                    crp = rowid + 0
                    rowcrp = crp
                    last_find = crp
                        zerrsm = s_smsg   /* "Found" */
                        zerrlm = argument "found during search in row:" crp
                       "Setmsg Msg(isrz002)"
                    leave
                    end
                 "TBSKIP" table_name "POSITION(Rowid)"
                 if rc = 8 then do
                       "TBTOP" table_name
                        s_smsg = "Wrapped"
                    if find_loop = "on" then do
                        zerrsm = "Not Found"
                        zerrlm = argument "Not found during search"
                        rowid = crp
                       "Setmsg Msg(isrz002)"
                        leave
                        end
                        else find_loop = "on"
                    end
                 zsel = ''
                 end
         return

        /* --------------------------------------------- *
         * Invoke the Computer Associates CA-View Dialog *
         * --------------------------------------------- */
         Do_CADialog: procedure expose cavdb null panels tables ,
                                       zerralrm zerrhm
         if panels <> null then
            "Libdef ISPPLIB Dataset id("panels")" ,
                   "Stack"
         if tables <> null then
            "Libdef ISPTLIB Dataset id("tables")" ,
                   "Stack"
         "Select PGM(SARSPF) PARM("cavdb") NewAppl(SAR) Passlib" ,
            "SCRName(CAView)"
         if panels <> null then
            "Libdef ISPPLIB"
         if tables <> null then
            "Libdef ISPTLIB"
         return

        /* ----------------------------------------------------------- *
         * Get_DB: Build the ISPF Table of available CA-View (aka SAR) *
         * databases.                                                  *
         *                                                             *
         * The available databases are determined based upon the       *
         * current NJE Node name.                                      *
         *                                                             *
         * Format is database-dsn database-description                 *
         *                                                             *
         * Variable JOBCLASS, if set, will cause the generated JCL     *
         * to have a CLASS=jobclass                                    *
         * ----------------------------------------------------------- */
         Get_DB:
             if tab.0 = 0 then do
                zerrsm = "Error"
                zerrlm = "The current environmet" node ,
                         "does not support any CA-View",
                         "databases. Exiting Application."
                "Setmsg msg(isrz002)"
                exit 4
                end

        /* ---------------------------------------- *
         * If one entry then use it and skip prompt *
         * ---------------------------------------- */
         if admin /= "OK" then
         if tab.0 = 1 then do
            if first_pass = 1 then exit
            parse value tab.1 with cavdb cavdbdes
            first_pass = 1
            return
            end

        /* -------------------------------------- *
         * Now Create the ISPF Table of databases *
         * -------------------------------------- */
         "TBCreate cavdbtbl Names(sel cavdb cavdbdes) NoWrite"
         sel = null
         do i = 1 to tab.0
            parse value tab.i with cavdb cavdbdes
            cavdb    = translate(strip(cavdb))
            cavdbdes = strip(cavdbdes)
            "TBAdd cavdbtbl"
            end

        /* --------------------------------------------- *
         * Display the ISPF Table of Available Databases *
         *                                               *
         * Row selection options:                        *
         *    C = invoke CA's View ISPF Interface        *
         *    V = display data base statistics           *
         *    non-blank open the data base               *
         * --------------------------------------------- */
         "TBSort cavdbtbl Fields(cavdbdes)"
         "TBTop cavdbtbl"
         top = 1
         do forever
            sel = null
            "TBTop cavdbtbl"
            "TBSkip cavdbtbl Number("top")"
            "TBDispl cavdbtbl Panel(cavxtrtd)"
            if rc > 7 then do
               "TBEnd cavdbtbl"
               exit
               end
            top  = ztdtop
            ssel = sel
            if row <> null then
               if row > 0 then do
                 "TBTop cavdbtbl"
                 "TBSkip cavdbtbl NUMBER("row")"
                 end
            sel = ssel
            lastdb = cavdb
            "Vput (lastdb jobclass) Profile"
            /* ------------------------------- *
             * Data Base Selection - Non-Admin *
             * ------------------------------- */
            if admin <> "OK" then
            Select
               When sel = "C" ! UseCA = 1 then do
                  call do_cadialog
                  end
               When sel <> null then do
                  "TBEnd cavdbtbl"
                  return
                  end
               Otherwise nop
               end
            /* --------------------------- *
             * Data Base Selection - Admin *
             * --------------------------- */
            if admin = "OK" then
            Select
               When sel = "C" ! UseCA = 1 then do
                  call do_cadialog
                  end
               When sel = "R" then call do_reorg
               When sel = "V" then call do_stats
               When sel = "VF" then call do_stats
               When sel <> null then do
                  "TBEnd cavdbtbl"
                  return
                  end
               Otherwise nop
               end
            end
         return

        /* ------------------------------------------------- *
         * Display the statistics for the selected data base *
         * ------------------------------------------------- */
         Do_Stats: procedure expose cavdb admin zerralrm zerrhm sel
         report = "cav.report.d"random(99999)
         Address TSO
         "alloc f(sysprint) ds("report") new spa(1,1) tr reuse"
         "alloc f(sysin) unit(sysallda) spa(1) tr recfm(f b) lrecl(80)" ,
               "reuse"
         if sel = "VF" then
            stat.1 = "STATUS FULL"
         else
            stat.1 = "STATUS"
         "Execio * diskw sysin (finis stem stat."
         "call *(sardbase) '"cavdb"'"
         "alloc f(sysprint) ds(*) reuse"
         "alloc f(sysin)    ds(*) reuse"
         call msg 'off'
         Address ISPExec "Browse Dataset("report")"
         "delete" report
         Address ISPExec
         return

        /* -------------------------- *
         * Build and Submit Reorg Job *
         * -------------------------- */
         Do_Reorg:
         call build_job_card
         drop t.0
         t.4 = "//STEP1    EXEC PGM=SARDBASE,PARM='"cavdb"'"
         t.5 = "//SYSPRINT DD SYSOUT=*"
         t.6 = "//SYSIN    DD  *"
         t.7 = "REORG ASYNCH"
         t.0 = 7
         function = "to do an asynchronous reorganization of",
                    "the index file is to be performed",
                    "The database can be actively used by",
                    "others during the reorganization;",
                    "however, the less database activity there",
                    "is, the faster the REORG will run.",
                    "Verify the success of this JOB upon",
                    "completion."
         call Submit_JCL
         return

        /* -------------- *
         * Build Job Card *
         * -------------- */
         Build_Job_Card:
         if jobclass <> null then
            jclass = ",CLASS="jobclass
         else jclass = null
         t.1 = jobcard
         t.2 = "//         MSGLEVEL=(1,1),NOTIFY="sysvar('sysuid')""jclass",",
               !!"TIME=30"
         t.3 = "//HOLD     OUTPUT JESDS=ALL,DEFAULT=Y,OUTDISP=(HOLD,HOLD)"
         return

        /* ------------------------------------------------------- *
         * Allocate the Internal Reader DD and write the generated *
         * JCL to the Internal Reader for execution.               *
         * ------------------------------------------------------- */
         Submit_JCL:
         Address TSO
         "Alloc f(cavxrdr) sysout(b) writer(intrdr)",
            "Recfm(f) lrecl(80) blksize(80) reuse"
         "Execio * diskw cavxrdr (finis stem t."
         "Free f(cavxrdr)"
         parse value t.1 with "//"jobname .
         drop t.
         Address ISPExec
         zerrsm = "Submitted"
         zerrlm = "Job" jobname "has been submitted",
                  function
         "Setmsg msg(isrz002)"
         return

./ ADD NAME=CAVXTRT$
        /* --------------------  rexx procedure  -------------------- *
         * Name:      CAVXTRTD                                        *
         *                                                            *
         * Function:  Defaults/Local Customizations for CAVXTRT       *
         *                                                            *
         * Syntax:    called by CAVXTRT                               *
         *                                                            *
         * Author:    Lionel B. Dyck                                  *
         *            Kaiser Permanente Information Technology        *
         *            Walnut Creek, CA 94598                          *
         *            (925) 926-5332                                  *
         *            Internet: lionel.b.dyck‡kp.org                  *
         *                                                            *
         * Dependencies: some knowledge of REXX coding.               *
         *                                                            *
         * History:                                                   *
         *            02/11/04 - Updated the panel/table ca lib       *
         *                       data set names with plex name        *
         *            07/10/03 - Remove SAR.RM from PROD              *
         *            06/16/03 - Change jobclass for nkaiser2         *
         *            06/13/03 - Add Sar.Sartest to d/b list          *
         *            06/06/03 - Add JOBCard                          *
         *            06/04/03 - Add Routine to Determine Admin Priv  *
         *            08/28/02 - Changed SARCICS to historical        *
         *            02/25/02 - Creation                             *
         *                                                            *
         * ---------------------------------------------------------- */

         parse value "" with null jobclass jobcard panels tables

        /* -------------------------------------------------- *
         * Setup the date format desired and which is used by *
         * the ca-view generated report                       *
         *                                                    *
         *    U = mm/dd/yy  (USA)                             *
         *    E = dd/mm/yy  (European)                        *
         * -------------------------------------------------- */
         datefmt = "U"

        /* ---------------------------------------------------- *
         * Construct JOB Card Accounting                        *
         *                                                      *
         * The account code is extracted from the ISPF Variable *
         * zacctnum and then parsed to insert into the JOB Card *
         * accounting field.                                    *
         *                                                      *
         * If / found then parse and rebuild with ,             *
         * ---------------------------------------------------- */
         Address ISPExec ,
            "Vget (zacctnum jobclass)"
         if pos("/",zacctnum) > 0 then do
            parse value zacctnum with a "/" b "/" c
            acct = strip(a)","strip(b)",D"
            end
         else acct = zacctnum

        /* ---------------------------------------- *
         * Define Job Suffix for generated Job Card *
         * ---------------------------------------- */
         jobsuf = "L"

        /* ---------------------------------------------------- *
         * Define the first JOB Card statement. This is for the *
         * basic information. The Class is on another statement *
         * created in CAVXTRT.                                  *
         * ---------------------------------------------------- */
         jobname = sysvar(sysuid)""jobsuf
         jobcard = "//"left(jobname,8) "JOB '"acct"','CA-View Extract',"

        /* ----------------------------------------------------------- *
         * To customize this remove all the Select/When/Otherwise/End  *
         * sections and insert your own.  If you have only a single    *
         * node (no NJE) then you can just setup the CA-View database  *
         * and description variables.                                  *
         *                                                             *
         * If you are not using the NJE Node for testing then the      *
         * node = sysvar('sysnode') is not needed.                     *
         *                                                             *
         * The format of the variable is:                              *
         *                                                             *
         * T.1 = "hlq.database sample test database"                   *
         * T.2 = "hlq.databas2 sample test database 2"                 *
         * t.0 = 2                                                     *
         *                                                             *
         * T.£ (where £ is from 1 to n incremented by 1)               *
         * "database-dsn database description"                         *
         *                                                             *
         * The database-dsn is the hlq for the database, not the full  *
         * dataset name for the database.  It is what you use in the   *
         * /DBASE control card for SARBCH.                             *
         *                                                             *
         * The database description is a short description and blanks  *
         * are allowed.                                                *
         *                                                             *
         * The database-dsn and database description MUST be enclosed  *
         * within the same set of quotes (single ' or double ")        *
         *                                                             *
         * T.0 = number of databases                                   *
         *                                                             *
         * This example demonstrates how to setup this code to work    *
         * on multiple nodes.                                          *
         *                                                             *
         * First get the active JES Node name (sysnode)                *
         *                                                             *
         * Then use the Select/When/Otherwise to test for each node    *
         * and setup the databases appropriate to each node. Also      *
         * set the jobclass for each node.                             *
         * ----------------------------------------------------------- */

         node = sysvar('sysnode')

        /* ------------------------------------------------ *
         * Start of Kaiser Specific Database Specifications *
         * ------------------------------------------------ */
         Select
           When node = "HAWJES2" then do
                t.1 =  "HI.SAR.DB01 CA-View (SAR)"
                t.2 =  "HI.SAR.TEST.DB01 CA-View (SAR) Test Database"
                t.0 = 2
                end
           When node = "NKAISERA" then do
                jobclass = "A"
                t.1 =  "SAR.SARPROD1 General Production"
                t.2 =  "SAR.SARPROD2 Oversize Reports"
                t.3 =  "SAR.SARPROD3 Production JCL & Messages"
                t.4 =  "SAR.SARCICS CICS Compiles (historical)"
                t.5 =  "SAR.SARUSER SAR User"
                t.6 =  "SAR.SARSYSTM SAR System"
                t.0 = 6
                end
           When node = "NKAISER2" then do
                jobclass = "V"
                t.1 =  "SAR.SARTEST CA-View Testing"
                t.0 = 1
                end
           When node = "SKAISERB" then do
                t.1 = "SAR.CENTEAST Central East Region + Ohio & MidAtlantic"
                t.2 = "SAR.RM.TST Rocky Mountain"
                t.3 = "SAR.SYSH Brooklyn Heights"
                t.4 = "SYSL.SAR.TST Southern California"
                t.5 = "SYSL.SAR.IRCS Q/Care, CMIS, IVIS, MM Common Systems"
                t.6 = "SYSL.SAR.CNG Change Control"
                t.7 = "SYSL.SAR.NW Northwest Region"
                t.8 = "SAR.SARUSER NCAL Development Reports"
                t.9 = "SAR.SARCICS NCAL CICS Development Reports"
                t.10 = "SYSL.SAR.MVS MSS Group Test D/B"
                t.0 = 10
                end
           When node = "SKAISERC" then do
                jobclass = "V"
                t.1 = "SAR.BH Ohio Historical Job Output Messages"
                t.2 = "SAR.CENTEAST Central East Region + Ohio & MidAtlantic"
                t.3 = "SAR.CIC CICS Dumps"
                t.4 = "SAR.IRCP Southwest Region and Common Service Center"
                t.5 = "SAR.IRCS KPIT Finance Division"
                t.6 = "SAR.JCL Job Output Messages for All Regions"
                t.7 = "SAR.NW Northwest Region"
                t.8 = "SAR.RM.JCL Rocky Mountain JCL"
                t.9  = "SAR.RM.RPTS Rocky Mountain Reports"
                t.10 = "SAR.RPT Southern California Region"
                t.0 = 10
                end
             Otherwise t.0 = 0
             end
        /* -------------------------------- *
         * End of Kaiser Specific Databases *
         * -------------------------------- */

        /* ----------------------------------------------------------- *
         * Define the Computer Associates CA-View ISPF Panel and Table *
         * dataset names.  This is only required if these libraries    *
         * are not in your standard TSO/ISPF allocations, if they are  *
         * then set these variables to null.                           *
         * ----------------------------------------------------------- */
         env    = mvsvar("SYMDEF","KSYSENV")
         panels = "'sysl.view."env".caiispp'"
         tables = "'sysl.view."env".caiispt'"

        /* ----------------------------------------------- *
         * Determine if the current user is authorized for *
         * Administrative Priviledges.                     *
         *                                                 *
         * For RACF extract the Default-Group and compare. *
         *    - Return ADMIN OK if authorized              *
         *      otherwise nothing                          *
         * ----------------------------------------------- */
         call outtrap "admin."
         "LU" sysvar('sysuid')
         call outtrap "off"
         parse value admin.2 with "DEFAULT-GROUP="group .
         admin_groups = "SDSMVS SYSSCP01"
         if wordpos(group,admin_groups) > 0 then
            Queue "ADMIN OK"

        /* ---------------------------------------- *
         * Now queue the information out to CAVXTRT *
         * ---------------------------------------- */
         Queue "JOBCARD" jobcard
         Queue "JOBCLASS" jobclass
         Queue "DATEFMT" datefmt
         Queue "PANELS" panels
         Queue "TABLES" tables
         if t.0 = 0 then QUEUE "DB none"
         else do i = 1 to t.0
              Queue "DB" t.i
              end

./ ADD NAME=CAVXTRTD
        /* --------------------  rexx procedure  -------------------- *
         * Name:      CAVXTRTD                                        *
         *                                                            *
         * Function:  Defaults/Local Customizations for CAVXTRT       *
         *                                                            *
         * Syntax:    called by CAVXTRT                               *
         *                                                            *
         * Author:    Lionel B. Dyck                                  *
         *            Kaiser Permanente Information Technology        *
         *            Walnut Creek, CA 94598                          *
         *            (925) 926-5332                                  *
         *            Internet: lionel.b.dyck‡kp.org                  *
         *                                                            *
         * Dependencies: some knowledge of REXX coding.               *
         *                                                            *
         * History:                                                   *
         *            02/11/04 - Updated the panel/table ca lib       *
         *                       data set names with plex name        *
         *            07/10/03 - Remove SAR.RM from PROD              *
         *            06/16/03 - Change jobclass for nkaiser2         *
         *            06/13/03 - Add Sar.Sartest to d/b list          *
         *            06/06/03 - Add JOBCard                          *
         *            06/04/03 - Add Routine to Determine Admin Priv  *
         *            08/28/02 - Changed SARCICS to historical        *
         *            02/25/02 - Creation                             *
         *                                                            *
         * ---------------------------------------------------------- */

         parse value "" with null jobclass jobcard panels tables

        /* -------------------------------------------------- *
         * Setup the date format desired and which is used by *
         * the ca-view generated report                       *
         *                                                    *
         *    U = mm/dd/yy  (USA)                             *
         *    E = dd/mm/yy  (European)                        *
         * -------------------------------------------------- */
         datefmt = "U"

        /* ---------------------------------------------------- *
         * Construct JOB Card Accounting                        *
         *                                                      *
         * The account code is extracted from the ISPF Variable *
         * zacctnum and then parsed to insert into the JOB Card *
         * accounting field.                                    *
         *                                                      *
         * If / found then parse and rebuild with ,             *
         * ---------------------------------------------------- */
         Address ISPExec ,
            "Vget (zacctnum jobclass)"
         if pos("/",zacctnum) > 0 then do
            parse value zacctnum with a "/" b "/" c
            acct = strip(a)","strip(b)",D"
            end
         else acct = zacctnum

        /* ---------------------------------------- *
         * Define Job Suffix for generated Job Card *
         * ---------------------------------------- */
         jobsuf = "L"

        /* ---------------------------------------------------- *
         * Define the first JOB Card statement. This is for the *
         * basic information. The Class is on another statement *
         * created in CAVXTRT.                                  *
         * ---------------------------------------------------- */
         jobname = sysvar(sysuid)""jobsuf
         jobcard = "//"left(jobname,8) "JOB '"acct"','CA-View Extract',"

        /* ----------------------------------------------------------- *
         * To customize this remove all the Select/When/Otherwise/End  *
         * sections and insert your own.  If you have only a single    *
         * node (no NJE) then you can just setup the CA-View database  *
         * and description variables.                                  *
         *                                                             *
         * If you are not using the NJE Node for testing then the      *
         * node = sysvar('sysnode') is not needed.                     *
         *                                                             *
         * The format of the variable is:                              *
         *                                                             *
         * T.1 = "hlq.database sample test database"                   *
         * T.2 = "hlq.databas2 sample test database 2"                 *
         * t.0 = 2                                                     *
         *                                                             *
         * T.£ (where £ is from 1 to n incremented by 1)               *
         * "database-dsn database description"                         *
         *                                                             *
         * The database-dsn is the hlq for the database, not the full  *
         * dataset name for the database.  It is what you use in the   *
         * /DBASE control card for SARBCH.                             *
         *                                                             *
         * The database description is a short description and blanks  *
         * are allowed.                                                *
         *                                                             *
         * The database-dsn and database description MUST be enclosed  *
         * within the same set of quotes (single ' or double ")        *
         *                                                             *
         * T.0 = number of databases                                   *
         *                                                             *
         * This example demonstrates how to setup this code to work    *
         * on multiple nodes.                                          *
         *                                                             *
         * First get the active JES Node name (sysnode)                *
         *                                                             *
         * Then use the Select/When/Otherwise to test for each node    *
         * and setup the databases appropriate to each node. Also      *
         * set the jobclass for each node.                             *
         * ----------------------------------------------------------- */

         node = sysvar('sysnode')

        /* ------------------------------------------------ *
         * Start of Kaiser Specific Database Specifications *
         * ------------------------------------------------ */
         Select
           When node = "N1" then do
                t.1 =  "SYPS.CAVIEW20 General Production"
                t.0 = 1
                end
           When node = "N2"       then do
                jobclass = "A"
                t.1 =  "SAR.SARPROD1 General Production"
                t.2 =  "SAR.SARPROD2 Oversize Reports"
                t.3 =  "SAR.SARPROD3 Production JCL & Messages"
                t.4 =  "SAR.SARCICS CICS Compiles (historical)"
                t.5 =  "SAR.SARUSER SAR User"
                t.6 =  "SAR.SARSYSTM SAR System"
                t.0 = 6
                end
           When node = "NKAISER2" then do
                jobclass = "V"
                t.1 =  "SAR.SARTEST CA-View Testing"
                t.0 = 1
                end
           When node = "SKAISERB" then do
                t.1 = "SAR.CENTEAST Central East Region + Ohio & MidAtlantic"
                t.2 = "SAR.RM.TST Rocky Mountain"
                t.3 = "SAR.SYSH Brooklyn Heights"
                t.4 = "SYSL.SAR.TST Southern California"
                t.5 = "SYSL.SAR.IRCS Q/Care, CMIS, IVIS, MM Common Systems"
                t.6 = "SYSL.SAR.CNG Change Control"
                t.7 = "SYSL.SAR.NW Northwest Region"
                t.8 = "SAR.SARUSER NCAL Development Reports"
                t.9 = "SAR.SARCICS NCAL CICS Development Reports"
                t.10 = "SYSL.SAR.MVS MSS Group Test D/B"
                t.0 = 10
                end
           When node = "SKAISERC" then do
                jobclass = "V"
                t.1 = "SAR.BH Ohio Historical Job Output Messages"
                t.2 = "SAR.CENTEAST Central East Region + Ohio & MidAtlantic"
                t.3 = "SAR.CIC CICS Dumps"
                t.4 = "SAR.IRCP Southwest Region and Common Service Center"
                t.5 = "SAR.IRCS KPIT Finance Division"
                t.6 = "SAR.JCL Job Output Messages for All Regions"
                t.7 = "SAR.NW Northwest Region"
                t.8 = "SAR.RM.JCL Rocky Mountain JCL"
                t.9  = "SAR.RM.RPTS Rocky Mountain Reports"
                t.10 = "SAR.RPT Southern California Region"
                t.0 = 10
                end
             Otherwise t.0 = 0
             end
        /* -------------------------------- *
         * End of Kaiser Specific Databases *
         * -------------------------------- */

        /* ----------------------------------------------------------- *
         * Define the Computer Associates CA-View ISPF Panel and Table *
         * dataset names.  This is only required if these libraries    *
         * are not in your standard TSO/ISPF allocations, if they are  *
         * then set these variables to null.                           *
         * ----------------------------------------------------------- */
         env    = mvsvar("SYMDEF","KSYSENV")
         panels = "'sysl.view."env".caiispp'"
         tables = "'sysl.view."env".caiispt'"

        /* ----------------------------------------------- *
         * Determine if the current user is authorized for *
         * Administrative Priviledges.                     *
         *                                                 *
         * For RACF extract the Default-Group and compare. *
         *    - Return ADMIN OK if authorized              *
         *      otherwise nothing                          *
         * ----------------------------------------------- */
         call outtrap "admin."
         "LU" sysvar('sysuid')
         call outtrap "off"
         parse value admin.2 with "DEFAULT-GROUP="group .
         admin_groups = "SDSMVS SYSSCP01"
         if wordpos(group,admin_groups) > 0 then
            Queue "ADMIN OK"

        /* ---------------------------------------- *
         * Now queue the information out to CAVXTRT *
         * ---------------------------------------- */
         Queue "JOBCARD" jobcard
         Queue "JOBCLASS" jobclass
         Queue "DATEFMT" datefmt
         Queue "PANELS" panels
         Queue "TABLES" tables
         if t.0 = 0 then QUEUE "DB none"
         else do i = 1 to t.0
              Queue "DB" t.i
              end

./ ADD NAME=CTMAPI00
/* Implement BAPI mode call in REXX .                                */ 00010000
/*S28P.IOA920.SAMPLE(CTMAPI00)*/                                        00011001
/* This exec call CTMAPI in BAPI mode extracts and prints the RBA of */ 00020000
/* a job.                                                            */ 00030000
/*trace r */                                                            00040000
/**/                                                                    00050000
nullword  = '00000000'x                                                 00060000
nullbyte  = '00'x                                                       00070000
nullhalf  = '0000'x                                                     00080000
/**/                                                                    00090000
/*  Define and initalize the BAPI fields according  to the CTMBAPI   */ 00100000
/*  macro. This is the long way. One can create a string length      */ 00110000
/*  BAPILEN containaing binary zeros and just copy there the desired */ 00120000
/*  values to correct places using SUBTR function.                   */ 00130000
/*  The compiled copy of CTMBAPI is needed because one must use the  */ 00140000
/*  offsets  of the various fields.                                  */ 00150000
/*  Beware - In REXX offsets start from 1 .                          */ 00160000
/**/                                                                    00170000
bapisign = 'BAPI'   /* SIGNATURE. NEEDED IN ANY CALL */                 00180000
bapivers  = '01'x   /* MACRO VERSION. NEEDED IN ANY CALL */             00190000
bapicmda  = nullword                                                    00200000
bapicmdl  = nullword                                                    00210000
bapirpls  = nullword                                                    00220000
bapirple  = nullword                                                    00230000
bapirpl£  = nullword                                                    00240000
bapirplc  = nullword                                                    00250000
bapiwork  = nullword                                                    00260000
bapimct   = nullword                                                    00270000
bapirc    = nullhalf                                                    00280000
bapirsn   = nullhalf                                                    00290000
bapiurc   = nullhalf                                                    00300000
bapicmd   = '02'x   /* BAPI_M_STATUS */                                 00310000
bapiflg1  = nullbyte                                                    00320000
bapiflg2  = nullbyte                                                    00330000
bapiflg3  = nullbyte                                                    00340000
bapiflg4  = nullbyte                                                    00350000
bapiflg5  = nullbyte                                                    00360000
bapiflg6  = nullbyte                                                    00370000
bapiflg7  = nullbyte                                                    00380000
bapiflg8  = nullbyte                                                    00390000
bapiflo1  = nullbyte                                                    00400000
bapiflo2  = nullbyte                                                    00410000
bapiflo3  = nullbyte                                                    00420000
bapiflo4  = nullbyte                                                    00430000
bapiext   = nullword                                                    00440000
/**/                                                                    00450000
/*  Here start the search extension. The job will be looked      */     00460000
/*  for according to the set up of this fields. Unused fields    */     00470000
/*  should be blanked . View CTMAPI docs to see how to plan for  */     00480000
/*  more then one job who matches search criteria                */     00490000
/*  This particular code relies on the fact that at most one job */     00500000
/*  with the same search criteria ( MEMNAME in this case ) is on */     00510000
/*  the AJF.                                                     */     00520000
/**/                                                                    00530000
bapisoid  = copies(' ',5)                                               00540000
bapismem  = 'IEFBR14 '     /* SEARCH ACCORDING TO MEMBER */             00550000
bapisgrn  = copies(' ',20)                                              00560000
bapisjnm  = copies(' ',8)                                               00570000
bapisjid  = copies(' ',5)                                               00580000
bapisstt  = copies(' ',15)                                              00590000
bapislib  = copies(' ',44)                                              00600000
bapistab  = copies(' ',8)                                               00610000
bapisown  = copies(' ',8)                                               00620000
bapistyp  = copies(' ',3)                                               00630000
bapisodt  = copies(' ',6)                                               00640000
bapishld  = ' '                                                         00650000
bapisrbb  = copies(' ',3)                                               00660000
bapisrba  = copies(' ',6)                                               00670000
bapilen   = x'0A3A'                                                     00680000
/**/                                                                    00690000
bapihead  = bapisign!!bapivers!!copies('00'x,3),                        00700000
            !!copies('00000000'x,2),                                    00710000
            !!bapicmda!!bapicmdl,                                       00720000
            !!bapirpls!!bapirple!!bapirpl£!!bapirplc,                   00730000
            !!copies(nullword,4),                                       00740000
            !!bapiwork!!bapimct,                                        00750000
            !!bapirc!!bapirsn!!bapiurc,                                 00760000
            !!copies('0000'x,3),                                        00770000
            !!bapicmd,                                                  00780000
            !!bapiflg1!!bapiflg2!!bapiflg3!!bapiflg4,                   00790000
            !!bapiflg5!!bapiflg6!!bapiflg7!!bapiflg8,                   00800000
            !!bapiflo1!!bapiflo2!!bapiflo3!!bapiflo4,                   00810000
            !!copies('00'x,3),                                          00820000
            !!copies(nullword,20),                                      00830000
            !!bapiext,                                                  00840000
            !!copies('00'x,96),                                         00850000
            !!copies('00'x,100)                                         00860000
/**/                                                                    00870000
bapisearch = bapisoid!!bapismem!!bapisgrn!!bapisjnm!!bapisjid,          00880000
            !!bapisstt!!bapislib!!bapistab!!bapisown,                   00890000
            !!bapistyp!!bapisodt!!bapishld!!bapisrbb!!bapisrba          00900000
/**/                                                                    00910000
bapi  = bapihead!!bapisearch!!copies('00'x,2000)                        00920000
/**/                                                                    00930000
address linkmvs "ctmapi bapi"                                           00940000
if ( rc < 0 ) then do                                                   00950000
   say  'runnig ctmapi failed rc is :' rc                               00960000
   exit                                                                 00970000
end                                                                     00980000
/**/                                                                    00990000
/*  Analyze result.  Print the RBA of job if found. use listing  */     01000000
/*  of CTMBAPI dsect . Translate offsets of fileds to decimal    */     01010000
/*  notation and add 1 for REXX.                                 */     01020000
/**/                                                                    01030000
bapirc = substr(bapi,65,2)                                              01040000
bapirsn = substr(bapi,67,2)                                             01050000
bapiurc = substr(bapi,69,2)                                             01060000
SAY ' AFTER CTMAPI '                                                    01070000
SAY 'BAPIRC IS :' c2d(bapirc)                                           01080000
SAY 'BAPIRSN IS :' c2d(bapirsn)                                         01090000
SAY 'BAPIURC IS :' c2d(bapiurc)                                         01100000
/**/                                                                    01110000
/* print the rba. when more then one job found the rba field  */        01120000
/* is unchanged and reason code is 208.                       */        01130000
/**/                                                                    01140000
if (c2d(bapirc) = 0 ) then do                                           01150000
   bapisrba = substr(bapi,507,6)                                        01160000
   if (bapisrba  Á== '      ' ) then                                    01170000
      say ' RBA of job is :' bapisrba                                   01180000
   else                                                                 01190000
      if (c2d(bapirsn) = 208 ) then                                     01200000
         say ' more then one job found '                                01210000
      else  say 'error occur '                                          01220000
end                                                                     01230000
exit                                                                    01240000

./ ADD NAME=CTMAPI01
/* Implement BAPI mode call in REXX .                                */ 00010000
/*S28P.IOA920.SAMPLE(CTMAPI01)*/                                        00011001
/* This exec calls CTMAPI in BAPI mode to order a job and, in addi-  */ 00020000
/* tion, add 2 setvar statements. CTMBAPI, the interface dsect to    */ 00021000
/* CTMAPI, contains several fields that are addresses. In REXX it    */ 00030000
/* is a problem to deal with addresses. In the method demonstrated   */ 00030100
/* in this exec all varaiables whose addresses are to be set in the  */ 00031000
/* BAPI dsect are appended to the dsect and passed to CTMAPI as one  */ 00031100
/* parameter.  The relevant fields in the dsect do not contain their */ 00032000
/* addresses but their offset from the start of the parameter list.  */ 00032100
/* In addition a special indicator BAPIF1OF is set in BAPIFLG1.      */ 00033000
/* This causes CTMAPI to convert the offsets into addresses before   */ 00033100
/* accessing the respective variables.                               */ 00034000
/*********************************************************************/ 00034100
/*trace r */                                                            00034200
/**/                                                                    00034300
say form()                                                              00034400
nullword  = '00000000'x                                                 00034500
nullbyte  = '00'x                                                       00034600
nullhalf  = '0000'x                                                     00034700
/*********************************************************************/ 00090000
/*  Define and initalize the BAPI fields according  to the CTMBAPI   */ 00100000
/*  macro. This is the long way. One can create a string length      */ 00110000
/*  BAPILEN containaing binary zeros and just copy there the desired */ 00120000
/*  values to the correct places using SUBTR function.               */ 00130000
/*  The compiled copy of CTMBAPI is needed because one must use the  */ 00140000
/*  offsets  of the various fields.                                  */ 00150000
/*  Beware - In REXX offsets start from 1 .                          */ 00160000
/*********************************************************************/ 00170000
bapisign = 'BAPI'   /* SIGNATURE. NEEDED IN ANY CALL */                 00180000
bapivers  = '01'x   /* MACRO VERSION. NEEDED IN ANY CALL */             00190000
bapicmda  = nullword                                                    00200000
bapicmdl  = nullword                                                    00210000
bapirpls  = nullword                                                    00220000
bapirple  = nullword                                                    00230000
bapirpl£  = nullword                                                    00240000
bapirplc  = nullword                                                    00250000
bapiwork  = nullword                                                    00260000
bapimct   = nullword                                                    00270000
bapirc    = nullhalf                                                    00280000
bapirsn   = nullhalf                                                    00290000
bapiurc   = nullhalf                                                    00300000
bapicmd   = nullbyte                                                    00310000
bapiflg1  = nullbyte                                                    00320000
bapiflg2  = nullbyte                                                    00330000
bapiflg3  = nullbyte                                                    00340000
bapiflg4  = nullbyte                                                    00350000
bapiflg5  = nullbyte                                                    00360000
bapiflg6  = nullbyte                                                    00370000
bapiflg7  = nullbyte                                                    00380000
bapiflg8  = nullbyte                                                    00390000
bapiflo1  = nullbyte                                                    00400000
bapiflo2  = nullbyte                                                    00410000
bapiflo3  = nullbyte                                                    00420000
bapiflo4  = nullbyte                                                    00430000
bapiext   = nullword                                                    00440000
/*****************************************************************/     00450000
/*  Start of ORDER extension.                                    */     00460000
/*****************************************************************/     00500000
bapicmd = '01'x    /*bapi_m_order*/                                     00500100
dsn = 'CTMP.V610.SCHEDULE'                                              00500200
bapiodsn= dsn!!copies(' ',44-length(dsn))                               00501000
bapiomem= 'TABLE610'                                                    00502000
bapiodd = copies(' ',8)                                                 00503100
BAPIOJOB= 'JOB78   '                                                    00503200
bapiodat= 'ODATE '                                                      00503300
bapiorba= copies(' ',6)                                                 00503400
bapiosp1= copies('00'x,30)   /*spare field*/                            00503500
bapiof1 = nullbyte                                                      00503600
bapiof2 = nullbyte                                                      00503700
bapiof3 = nullbyte                                                      00503800
bapiosp2= copies('00'x,3)   /*spare field hidden */                     00503900
bapiobot= nullword                                                      00504000
bapiotop= nullword                                                      00504100
/********************************************************************/  00504200
/*  Define the additional 2 setvar statements we would like to add  */  00504300
/*  to the job. Determine that their offset in the parameter passed */  00504400
/*  to CTMAPI is 10000.                                             */  00504500
/********************************************************************/  00504600
var1 = '%%ABC=100'                                                      00504700
var2 = '%%CDE=200'                                                      00504800
var1 =     var1!!copies(' ',66-length(var1))                            00505000
var2 =     var2!!copies(' ',66-length(var2))                            00505100
var =   var1!!var2                                                      00505200
bapiosva= d2c(10000,4)   /*disp where we shall put var when we build    00505300
                           final bapi */                                00505400
bapiosvn= d2c(2,2)       /*num of set var statements*/                  00505500
/******************************************************************/    00505600
/*  Create the ORDER extension                                    */    00505700
/******************************************************************/    00505800
bapivar = bapiodsn,                                                     00505900
                  !!bapiomem,                                           00506000
                  !!bapiodd,                                            00506100
                  !!bapiojob,                                           00506200
                  !!bapiodat,                                           00506300
                  !!bapiorba,                                           00506400
                  !!bapiosp1,                                           00506500
                  !!bapiof1,                                            00506600
                  !!bapiof2,                                            00506700
                  !!bapiof3,                                            00506800
                  !!bapiosp2,                                           00506900
                  !!bapiobot,                                           00507000
                  !!bapiotop,                                           00507100
                  !!bapiosvn,                                           00507200
                  !!bapiosva,                                           00507300
                  !!copies('00'x,5000)                                  00508000
bapilen   = x'0A3A'                                                     00650000
/********************************************************************/  00660000
/*  bapif1of  - CTMAPI should convert offsets to addresses.         */  00670000
/********************************************************************/  00690000
bapiflg1 = '60'x  /* bapif1of  */                                       00700000
/********************************************************************/  00710000
/*  create the bapi header                                          */  00711000
/********************************************************************/  00712000
bapihead  = bapisign!!bapivers!!copies('00'x,3),                        00720000
            !!copies('00000000'x,2),                                    00730000
            !!bapicmda!!bapicmdl,                                       00740000
            !!bapirpls!!bapirple!!bapirpl£!!bapirplc,                   00750000
            !!copies(nullword,4),                                       00760000
            !!bapiwork!!bapimct,                                        00770000
            !!bapirc!!bapirsn!!bapiurc,                                 00780000
            !!copies('0000'x,3),                                        00790000
            !!bapicmd,                                                  00800000
            !!bapiflg1!!bapiflg2!!bapiflg3!!bapiflg4,                   00810000
            !!bapiflg5!!bapiflg6!!bapiflg7!!bapiflg8,                   00820000
            !!bapiflo1!!bapiflo2!!bapiflo3!!bapiflo4,                   00830000
            !!copies('00'x,3),                                          00840000
            !!copies(nullword,20),                                      00850000
            !!bapiext,                                                  00860000
            !!copies('00'x,96),                                         00870000
            !!copies('00'x,100)                                         00880000
/*****************************************************************/     00890000
/*  Create the parm to be passed to CTMAPI. It contains 3 parts  */     00891000
/*  1. The BAPI string which must match exactly the CTMBAPI      */     00892000
/*     dsect.                                                    */     00893000
/*  2. A filler to which we will add bytes to a total length     */     00894000
/*     of 10000 which is the offset we determined for the        */     00895000
/*     setvar commands.                                          */     00895100
/*  3. The SETVAR commands themselves.                           */     00896000
/*****************************************************************/     00897000
bapi  = bapihead!!bapivar                                               00900000
buffer = copies('00'x,10000-length(bapi))                               00910000
parm = bapi!!buffer!!var  /* var is in disp 10000 from bapi */          00920000
/**/                                                                    00930000
address linkmvs "ctmapi parm"                                           00940000
bapi = substr(parm,1,length(bapi))                                      00941000
/*****************************************************************/     00950000
/*  Analyze result.  Print the RBA of job if found. use listing  */     00960000
/*  of CTMBAPI dsect . Translate offsets of fileds to decimal    */     00970000
/*  notation and add 1 for REXX.                                 */     00980000
/*****************************************************************/     00990000
bapirc = substr(bapi,65,2)                                              01000000
bapirsn = substr(bapi,67,2)                                             01010000
bapiurc = substr(bapi,69,2)                                             01020000
SAY ' AFTER CTMAPI '                                                    01030000
SAY 'BAPIRC IS :' c2x(bapirc)                                           01040000
SAY 'BAPIRSN IS :' c2x(bapirsn)                                         01050000
SAY 'BAPIURC IS :' c2x(bapiurc)                                         01060000
if (c2d(bapirc) = 0  ) then do                                          01070000
   bapisrba = substr(bapi,507,6)                                        01080000
   say ' RBA of job is :' bapisrba                                      01090000
end                                                                     01100000
exit                                                                    01110000

./ ADD NAME=DB2SPACE
/* REXX    DB2SPACE   Calculate the amount of space needed by a DB2
                      database and index.

           Written by Frank Clarke, Houston, 19981019

     Impact Analysis
.    SYSEXEC   TRAPOUT

     Modification History
     20021010 fxc upgrade from v.19980225 to v.20020513;

*/ arg argline
address TSO                            /* REXXSKEL ver.20020513      */
arg parms "((" opts

signal on syntax
signal on novalue

call TOOLKIT_INIT                      /* conventional start-up     -*/
rc = Trace("O"); rc = Trace(tv)
info   = parms                         /* to enable parsing          */

call A_INIT                            /*                           -*/
call B_CALC                            /*                           -*/

if ^sw.nested then call DUMP_QUEUE     /*                           -*/
exit                                   /*@ DB2SPACE                  */
/*
.  ----------------------------------------------------------------- */
A_INIT:                                /*@                           */
   if branch then call BRANCH
   address TSO

   call AA_KEYWDS                      /*                           -*/
   parse value "0 0 0 0 0 0 0 0 0 0" with,
           entpleaf  leafpgs  indexpgs  workpgs  intpages  indexk .

return                                 /*@ A_INIT                    */
/*
.  ----------------------------------------------------------------- */
AA_KEYWDS:                             /*@                           */
   if branch then call BRANCH
   address TSO

   rows        = KEYWD("ROWS")
   lrecl       = KEYWD("LRECL")
   keysize     = KEYWD("KEYSIZE")

   if Words(rows lrecl keysize) <> 3 then do
      helpmsg = "Missing required parameters. "
      call HELP                        /*                           -*/
      end

return                                 /*@ AA_KEYWDS                 */
/*
.  ----------------------------------------------------------------- */
B_CALC:                                /*@                           */
   if branch then call BRANCH
   address TSO

   tblsize      = rows * lrecl
   rowsppg      = 4074 % (lrecl+8)     /* rows per page              */
   if rowsppg > 127 then rowsppg = 127 /* 127 max                    */

   tblpages     = rows % rowsppg  + 1  /*                            */
   tablek       = (tblpages + 2) * 4   /* base table size            */

   if keysize > 0 then call BX_CALC_INDEX     /*                    -*/

   "CLEAR"
   say "Table calculation"
   say
   say "LRECL (bytes/row)        :"Right(lrecl     ,6)
   say "# of rows                :"Right(rows      ,6)
   say "Rows per 4K Page         :"Right(rowsppg   ,6)
   say "Pages                    :"Right(tblpages  ,6)
   say "Total size (Kbytes)      :"Right(tablek    ,6)
   say
   say
   say "Index calculation"
   say
   say "Key length               :"Right(keysize   ,6)
   say "Entries per 4K Leaf page :"Right(entpleaf  ,6)
   say "Leaf pages needed        :"Right(leafpgs   ,6)
   say "Intermediate pages needed:"Right(intpages  ,6)
   say "Total index pages        :"Right(indexpgs  ,6)
   say "Index size (Kbytes)      :"Right(indexk    ,6)

return                                 /*@ B_CALC                    */
/*
.  ----------------------------------------------------------------- */
BX_CALC_INDEX:                         /*@                           */
   if branch then call BRANCH
   address TSO

   entpleaf     = 4050 % (keysize + 4) /* entries per leaf           */
   leafpgs      = rows % entpleaf + 1  /* base index pages           */

   indexpgs     = 1 + leafpgs          /* add the top page           */
   workpgs      = leafpgs              /* preserve leafpgs           */
   do while workpgs > entpleaf         /* calc intermediate pages    */
      intpages  = workpgs % entpleaf
      if intpages < (workpgs / entpleaf) then,  /* truncation        */
         intpages = intpages + 1       /* round up                   */
      indexpgs  = indexpgs + intpages
      workpgs   = intpages
   end
   indexk       = (indexpgs + 2) * 4

return                                 /*@ BX_CALC_INDEX             */
/*
.  ----------------------------------------------------------------- */
LOCAL_PREINIT:                         /*@ customize opts            */
   address TSO


return                                 /*@ LOCAL_PREINIT             */
/*   subroutines below LOCAL_PREINIT are not selected by SHOWFLOW    */
/*
.  ----------------------------------------------------------------- */
HELP:                                  /*@                           */
address TSO;"CLEAR"
if helpmsg <> "" then do ; say helpmsg; say ""; end
ex_nam = Left(exec_name,8)             /* predictable size           */
say "                                                                          "
say "  "ex_nam"      Calculates space requirements for DB2 tables and indexes. "
say "                                                                          "
say "  Syntax:   "ex_nam"  <LRECL   recordsize>                      (Required)"
say "                      <ROWS    tablesize>                       (Required)"
say "                      <KEYSIZE keylength>                       (Required)"
say "                                                                          "
say "            <recordsize>    the nominal length of a typical DB2 table row "
say "                      for this table.                                     "
say "                                                                          "
say "            <tablesize>     the expected number of rows to be contained in"
say "                      this table.                                         "
say "                                                                          "
say "            <keylength>     the size in bytes of the key (if any) for this"
say "                      table.  Specify '0' if the table is not keyed.      "
say "                                                                          "
"NEWSTACK"; pull ; "CLEAR" ; "DELSTACK"
say "                                                                          "
say "   Debugging tools provided include:                                      "
say "                                                                          "
say "        BRANCH:   show all paragraph entries.                             "
say "                                                                          "
say "        TRACE tv: will use value following TRACE to place                 "
say "                  the execution in REXX TRACE Mode.                       "
say "                                                                          "
say "                                                                          "
say "   Debugging tools can be accessed in the following manner:               "
say "                                                                          "
say "        TSO" exec_name"  parameters  ((  debug-options                    "
say "                                                                          "
say "   For example:                                                           "
say "                                                                          "
say "        TSO" exec_name " (( MONITOR TRACE ?R                              "
say "                                                                          "
address ISPEXEC "CONTROL DISPLAY REFRESH"
exit                                   /*@ HELP                      */
/*
.  ----------------------------------------------------------------- */
BRANCH: Procedure expose,              /*@                           */
        sigl exec_name
   rc = trace("O")                     /* we do not want to see this */
   arg brparm .

   origin = sigl                       /* where was I called from ?  */
   do currln = origin to 1 by -1       /* inch backward to label     */
      if Right(Word(Sourceline(currln),1),1) = ":" then do
         parse value sourceline(currln) with pgfname ":" .  /* Label */
         leave ; end                   /*                name        */
   end                                 /* currln                     */

   select
      when brparm = "NAME" then return(pgfname) /* Return full name  */
      when brparm = "ID"      then do           /* wants the prefix  */
         parse var pgfname pgfpref "_" .        /* get the prefix    */
         return(pgfpref)
         end                           /* brparm = "ID"              */
      otherwise
         say left(sigl,6) left(pgfname,40) exec_name "Time:" time("L")
   end                                 /* select                     */

return                                 /*@ BRANCH                    */
/*
.  ----------------------------------------------------------------- */
DUMP_QUEUE:                            /*@ Take whatever is in stack */
   rc = trace("O")                     /*  and write to the screen   */
   address TSO

   "QSTACK"                            /* how many stacks?           */
   stk2dump    = rc - tk_init_stacks   /* remaining stacks           */
   if stk2dump = 0 & queued() = 0 then return
   say "Total Stacks" rc ,             /* rc = #of stacks            */
    "   Begin Stacks" tk_init_stacks , /* Stacks present at start    */
    "   Excess Stacks to dump" stk2dump

   do dd = rc to tk_init_stacks by -1  /* empty each one.            */
      say "Processing Stack #" dd "   Total Lines:" queued()
      do queued();pull line;say line;end /* pump to the screen       */
      "DELSTACK"                       /* remove stack               */
   end                                 /* dd = 1 to rc               */

return                                 /*@ DUMP_QUEUE                */
/* Handle CLIST-form keywords             added 20020513
.  ----------------------------------------------------------------- */
CLKWD: Procedure expose info           /*@ hide all except info      */
   arg kw
   kw = kw"("                          /* form is 'KEY(DATA)'        */
   kw_pos = Pos(kw,info)               /* find where it is, maybe    */
   if kw_pos = 0 then return ""        /* send back a null, not found*/
   rtpt   = Pos(") ",info" ",kw_pos)   /* locate end-paren           */
   slug   = Substr(info,kw_pos,rtpt-kw_pos+1)     /* isolate         */
   info   = Delstr(info,kw_pos,rtpt-kw_pos+1)     /* excise          */
   parse var slug (kw)     slug        /* drop kw                    */
   slug   = Reverse(Substr(Reverse(Strip(slug)),2))
return slug                            /*@CLKWD                      */
/* Handle multi-word keys 20020513
.  ----------------------------------------------------------------- */
KEYWD: Procedure expose info           /*@ hide all vars, except info*/
   arg kw
   kw_pos = wordpos(kw,info)           /* find where it is, maybe    */
   if kw_pos = 0 then return ""        /* send back a null, not found*/
   kw_val = word(info,kw_pos+Words(kw))/* get the next word          */
   info   = Delword(info,kw_pos,2)     /* remove both                */
return kw_val                          /*@ KEYWD                     */
/*
.  ----------------------------------------------------------------- */
KEYPHRS: Procedure expose,             /*@                           */
         info helpmsg exec_name        /*  except these three        */
   arg kp
   wp    = wordpos(kp,info)            /* where is it?               */
   if wp = 0 then return ""            /* not found                  */
   front = subword(info,1,wp-1)        /* everything before kp       */
   back  = subword(info,wp+1)          /* everything after kp        */
   parse var back dlm back             /* 1st token must be 2 bytes  */
   if length(dlm) <> 2 then            /* Must be two bytes          */
      helpmsg = helpmsg "Invalid length for delimiter("dlm") with KEYPHRS("kp")"
   if wordpos(dlm,back) = 0 then       /* search for ending delimiter*/
      helpmsg = helpmsg "No matching second delimiter("dlm") with KEYPHRS("kp")"
   if helpmsg <> "" then call HELP     /* Something is wrong         */
   parse var back kpval (dlm) back     /* get everything b/w delim   */
   info =  front back                  /* restore remainder          */
return Strip(kpval)                    /*@ KEYPHRS                   */
/*
.  ----------------------------------------------------------------- */
NOVALUE:                               /*@                           */
   say exec_name "raised NOVALUE at line" sigl
   say " "
   say "The referenced variable is" condition("D")
   say " "
   zsigl = sigl
   signal SHOW_SOURCE                  /*@ NOVALUE                   */
/*
.  ----------------------------------------------------------------- */
SHOW_SOURCE:                           /*@                           */
   call DUMP_QUEUE                     /* Spill contents of stacks  -*/
   if sourceline() <> "0" then         /* to screen                  */
      say sourceline(zsigl)
   rc =  trace("?R")
   nop
   exit                                /*@ SHOW_SOURCE               */
/*
.  ----------------------------------------------------------------- */
SS: Procedure                          /*@ Show Source               */
   arg  ssbeg  ssend  .
   if ssend = "" then ssend = 10
   if ^datatype(ssbeg,"W") ! ^datatype(ssend,"W") then return
   ssend = ssbeg + ssend
   do ssii = ssbeg to ssend ; say Strip(sourceline(ssii),'T') ; end
return                                 /*@ SS                        */
/*
.  ----------------------------------------------------------------- */
SWITCH: Procedure expose info          /*@                           */
   arg kw
   sw_val = Wordpos(kw,info) > 0       /* exists = 1; not found = 0  */
   if sw_val then                      /* exists                     */
      info = Delword(info,Wordpos(kw,info),1) /* remove it           */
return sw_val                          /*@ SWITCH                    */
/*
.  ----------------------------------------------------------------- */
SYNTAX:                                /*@                           */
   errormsg = exec_name "encountered REXX error" rc "in line" sigl":",
                        errortext(rc)
   say errormsg
   zsigl = sigl
   signal SHOW_SOURCE                  /*@ SYNTAX                    */
/*
   Can call TRAPOUT.
.  ----------------------------------------------------------------- */
TOOLKIT_INIT:                          /*@                           */
   address TSO
   info = Strip(opts,"T",")")          /* clip trailing paren        */

   parse source  sys_id  how_invokt  exec_name  DD_nm  DS_nm,
                     as_invokt  cmd_env  addr_spc  usr_tokn

   parse value "" with  tv  helpmsg  .
   parse value 0   "ISR00000  YES"     "Error-Press PF1"    with,
               sw.  zerrhm    zerralrm  zerrsm

   if SWITCH("TRAPOUT") then do
      "TRAPOUT" exec_name parms "(( TRACE R" info
      exit
      end                              /* trapout                    */

   if Word(parms,1) = "?" then call HELP /* I won't be back          */

   "QSTACK" ; tk_init_stacks = rc      /* How many stacks?           */

   parse value SWITCH("BRANCH") SWITCH("MONITOR") SWITCH("NOUPDT") with,
               branch           monitor           noupdt    .

   parse value mvsvar("SYSNAME") sysvar("SYSNODE") with,
               #tk_cpu           node          .

   sw.nested    = sysvar("SYSNEST") = "YES"
   sw.batch     = sysvar("SYSENV")  = "BACK"
   sw.inispf    = sysvar("SYSISPF") = "ACTIVE"

   parse value KEYWD("TRACE")  "O"    with   tv  .
   tk_globalvars = "exec_name  tv  helpmsg  sw.  zerrhm  zerralrm ",
                   "zerrsm  zerrlm  tk_init_stacks  branch  monitor ",
                   "noupdt"

   call LOCAL_PREINIT                  /* for more opts             -*/

return                                 /*@ TOOLKIT_INIT              */

./ ADD NAME=DESCRIBE
/* REXX    DESCRIBE   Show the data from the PGMASTR table

           Written by Frank Clarke 20020214

     Impact Analysis
.    SYSEXEC   QENQ
.    SYSEXEC   TRAPOUT

     Modification History
     ccyymmdd xxx .....
                  ....

*/ arg argline
address ISPEXEC                        /* REXXSKEL ver.20010802      */
arg parms "((" opts

signal on syntax
signal on novalue

call TOOLKIT_INIT                      /* conventional start-up     -*/
rc     = trace(tv)
info   = parms                         /* to enable parsing          */
"CONTROL ERRORS RETURN"                /* I'll handle my own         */

call A_INIT                            /*                           -*/
                                    if \sw.0error_found then,
call B_TABLE_OPS                       /*                           -*/

if \sw.nested then call DUMP_QUEUE     /*                           -*/
exit                                   /*@ DESCRIBE                  */
/*
.  ----------------------------------------------------------------- */
A_INIT:                                /*@                           */
   if branch then call BRANCH
   address TSO

   parse var info pmkey info
   if pmkey = "" then do
      helpmsg = "Key value required for search"
      call HELP                        /* ...and don't come back    -*/
      end

return                                 /*@ A_INIT                    */
/*
.  ----------------------------------------------------------------- */
B_TABLE_OPS:                           /*@                           */
   if branch then call BRANCH
   address ISPEXEC

   call BA_OPEN                        /*                           -*/
                                    if \sw.0error_found then,
   call BG_GET_ROW                     /*                           -*/
   call BZ_CLOSE                       /*                           -*/

return                                 /*@ B_TABLE_OPS               */
/*
.  ----------------------------------------------------------------- */
BA_OPEN:                               /*@                           */
   if branch then call BRANCH
   address ISPEXEC

   "LIBDEF  ISPTLIB  DATASET  ID("isptlib")  STACK"
   "TBSTATS" $tn$ "STATUS1(s1) STATUS2(s2)"
   if s1 > 1 then do
      say "Table" $tn$ "not available."
      zerrsm = "Table" $tn$ "not available."
      zerrlm = "Table" $tn$ "not found in the ISPTLIB library chain"
      sw.0error_found = "1"
      end; else,
   if s2 = 1 then do
      "TBOPEN "   $tn$   "NOWRITE"
      if rc > 0 then do
         say "Table did not open"
         sw.0error_found = "1"
         end                           /* TBOPEN failed              */
      end
   else "TBTOP" $tn$
   "LIBDEF  ISPTLIB"

return                                 /*@ BA_OPEN                   */
/*
.  ----------------------------------------------------------------- */
BAN_CHECK_ENQ:                         /*@                           */
   if branch then call BRANCH
   address TSO

   "NEWSTACK"
   "QENQ" isptlib
   do queued()
      parse pull tag msg
      say msg
   end                                 /* queued                     */
   "DELSTACK"

return                                 /*@ BAN_CHECK_ENQ             */
/*
.  ----------------------------------------------------------------- */
BG_GET_ROW:                            /*@                           */
   if branch then call BRANCH
   address ISPEXEC

   taglist = "PMKEY,EQ"
   pmkey  = pmkey"*"
   "TBSARG" $tn$ "NAMECOND("taglist")"
   "TBSCAN" $tn$
   if rc > 0 then do
      say pmkey "was not found"
      end
   else,
      say pmkey "is described as" pmdesc

return                                 /*@ BG_GET_ROW                */
/*
.  ----------------------------------------------------------------- */
BZ_CLOSE:                              /*@                           */
   if branch then call BRANCH
   address ISPEXEC

   "TBEND"  $tn$

return                                 /*@ BZ_CLOSE                  */
/*
.  ----------------------------------------------------------------- */
LOCAL_PREINIT:                         /*@ customize opts            */
   address TSO

   parse value KEYWD("ISPTLIB") "'NTIN.AT.D752.SQA.ISPTLIB'"   with,
               isptlib   .

   parse value KEYWD("ISPTABL")  isptlib    with,
               isptabl   .

   parse value KEYWD("USETBL")   "PGMASTR"  with,
               $tn$      .

return                                 /*@ LOCAL_PREINIT             */
/*   subroutines below LOCAL_PREINIT are not selected by SHOWFLOW    */
/*
.  ----------------------------------------------------------------- */
HELP:                                  /*@                           */
address TSO;"CLEAR"
if helpmsg <> "" then do ; say helpmsg; say ""; end
ex_nam = Left(exec_name,8)             /* predictable size           */
             /* The following template may be used to
                customize HELP-text for this routine.
say "  "ex_nam"      ........                                               "
say "                ........                                               "
say "                                                                       "
say "  Syntax:   "ex_nam"  ..........                                       "
say "                      ..........                                       "
say "                                                                       "
say "            ....      ..........                                       "
say "                      ..........                                       "
say "                                                                       "
"NEWSTACK"; pull ; "CLEAR" ; "DELSTACK"
say "   Debugging tools provided include:                                   "
say "                                                                       "
say "        MONITOR:  displays key information throughout processing.      "
say "                                                                       "
say "        NOUPDT:   by-pass all update logic.                            "
say "                                                                       "
say "        BRANCH:   show all paragraph entries.                          "
say "                                                                       "
say "        TRACE tv: will use value following TRACE to place the          "
say "                  execution in REXX TRACE Mode.                        "
say "                                                                       "
say "                                                                       "
say "   Debugging tools can be accessed in the following manner:            "
say "                                                                       "
say "        TSO "ex_nam"  parameters     ((  debug-options                 "
say "                                                                       "
say "   For example:                                                        "
say "                                                                       "
say "        TSO "ex_nam"  (( MONITOR TRACE ?R                              "
                                                                    .*/
address ISPEXEC "CONTROL DISPLAY REFRESH"
exit                                   /*@ HELP                      */
/*
.  ----------------------------------------------------------------- */
BRANCH: Procedure expose,              /*@                           */
        sigl exec_name
   rc = trace("O")                     /* we do not want to see this */
   arg brparm .

   origin = sigl                       /* where was I called from ?  */
   do currln = origin to 1 by -1       /* inch backward to label     */
      if Right(Word(Sourceline(currln),1),1) = ":" then do
         parse value sourceline(currln) with pgfname ":" .  /* Label */
         leave ; end                   /*                name        */
   end                                 /* currln                     */

   select
      when brparm = "NAME" then return(pgfname) /* Return full name  */
      when brparm = "ID"      then do           /* wants the prefix  */
         parse var pgfname pgfpref "_" .        /* get the prefix    */
         return(pgfpref)
         end                           /* brparm = "ID"              */
      otherwise
         say left(sigl,6) left(pgfname,40) exec_name "Time:" time("L")
   end                                 /* select                     */

return                                 /*@ BRANCH                    */
/*
.  ----------------------------------------------------------------- */
DUMP_QUEUE:                            /*@ Take whatever is in stack */
   rc = trace("O")                     /*  and write to the screen   */
   address TSO

   "QSTACK"                            /* how many stacks?           */
   stk2dump    = rc - tk_init_stacks   /* remaining stacks           */
   if stk2dump = 0 & queued() = 0 then return
   say "Total Stacks" rc ,             /* rc = #of stacks            */
    "   Begin Stacks" tk_init_stacks , /* Stacks present at start    */
    "   Excess Stacks to dump" stk2dump

   do dd = rc to tk_init_stacks by -1  /* empty each one.            */
      say "Processing Stack #" dd "   Total Lines:" queued()
      do queued();pull line;say line;end /* pump to the screen       */
      "DELSTACK"                       /* remove stack               */
   end                                 /* dd = 1 to rc               */

return                                 /*@ DUMP_QUEUE                */
/*
.  ----------------------------------------------------------------- */
KEYWD: Procedure expose info           /*@ hide all vars, except info*/
   arg kw
   kw_pos = wordpos(kw,info)           /* find where it is, maybe    */
   if kw_pos = 0 then return ""        /* send back a null, not found*/
   kw_val = word(info,kw_pos+1)        /* get the next word          */
   info   = Delword(info,kw_pos,2)     /* remove both                */
return kw_val                          /*@ KEYWD                     */
/*
.  ----------------------------------------------------------------- */
KEYPHRS: Procedure expose,             /*@                           */
         info helpmsg exec_name        /*  except these three        */
   arg kp
   wp    = wordpos(kp,info)            /* where is it?               */
   if wp = 0 then return ""            /* not found                  */
   front = subword(info,1,wp-1)        /* everything before kp       */
   back  = subword(info,wp+1)          /* everything after kp        */
   parse var back dlm back             /* 1st token must be 2 bytes  */
   if length(dlm) <> 2 then            /* Must be two bytes          */
      helpmsg = helpmsg "Invalid length for delimiter("dlm") with KEYPHRS("kp")"
   if wordpos(dlm,back) = 0 then       /* search for ending delimiter*/
      helpmsg = helpmsg "No matching second delimiter("dlm") with KEYPHRS("kp")"
   if helpmsg <> "" then call HELP     /* Something is wrong         */
   parse var back kpval (dlm) back     /* get everything b/w delim   */
   info =  front back                  /* restore remainder          */
return Strip(kpval)                    /*@ KEYPHRS                   */
/*
.  ----------------------------------------------------------------- */
NOVALUE:                               /*@                           */
   say exec_name "raised NOVALUE at line" sigl
   say " "
   say "The referenced variable is" condition("D")
   say " "
   zsigl = sigl
   signal SHOW_SOURCE                  /*@ NOVALUE                   */
/*
.  ----------------------------------------------------------------- */
SHOW_SOURCE:                           /*@                           */
   call DUMP_QUEUE                     /* Spill contents of stacks  -*/
   if sourceline() <> "0" then         /* to screen                  */
      say sourceline(zsigl)
   rc =  trace("?R")
   nop
   exit                                /*@ SHOW_SOURCE               */
/*
.  ----------------------------------------------------------------- */
SS: Procedure                          /*@ Show Source               */
   arg  ssbeg  ssend  .
   if ssend = "" then ssend = 10
   if \datatype(ssbeg,"W") | \datatype(ssend,"W") then return
   ssend = ssbeg + ssend
   do ssii = ssbeg to ssend ; say Strip(sourceline(ssii),'T') ; end
return                                 /*@ SS                        */
/*
.  ----------------------------------------------------------------- */
SWITCH: Procedure expose info          /*@                           */
   arg kw
   sw_val = Wordpos(kw,info) > 0       /* exists = 1; not found = 0  */
   if sw_val then                      /* exists                     */
      info = Delword(info,Wordpos(kw,info),1) /* remove it           */
return sw_val                          /*@ SWITCH                    */
/*
.  ----------------------------------------------------------------- */
SYNTAX:                                /*@                           */
   errormsg = exec_name "encountered REXX error" rc "in line" sigl":",
                        errortext(rc)
   say errormsg
   zsigl = sigl
   signal SHOW_SOURCE                  /*@ SYNTAX                    */
/*
   Can call TRAPOUT.
.  ----------------------------------------------------------------- */
TOOLKIT_INIT:                          /*@                           */
   address TSO
   info = Strip(opts,"T",")")          /* clip trailing paren        */

   parse source  sys_id  how_invokt  exec_name  DD_nm  DS_nm,
                     as_invokt  cmd_env  addr_spc  usr_tokn

   parse value "" with  tv  helpmsg  .
   parse value 0   "ISR00000  YES"     "Error-Press PF1"    with,
               sw.  zerrhm    zerralrm  zerrsm

   if SWITCH("TRAPOUT") then do
      "TRAPOUT" exec_name parms "(( TRACE R" info
      exit
      end                              /* trapout                    */

   if Word(parms,1) = "?" then call HELP /* I won't be back          */

   "QSTACK" ; tk_init_stacks = rc      /* How many stacks?           */

   parse value SWITCH("BRANCH") SWITCH("MONITOR") SWITCH("NOUPDT") with,
               branch           monitor           noupdt    .

   parse value mvsvar("SYSNAME") sysvar("SYSNODE") with,
               #tk_cpu           node          .

   sw.nested    = sysvar("SYSNEST") = "YES"
   sw.batch     = sysvar("SYSENV")  = "BACK"
   sw.inispf    = sysvar("SYSISPF") = "ACTIVE"

   parse value KEYWD("TRACE")  "O"    with   tv  .
   tk_globalvars = "exec_name  tv  helpmsg  sw.  zerrhm  zerralrm ",
                   "zerrsm  zerrlm  tk_init_stacks  branch  monitor ",
                   "noupdt"

   call LOCAL_PREINIT                  /* for more opts             -*/

return                                 /*@ TOOLKIT_INIT              */

./ ADD NAME=EXTTST
/* REXX    EXTTST     Demonstrates use of RXVSAM for dealing with VSAM
                      files.

           Written by Frank Clarke 20020807

     Impact Analysis
.    SYSEXEC   LISTCSUM
.    SYSEXEC   TRAPOUT
.    ISPLLIB   RXVSAM

     Modification History
     20030611 fxc enable CLEAR
     20030922 fxc allow rkp<>0
     20040426 fxc correct LIBDEF to ISPLLIB

*/ arg argline
address ISPEXEC                        /* REXXSKEL ver.20020513      */
arg parms "((" opts

signal on syntax
signal on novalue

call TOOLKIT_INIT                      /* conventional start-up     -*/
rc = Trace("O"); rc = Trace(tv)
info   = parms                         /* to enable parsing          */

"LIBDEF ISPLLIB DATASET ID('NTIN.TS.D822.LIB.ISPLLIB') STACK"
call A_INIT                            /*                           -*/
                                    if ^sw.0error_found then,
call B_VSAM_OPS                        /*                           -*/
"LIBDEF ISPLLIB"

if ^sw.nested then call DUMP_QUEUE     /*                           -*/
exit                                   /*@ EXTTST                    */
/*
.  ----------------------------------------------------------------- */
A_INIT:                                /*@                           */
   if branch then call BRANCH
   address TSO

   parse value "0 0 0 0 0 0 0"  with,
         ct.  .
   call AK_KEYWDS                      /*                           -*/

   if vsamdsn = "" then do
      helpmsg = "DSN is required."
      call HELP                        /*                           -*/
      end

   kl  = Length(key)
   call AL_LISTCSUM                    /*                           -*/
   colmk = "----+----1----+----2----+----3----+----4----+----5----+----6----+---
   uphex = Copies("0",16)Copies("1",16)Copies("2",16)Copies("3",16),
        || Copies("4",16)Copies("5",16)Copies("6",16)Copies("7",16),
        || Copies("8",16)Copies("9",16)Copies("A",16)Copies("B",16),
        || Copies("C",16)Copies("D",16)Copies("E",16)Copies("F",16)
   dnhex = Copies("0123456789ABCDEF",16)

return                                 /*@ A_INIT                    */
/*
.  ----------------------------------------------------------------- */
AK_KEYWDS:                             /*@                           */
   if branch then call BRANCH
   address TSO

   if SWITCH("CLEAR") then "CLEAR"
   sw.0Generic  = SWITCH("GENERIC")

   parse value    KEYWD("KEY") "*"   with ,
         key  .

   vsamdsn      = KEYWD("DSN")
   parse value    KEYWD("LIMIT")      "*"   with ,
                  limit   .

   sw.0NoKey    = key = "*"

return                                 /*@ AK_KEYWDS                 */
/*
.  ----------------------------------------------------------------- */
AL_LISTCSUM:                           /*@                           */
   if branch then call BRANCH
   address TSO

   rkp = "?"
   "ALTLIB   ACT APPLICATION(EXEC)  DA('DTAFXC.@@.EXEC') "
   if rc > 4 then do
      say "ALTLIB failed, RC="rc
      sw.0error_found = 1
      return
      end

   "NEWSTACK"
   "LISTCSUM" vsamdsn "STACK"
   do queued()
      pull line
      parse var line tag ":" value
      if tag  = "DATAATTRIBUTES" then do
         info = value
         rkp  = KEYWD("RKP")           /* relative key position      */
         end
   end                                    /* queued                     */
   "DELSTACK"

   "ALTLIB DEACT APPLICATION(EXEC)"

   if rkp = "?" |,
      rkp = " " then do                /* oops....                   */
      say "No RKP returned by LISTCSUM"
      sw.0error_found = 1
      end

return                                 /*@ AL_LISTCSUM               */
/*
.  ----------------------------------------------------------------- */
B_VSAM_OPS:                            /*@                           */
   if branch then call BRANCH
   address TSO

   "ALLOC FI(VSDS) DA("vsamdsn") SHR REU"
   say "Using" vsamdsn ; say ""

   rc = RXVSAM('OPENINPUT','VSDS','KSDS')
   say "OPEN" rc

   if sw.0Generic then do
      rc = RXVSAM('READGENERIC','VSDS',key,'VSREC')
      call BP_PUT_REC                  /*                           -*/
      end
   else,                               /*                            */
   if sw.0NoKey   then do
      rc = RXVSAM('READNEXT','VSDS',,'VSREC')
      call BP_PUT_REC                  /*                           -*/
      end
   else do
      rc = RXVSAM('READ','VSDS',key,'VSREC')
      call BP_PUT_REC                  /*                           -*/
      end

   do forever
      if limit <> "*" then,
         if limit <= ct.read then leave
      rc = RXVSAM('READNEXT','VSDS',,'VSREC')
      if rc > 0 then leave
      if ^sw.0NoKey then,
      If Substr(VSREC,rkp+1,kl) <> key then leave
      call BP_PUT_REC                  /*                           -*/
   end                                 /* forever                    */
   say "READ" rc

   rc = RXVSAM('CLOSE','VSDS')
   "FREE  FI(VSDS)"

return                                 /*@ B_VSAM_OPS                */
/*
.  ----------------------------------------------------------------- */
BP_PUT_REC:                            /*@                           */
   if branch then call BRANCH
   address TSO

   ct.read = ct.read + 1
   recl = Length(vsrec)
   iter = (recl%100) + 1
   colln = Left( Copies(colmk,iter) , recl )
   uplin = Translate(vsrec,uphex)
   dnlin = Translate(vsrec,dnhex)
   say vsrec
   say colln rc
   say uplin
   say dnlin

return                                 /*@ BP_PUT_REC                */
/*
.  ----------------------------------------------------------------- */
LOCAL_PREINIT:                         /*@ customize opts            */
   address TSO


return                                 /*@ LOCAL_PREINIT             */
/*   subroutines below LOCAL_PREINIT are not selected by SHOWFLOW    */
/*
.  ----------------------------------------------------------------- */
HELP:                                  /*@                           */
address TSO;"CLEAR" ; say
if helpmsg <> "" then do ; say helpmsg; say ""; end
ex_nam = Left(exec_name,8)             /* predictable size           */

say "  "ex_nam"      demonstrates a method of reading a VSAM KSDS in REXX.  "
say "                                                                       "
say "  Syntax:   "ex_nam"  <DSN vsamdsn>                          (Required)"
say "                      <KEY vsamkey>                                    "
say "                      <GENERIC>                                        "
say "                      <CLEAR>                                          "
say "                                                                       "
say "            vsamdsn   identifies the CLUSTER for which VSAM I/O is to  "
say "                      be done.                                         "
say "                                                                       "
say "            vsamkey   specifies the key (if any) to be used for the    "
say "                      initial read.  If specified, only records        "
say "                      with this key will be read.  If no key is        "
say "                      specified, all records will be read.             "
say "                                                                       "
say "            GENERIC   identifies <vsamkey> as a partial (generic) key. "
say "                                                                       "
say "            CLEAR     requests a clear screen before writing output.   "
say "                                                                       "
"NEWSTACK"; pull ; "CLEAR" ; "DELSTACK"
say "   Debugging tools provided include:                                   "
say "                                                                       "
say "        MONITOR:  displays key information throughout processing.      "
say "                                                                       "
say "        NOUPDT:   by-pass all update logic.                            "
say "                                                                       "
say "        BRANCH:   show all paragraph entries.                          "
say "                                                                       "
say "        TRACE tv: will use value following TRACE to place the          "
say "                  execution in REXX TRACE Mode.                        "
say "                                                                       "
say "                                                                       "
say "   Debugging tools can be accessed in the following manner:            "
say "                                                                       "
say "        TSO "ex_nam"  parameters     ((  debug-options                 "
say "                                                                       "
say "   For example:                                                        "
say "                                                                       "
say "        TSO "ex_nam"  (( MONITOR TRACE ?R                              "
address ISPEXEC "CONTROL DISPLAY REFRESH"
exit                                   /*@ HELP                      */
/*
.  ----------------------------------------------------------------- */
BRANCH: Procedure expose,              /*@                           */
        sigl exec_name
   rc = trace("O")                     /* we do not want to see this */
   arg brparm .

   origin = sigl                       /* where was I called from ?  */
   do currln = origin to 1 by -1       /* inch backward to label     */
      if Right(Word(Sourceline(currln),1),1) = ":" then do
         parse value sourceline(currln) with pgfname ":" .  /* Label */
         leave ; end                   /*                name        */
   end                                 /* currln                     */

   select
      when brparm = "NAME" then return(pgfname) /* Return full name  */
      when brparm = "ID"      then do           /* wants the prefix  */
         parse var pgfname pgfpref "_" .        /* get the prefix    */
         return(pgfpref)
         end                           /* brparm = "ID"              */
      otherwise
         say left(sigl,6) left(pgfname,40) exec_name "Time:" time("L")
   end                                 /* select                     */

return                                 /*@ BRANCH                    */
/*
.  ----------------------------------------------------------------- */
DUMP_QUEUE:                            /*@ Take whatever is in stack */
   rc = trace("O")                     /*  and write to the screen   */
   address TSO

   "QSTACK"                            /* how many stacks?           */
   stk2dump    = rc - tk_init_stacks   /* remaining stacks           */
   if stk2dump = 0 & queued() = 0 then return
   say "Total Stacks" rc ,             /* rc = #of stacks            */
    "   Begin Stacks" tk_init_stacks , /* Stacks present at start    */
    "   Excess Stacks to dump" stk2dump

   do dd = rc to tk_init_stacks by -1  /* empty each one.            */
      say "Processing Stack #" dd "   Total Lines:" queued()
      do queued();pull line;say line;end /* pump to the screen       */
      "DELSTACK"                       /* remove stack               */
   end                                 /* dd = 1 to rc               */

return                                 /*@ DUMP_QUEUE                */
/* Handle CLIST-form keywords             added 20020513
.  ----------------------------------------------------------------- */
CLKWD: Procedure expose info           /*@ hide all except info      */
   arg kw
   kw = kw"("                          /* form is 'KEY(DATA)'        */
   kw_pos = Pos(kw,info)               /* find where it is, maybe    */
   if kw_pos = 0 then return ""        /* send back a null, not found*/
   rtpt   = Pos(") ",info" ",kw_pos)   /* locate end-paren           */
   slug   = Substr(info,kw_pos,rtpt-kw_pos+1)     /* isolate         */
   info   = Delstr(info,kw_pos,rtpt-kw_pos+1)     /* excise          */
   parse var slug (kw)     slug        /* drop kw                    */
   slug   = Reverse(Substr(Reverse(Strip(slug)),2))
return slug                            /*@CLKWD                      */
/* Handle multi-word keys 20020513
.  ----------------------------------------------------------------- */
KEYWD: Procedure expose info           /*@ hide all vars, except info*/
   arg kw
   kw_pos = wordpos(kw,info)           /* find where it is, maybe    */
   if kw_pos = 0 then return ""        /* send back a null, not found*/
   kw_val = word(info,kw_pos+Words(kw))/* get the next word          */
   info   = Delword(info,kw_pos,2)     /* remove both                */
return kw_val                          /*@ KEYWD                     */
/*
.  ----------------------------------------------------------------- */
KEYPHRS: Procedure expose,             /*@                           */
         info helpmsg exec_name        /*  except these three        */
   arg kp
   wp    = wordpos(kp,info)            /* where is it?               */
   if wp = 0 then return ""            /* not found                  */
   front = subword(info,1,wp-1)        /* everything before kp       */
   back  = subword(info,wp+1)          /* everything after kp        */
   parse var back dlm back             /* 1st token must be 2 bytes  */
   if length(dlm) <> 2 then            /* Must be two bytes          */
      helpmsg = helpmsg "Invalid length for delimiter("dlm") with KEYPHRS("kp")"
   if wordpos(dlm,back) = 0 then       /* search for ending delimiter*/
      helpmsg = helpmsg "No matching second delimiter("dlm") with KEYPHRS("kp")"
   if helpmsg <> "" then call HELP     /* Something is wrong         */
   parse var back kpval (dlm) back     /* get everything b/w delim   */
   info =  front back                  /* restore remainder          */
return Strip(kpval)                    /*@ KEYPHRS                   */
/*
.  ----------------------------------------------------------------- */
NOVALUE:                               /*@                           */
   say exec_name "raised NOVALUE at line" sigl
   say " "
   say "The referenced variable is" condition("D")
   say " "
   zsigl = sigl
   signal SHOW_SOURCE                  /*@ NOVALUE                   */
/*
.  ----------------------------------------------------------------- */
SHOW_SOURCE:                           /*@                           */
   call DUMP_QUEUE                     /* Spill contents of stacks  -*/
   if sourceline() <> "0" then         /* to screen                  */
      say sourceline(zsigl)
   rc =  trace("?R")
   nop
   exit                                /*@ SHOW_SOURCE               */
/*
.  ----------------------------------------------------------------- */
SS: Procedure                          /*@ Show Source               */
   arg  ssbeg  ssend  .
   if ssend = "" then ssend = 10
   if ^datatype(ssbeg,"W") | ^datatype(ssend,"W") then return
   ssend = ssbeg + ssend
   do ssii = ssbeg to ssend ; say Strip(sourceline(ssii),'T') ; end
return                                 /*@ SS                        */
/*
.  ----------------------------------------------------------------- */
SWITCH: Procedure expose info          /*@                           */
   arg kw
   sw_val = Wordpos(kw,info) > 0       /* exists = 1; not found = 0  */
   if sw_val then                      /* exists                     */
      info = Delword(info,Wordpos(kw,info),1) /* remove it           */
return sw_val                          /*@ SWITCH                    */
/*
.  ----------------------------------------------------------------- */
SYNTAX:                                /*@                           */
   errormsg = exec_name "encountered REXX error" rc "in line" sigl":",
                        errortext(rc)
   say errormsg
   zsigl = sigl
   signal SHOW_SOURCE                  /*@ SYNTAX                    */
/*
   Can call TRAPOUT.
.  ----------------------------------------------------------------- */
TOOLKIT_INIT:                          /*@                           */
   address TSO
   info = Strip(opts,"T",")")          /* clip trailing paren        */

   parse source  sys_id  how_invokt  exec_name  DD_nm  DS_nm,
                     as_invokt  cmd_env  addr_spc  usr_tokn

   parse value "" with  tv  helpmsg  .
   parse value 0   "ISR00000  YES"     "Error-Press PF1"    with,
               sw.  zerrhm    zerralrm  zerrsm

   if SWITCH("TRAPOUT") then do
      "TRAPOUT" exec_name parms "(( TRACE R" info
      exit
      end                              /* trapout                    */

   if Word(parms,1) = "?" then call HELP /* I won't be back          */

   "QSTACK" ; tk_init_stacks = rc      /* How many stacks?           */

   parse value SWITCH("BRANCH") SWITCH("MONITOR") SWITCH("NOUPDT") with,
               branch           monitor           noupdt    .

   parse value mvsvar("SYSNAME") sysvar("SYSNODE") with,
               #tk_cpu           node          .

   sw.nested    = sysvar("SYSNEST") = "YES"
   sw.batch     = sysvar("SYSENV")  = "BACK"
   sw.inispf    = sysvar("SYSISPF") = "ACTIVE"

   parse value KEYWD("TRACE")  "O"    with   tv  .
   tk_globalvars = "exec_name  tv  helpmsg  sw.  zerrhm  zerralrm ",
                   "zerrsm  zerrlm  tk_init_stacks  branch  monitor ",
                   "noupdt"

   call LOCAL_PREINIT                  /* for more opts             -*/

return                                 /*@ TOOLKIT_INIT              */

./ ADD NAME=GENSAR
/* REXX    GENSAR     A special-purpose tool for generating control
                      statements for SARBCH.

                Written by Frank Clarke, HAS, Inc.
*/
signal on syntax
tv = ""
hmsg = ""
arg parms "((" opts

optl = Length(opts)                    /* how long ?                 */
if optl > 0 then,                      /* exists ?                   */
if Right(opts,1) = ")" then,           /* last char is close-paren ? */
   opts = Left(opts,optl-1)            /* clip trailing paren        */

parse var opts "TRACE" tv .
if tv ^= "" then interpret "TRACE" tv

if parms = "" then call HELP
if Word(parms,1) = "?" then call HELP

job    = KEYWD(job)
report = KEYWD(report)
gen    = KEYWD(gen)
seq    = KEYWD(seq)

if parms ^= "" then do
   hmsg = "Unrecognized parms:" parms
   call HELP
   end

if job  = "" & report  = "" then do
   hmsg = "Either JOB or REPORT must be specified."
   call HELP
   end

if job ^= "" & report ^= "" then do
   hmsg = "JOB and REPORT are mutually exclusive."
   call HELP
   end

if gen  = "" then do
   hmsg = "GEN is required."
   call HELP
   end

jobid = Strip(job||report)

"NEWSTACK"
queue "/LOAD  ID="jobid
queue "       GEN="gen
if seq ^= "" then,
queue "       SEQ="seq
queue "       DDNAME=WRITE"
"EXECIO * DISKW $OUT (FINIS"
"DELSTACK"

exit

/*-------------------------------------------------------------------*/
HELP:                                  /*@                           */
address TSO "CLEAR"
if hmsg ^= "" then do
   say hmsg
   say ""
   end
say "                                                                 "
say "  GENSAR        is a special-purpose tool for generating control "
say "                statements for SARBCH.                           "
say "                                                                 "
say "  Syntax:   GENSAR    < parms >     <  <((>  options >           "
say "                                                                 "
say "            <parms> may be any combination of:                   "
say "                    JOB jobname                                  "
say "                    REPORT reportname                            "
say "                    GEN generation-number                        "
say "                    SEQ sequence-number                          "
say "            except that a) either JOB or REPORT must be specified"
say "                (but not both), and b) GEN is required.  It is   "
say "                wise (but not neccessary) to specify SEQ.        "
say "                                                                 "
exit                                   /*@ HELP                      */

/*-------------------------------------------------------------------*/
KEYWD: Procedure expose,               /*@                           */
       kw parms
arg kw .
if Wordpos(kw,parms) = 0 then,
   kw_val = ""
else,
if Wordpos(kw,parms) = 1 then,
   kwa = kw" "
else kwa = " "kw" "
parse var parms . value(kwa)  kw_val .
if kw_val <> "" then parms = Delword(parms,Wordpos(value(kw),parms),2)
return kw_val                          /*@ KEYWD                     */

/*-------------------------------------------------------------------*/
SWITCH:                                /*@                           */
arg kw .
sw_val  = Wordpos(value(kw),parms) > 0
if sw_val  then parms = Delword(parms,Wordpos(value(kw),parms),1)
return sw_val                          /*@ SWITCH                    */

/*-------------------------------------------------------------------*/
SYNTAX:                                /*@                           */
   errormsg = "REXX error" rc "in line" sigl":" errortext(rc)
   say errormsg
   say sourceline(sigl)
   trace "?r"
   nop
exit                                   /*@ SYNTAX                    */

./ ADD NAME=HSMLIST
/* REXX    HSMLIST    A dialog to ease the use of HSM's HLIST
  https://www.rexxla.org/freerepo/REXX/
   |**-***-***-***-***-***-***-***-***-***-***-***-***-***-***-***-**|
   |                                                                 |
   |          WARNING: EMBEDDED COMPONENTS.                          |
   |                      See text following TOOLKIT_INIT            |
   |                                                                 |
   |**-***-***-***-***-***-***-***-***-***-***-***-***-***-***-***-**|

           Written by Frank Clarke 20010608

     Impact Analysis
.    SYSEXEC   POST
.    SYSEXEC   TRAPOUT

     Modification History
     20010620 fxc zap the table row on 'delete';
     20011002 fxc fix scroll-amt field;
     20020102 fxc add HELP panel; log table-load; WIDEHELP;
     20020423 fxc NOVALUE in CB_;
     20020607 fxc reorg;
     20020918 fxc progress msg during HLIST; allow KEEP of HLIST
                  output;
     20030218 fxc remove obsolete code;
     20031121 fxc text on panels;
     20040722 fxc widescreen version;
     20050218 fxc HELP for main panel;

*/ arg argline
address ISPEXEC                        /* REXXSKEL ver.20010524      */
arg parms "((" opts

signal on syntax
signal on novalue

call TOOLKIT_INIT                      /* conventional start-up     -*/
rc     = trace(tv)
info   = parms                         /* to enable parsing          */

"CONTROL ERRORS RETURN"                /* I'll handle my own         */

address TSO "POST" exec_name argline
call A_INIT                            /*                           -*/

call C_TABLE_OPS                       /*                           -*/
                                    if \sw.0halt_process then,
call D_HSM_OPS                         /*                            */

call ZB_SAVELOG                        /*                           -*/

if \sw.nested then call DUMP_QUEUE     /*                           -*/
exit                                   /*@ HSMLIST                   */
/*
   Initialization
.  ----------------------------------------------------------------- */
A_INIT:                                /*@                           */
   if branch then call BRANCH
   address TSO

   call AL_SETUP_LOG                   /*                           -*/
   parse value "0 0 0 0 0 0 0 0 0" with ,
         req.  ,
         .

   parse value "" with ,
         dslevel  odsn ,
         dsname  backdt  backtm  gen ,
         .
   call AP_KEYWDS                      /*                           -*/
   parse var info   dslevel  info

return                                 /*@ A_INIT                    */
/*
   Allocate the LOG dataset
.  ----------------------------------------------------------------- */
AL_SETUP_LOG:                          /*@                           */
   if branch then call BRANCH
   address TSO

   parse value "0" with,
               log#    log.
   parse value Date("S")  Time("S")  Time("N")  with,
               yyyymmdd   sssss      hhmmss  .
   parse var yyyymmdd  4 yrdigit 5 mm 7 dd          /* 9 12 14 maybe */
   if Pos(yrdigit,"13579") > 0 then mm = mm + 12       /* mm=24      */
   logtag = Substr("ABCDEFGHIJKLMNOPQRSTUVWX",mm,1)    /* logtag=X   */
   subid  = logtag""dd""Right(sssss,5,0)               /* X1423722 ? */
   vb4k.0    = "NEW CATALOG UNIT(SYSDA) SPACE(1 5) TRACKS",
               "RECFM(V B) LRECL(4096) BLKSIZE(0)"
   vb4k.1    = "SHR"                   /* if it already exists...    */
   logdsn = "@@LOG."exec_name"."subid".#CILIST"

   call ZL_LOGMSG("Log started by" Userid()  yyyymmdd  hhmmss)
   call ZL_LOGMSG("Arg:" argline)

return                                 /*@ AL_SETUP_LOG              */
/*
.  ----------------------------------------------------------------- */
AP_KEYWDS:                             /*@                           */
   if branch then call BRANCH
   address TSO

   sw.0KeepList = SWITCH("SAVE")

return                                 /*@ AP_KEYWDS                 */
/*
.  ----------------------------------------------------------------- */
C_TABLE_OPS:                           /*@                           */
   if branch then call BRANCH
   address ISPEXEC

   call C0_PROLOG                      /*                           -*/
   call CA_HLIST                       /*                           -*/
                                    if \sw.0halt_process then,
   call CB_LOAD_TABLE                  /*                           -*/
                                    if \sw.0halt_process then,
   call CD_DISPLAY                     /*                           -*/
   call CZ_EPILOG                      /*                           -*/

return                                 /*@ C_TABLE_OPS               */
/*
.  ----------------------------------------------------------------- */
C0_PROLOG:                             /*@                           */
   if branch then call BRANCH
   address ISPEXEC

   call DEIMBED                        /*                           -*/
   call C0A_SETUP_LIBDEFS              /*                           -*/

return                                 /*@ C0_PROLOG                 */
/*
   Attach the extracted ISPF material
.  ----------------------------------------------------------------- */
C0A_SETUP_LIBDEFS:                     /*@                           */
   if branch then call BRANCH
   address ISPEXEC

   dd = ""
   do Words(ddnlist)                   /* each LIBDEF DD             */
      parse value ddnlist dd  with  dd ddnlist
      $ddn   = $ddn.dd                 /* PLIB322 <- PLIB            */
      "LIBDEF  ISP"dd "LIBRARY  ID("$ddn") STACK"
   end
   ddnlist = ddnlist dd

return                                 /*@ C0A_SETUP_LIBDEFS         */
/*
   HLIST the requested datasets
.  ----------------------------------------------------------------- */
CA_HLIST:                              /*@                           */
   if branch then call BRANCH
   address TSO

   if dslevel = ""  then do
      call ZL_LOGMSG("No input parm.")
      call CAG_GET_PARMS               /*                           -*/
      end
                                    if sw.0halt_process then return
   call ZL_LOGMSG("Using" dslevel)
   call CAM_PROGRESS_MSG               /*                           -*/

   parse value odsn "TEMP.SYSPRINT"   with   odsn  .

   "HLIST LEVEL("dslevel") BOTH ODS("odsn")"

return                                 /*@ CA_HLIST                  */
/*
   Caller didn't pass a parm.  Get the catalog level to be HLISTed
.  ----------------------------------------------------------------- */
CAG_GET_PARMS:                         /*@                           */
   if branch then call BRANCH
   address ISPEXEC

   "DISPLAY PANEL(HLPARM)"
   sw.0halt_process = rc > 0

return                                 /*@ CAG_GET_PARMS             */
/*
.  ----------------------------------------------------------------- */
CAM_PROGRESS_MSG:                      /*@                           */
   if branch then call BRANCH
   address ISPEXEC

   "CONTROL DISPLAY LOCK"
   parse value "" with pop1 pop2 pop3 pop4
   pop2 = "    Obtaining HSM data."
   "ADDPOP ROW(12) COLUMN(3)"
   "DISPLAY PANEL(POP40BY4)"
   "REMPOP ALL"

return                                 /*@ CAM_PROGRESS_MSG          */
/*
   Create the table and load the HLIST data to it.
.  ----------------------------------------------------------------- */
CB_LOAD_TABLE:                         /*@                           */
   if branch then call BRANCH
   address ISPEXEC

   "TBCREATE  HSML  KEYS(DSNAME GEN) NAMES(TYPEMORB BACKDT BACKTM VER)",
            "NOWRITE REPLACE"

   address TSO "NEWSTACK"
   call CBQ_LOAD_QUEUE                 /* HLIST output to queue     -*/

   "CONTROL DISPLAY LOCK"
   pop3 = "    Loading temporary table"
   "ADDPOP ROW(12) COLUMN(3)"
   "DISPLAY PANEL(POP40BY4)"
   "REMPOP ALL"

   typemorb = "M"                      /* migrated                   */
   do queued()
      pull 2 line
      if Pos("BACKUP DATASET-",line) > 0 then leave
      if Pos("LAST REF MIGRAT",line) > 0 then sw.0ready = "1"
      if Pos("MIGRATED"       ,line) > 0 then iterate
      if Pos("CONTROL DATASET",line) > 0 then iterate
      if \sw.0ready then iterate
      if Left(line,12) = "" then iterate

      /* process this line ------------------------                  */
      parse var line dsname vol refdt backdt .
      "TBADD  HSML"
      call ZL_LOGMSG("M" Left(dsname,44) vol refdt backdt)
   end                                 /* queued                     */

   typemorb = "B"                      /* backed-up                  */
   dsname = ""
   do queued()
      pull 2 line
      if Word(line,1) = "DSNAME" then do
         parse var line . . dsname .
         iterate ;   end
      if dsname = "" then iterate
      if Pos("BACKUP VERSION ",line) > 0 then iterate
      if Pos("VOLUME  VOLUME ",line) > 0 then iterate
      if line = "" then,               /* empty line                 */
         if gen = "" then iterate      /* skip                       */
      else do
         parse value "" with gen dsname
         iterate ; end
      /* process this line ------------------------                  */
      parse var line 67 backdt . 77 backtm . 92 gen . 98 ver .
      "TBADD  HSML"
      call ZL_LOGMSG("B" Left(dsname,44) gen ver backdt backtm)
   end                                 /* queued                     */
   "TBSORT  HSML  FIELDS(DSNAME,C,A,GEN,N,D)"

   address TSO "DELSTACK"

return                                 /*@ CB_LOAD_TABLE             */
/*
.  ----------------------------------------------------------------- */
CBQ_LOAD_QUEUE:                        /*@                           */
   if branch then call BRANCH
   address TSO

   "ALLOC FI($TMP) DA("odsn") SHR REU"
   "EXECIO * DISKR $TMP (FINIS"
   "FREE  FI($TMP)"

   call ZL_LOGMSG(queued() "lines on SYSPRINT")
   if sw.0KeepList then return         /* don't delete the data      */

   $z = Msg("OFF")
   "DELETE TEMP.SYSPRINT"
   $z = Msg($z)

return                                 /*@ CBQ_LOAD_QUEUE            */
/*
   Show the list of datasets and let the caller select datasets for
   HRECALL, HRECOVER, HDELETE, or HBDELETE.
.  ----------------------------------------------------------------- */
CD_DISPLAY:                            /*@                           */
   if branch then call BRANCH
   address ISPEXEC

   $tn$  = "HSML"
   do forever
      "TBDISPL" $tn$ "PANEL(HLDETL)"
      if rc > 4 then leave             /* PF3 ?                      */

      if zcmd ^= "" then do
         "CONTROL DISPLAY SAVE"
         call CDP_PROCESS_CMD
         "CONTROL DISPLAY RESTORE"
         iterate
         end

      do ztdsels
         select
            when action = "D" then do  /* Delete                     */
               call CDD_HDELETE        /*                           -*/
               end
            when action = "R" then do  /* Recall/Recover             */
               call CDR_RECALL         /*                           -*/
               end
            otherwise nop
         end                           /* Select                     */

         if verb = "" then iterate     /* no action requested        */

         Parse value req.0+1 verb           with,
                     $z$     req.$z$     1  req.0  .
         call ZL_LOGMSG(verb)          /* Log the action             */

         if ztdsels = 1 then,          /* never do the last one      */
            ztdsels = 0
         else "TBDISPL" $tn$           /* next row                   */
      end                              /* ztdsels                    */
      action = ''                      /* clear for re-display       */
   end                                 /* forever                    */

return                                 /*@ CD_DISPLAY                */
/*
   Format the command which will be issued to HSM.
.  ----------------------------------------------------------------- */
CDD_HDELETE:                           /*@                           */
   if branch then call BRANCH
   address ISPEXEC

   if typemorb = "B" then verb = "HBDELETE '"dsname"' VERSIONS("ver")"
                     else verb = "HDELETE  '"dsname"'"
   "TBDELETE" $tn$                     /* zap the row                */

return                                 /*@ CDD_HDELETE               */
/*
.  ----------------------------------------------------------------- */
CDP_PROCESS_CMD:                       /*@                           */
   if branch then call BRANCH
   address ISPEXEC

   parse var zcmd  cmdverb cmdtext     /*                            */
   select
      when cmdverb = "RECAP" then do   /*                            */
         call CDPR_RECAP               /*                           -*/
         end                           /* RECAP                      */
      otherwise nop
   end                                 /* select                     */

return                                 /*@ CDP_PROCESS_CMD           */
/*
.  ----------------------------------------------------------------- */
CDPR_RECAP:                            /*@                           */
   if branch then call BRANCH
   address ISPEXEC

   "TBCREATE  HSCMDS  NAMES(HSCMD) NOWRITE REPLACE"
   do cz = 1 to req.0
      hscmd = req.cz
      "TBADD  HSCMDS"
   end                                 /* cz                         */

   "TBTOP  HSCMDS"
   do forever
      "TBDISPL  HSCMDS  PANEL(HLRECAP)"
       if rc > 4 then leave

      do ztdsels
         "CONTROL DISPLAY SAVE"

         select

            when sel = "D" then "TBDELETE HSCMDS"

            otherwise nop

         end                           /* select                     */

         "CONTROL DISPLAY RESTORE"

         if ztdsels > 1 then "TBDISPL  HSCMDS"

      end                              /* ztdsels                    */

      sel = ""

   end                                 /* forever                    */

   "TBTOP  HSCMDS"
   req.0 = 0
   do forever
      "TBSKIP  HSCMDS"
      if rc > 0 then leave
      parse value req.0+1 hscmd  with ,
                  $z$     req.$z$    1   req.0   .
   end                                 /* forever                    */

   "TBEND    HSCMDS"

return                                 /*@ CDPR_RECAP                */
/*
   HRecover or HRecall the dataset.  If it is in "backed-up" status,
   HRECOVER; if migrated, HRECALL.
.  ----------------------------------------------------------------- */
CDR_RECALL:                            /*@                           */
   if branch then call BRANCH
   address TSO

   if typemorb = "B" then verb = CDRA_NEW_OR_REP()
                     else verb = "HRECALL  '"dsname"'"

return                                 /*@ CDR_RECALL                */
/*
   HRECOVER this dataset, but first... does it already exist?  If so,
   ask the caller whether to replace the existing copy or give it a
   new name.
.  ----------------------------------------------------------------- */
CDRA_NEW_OR_REP:                       /*@                           */
   if branch then call BRANCH
   address ISPEXEC

   badcodes = "0001 0005 0008 0017 0019 0020 0021 0023 0027 0028",
              "0029 0030 0031 0032 0033 0034 0035 0036"
   verb = ""
   ldrc = LISTDSI("'"dsname"' NORECALL")
   if Wordpos(sysreason,badcodes) > 0 then do
      verb = "HRECOVER '"dsname"' VERSION("ver") REPLACE"
      return(verb)
      end

   "DISPLAY PANEL(HLVERF)"             /* sets REPLACE or NEWDSN     */
   if rc > 0 then return(verb)         /* PF 3 ?                     */

   if newdsn <> "" then,
      verb = "HRECOVER '"dsname"' VERSION("ver") NEWNAME('"newdsn"')"
                   else,
   if repl   <> "" then,
      verb = "HRECOVER '"dsname"' VERSION("ver") REPLACE"

return(verb)                           /*@ CDRA_NEW_OR_REP           */
/*
   Disconnect the ISPF material and FREE the files.
.  ----------------------------------------------------------------- */
CZ_EPILOG:                             /*@                           */
   if branch then call BRANCH
   address ISPEXEC

   dd = ""
   do Words(ddnlist)                   /* each LIBDEF DD             */
      parse value ddnlist dd  with  dd ddnlist
      $ddn   = $ddn.dd                 /* PLIB322 <- PLIB            */
      "LIBDEF  ISP"dd
      address TSO "FREE  FI("$ddn")"
   end
   ddnlist = ddnlist dd

return                                 /*@ CZ_EPILOG                 */
/*
   Issue all the commands collected for the actions requested.
.  ----------------------------------------------------------------- */
D_HSM_OPS:                             /*@                           */
   if branch then call BRANCH
   address TSO

   do dx = 1 to req.0                  /* every request              */
      parse var req.dx verb
      (verb)                           /* execute the command        */
   end                                 /* dx                         */

return                                 /*@ D_HSM_OPS                 */
/*
.  ----------------------------------------------------------------- */
LOCAL_PREINIT:                         /*@ customize opts            */
   address TSO


return                                 /*@ LOCAL_PREINIT             */
/*   subroutines below LOCAL_PREINIT are not selected by SHOWFLOW    */
/*
   Parse out the embedded components at the back of the source code.
.  ----------------------------------------------------------------- */
DEIMBED: Procedure expose,             /*@                           */
   (tk_globalvars)  ddnlist  $ddn.  daid.

   address TSO

   address ISPEXEC "VGET ZSCREENW"
   fb80po.0  = "NEW UNIT(VIO) SPACE(5 5) TRACKS DIR(40)",
                   "RECFM(F B) LRECL("zscreenw") BLKSIZE(0)"
   parse value ""   with  ddnlist $ddn.  daid.

   lastln   = sourceline()
   currln   = lastln                   /*                            */
   if Left(sourceline(currln),2) <> "*/" then return

   currln = currln - 1                 /* previous line              */
   "NEWSTACK"
   address ISPEXEC
   do while sourceline(currln) <> "/*"
      text = sourceline(currln)        /* save with a short name !   */
      if Left(text,3) = ")))" then do  /* package the queue          */
         parse var text ")))" ddn mbr .   /* PLIB PANL001  maybe     */
         if Pos(ddn,ddnlist) = 0 then do  /* doesn't exist           */
            ddnlist = ddnlist ddn      /* keep track                 */
            $ddn = ddn || Random(999)
            $ddn.ddn = $ddn
            address TSO "ALLOC FI("$ddn")" fb80po.0
            "LMINIT DATAID(DAID) DDNAME("$ddn")"
            daid.ddn = daid
            end
         daid = daid.ddn
         "LMOPEN DATAID("daid") OPTION(OUTPUT)"
         do queued()
            parse pull line
            "LMPUT DATAID("daid") MODE(INVAR) DATALOC(LINE)" ,
                      "DATALEN("zscreenw")"
         end
         "LMMADD DATAID("daid") MEMBER("mbr")"
         "LMCLOSE DATAID("daid")"
         end                           /* package the queue          */
      else push text                   /* onto the top of the stack  */
      currln = currln - 1              /* previous line              */
   end                                 /* while                      */
   address TSO "DELSTACK"

return                                 /*@ DEIMBED                   */
/*
.  ----------------------------------------------------------------- */
ZB_SAVELOG:                            /*@                           */
   if branch then call BRANCH
   address TSO

   if Symbol("LOG#") = "LIT" then return          /* not yet set     */

   "ALLOC FI($LOG) DA("logdsn") REU" vb4k.0
   "EXECIO" log# "DISKW $LOG (STEM LOG. FINIS"
   "FREE  FI($LOG)"

return                                 /*@ ZB_SAVELOG                */
/*
.  ----------------------------------------------------------------- */
ZL_LOGMSG: Procedure expose,           /*@                           */
   (tk_globalvars)  log. log#
   rc = Trace("O")
   address TSO

   parse arg msgtext
   parse value  log#+1  msgtext     with,
                zz      log.zz    1  log#   .

   if monitor then say,
      msgtext

return                                 /*@ ZL_LOGMSG                 */
/*
.  ----------------------------------------------------------------- */
HELP:                                  /*@                           */
address TSO;"CLEAR"
if helpmsg <> "" then do ; say helpmsg; say ""; end
ex_nam = Left(exec_name,8)             /* predictable size           */

say "  "ex_nam"      eases the burden of manipulating backed-up and migrated   "
say "                versions of datasets.  It produces a scrollable list of   "
say "                the datasets for the specified <dslevel> and allows the   "
say "                caller to delete, recall, and recover datasets.  For any  "
say "                shown dataset, entering a 'D' next to the dataset name    "
say "                causes that backed-up or migrated dataset to be deleted.  "
say "                Any other character will cause the dataset to be recovered"
say "                or recalled as appropriate.                               "
say "                                                                          "
say "  Syntax:   "ex_nam"  <dslevel>                                           "
say "                ((    <SAVE>                                              "
say "                                                                          "
say "            <dslevel> identifies the catalog level for which an HLIST is  "
say "                      to be done.  The datasets referenced will be used to"
say "                      populate the display.                               "
say "                                                                          "
say "            <SAVE>    orders that the output from HLIST is to be kept     "
say "                      rather than deleted.                                "
say "                                                                          "
"NEWSTACK"; pull ; "CLEAR" ; "DELSTACK"
say "   Debugging tools provided include:                                      "
say "                                                                          "
say "        MONITOR:  displays key information throughout processing.         "
say "                                                                          "
say "        NOUPDT:   by-pass all update logic.                               "
say "                                                                          "
say "        BRANCH:   show all paragraph entries.                             "
say "                                                                          "
say "        TRACE tv: will use value following TRACE to place the             "
say "                  execution in REXX TRACE Mode.                           "
say "                                                                          "
say "                                                                          "
say "   Debugging tools can be accessed in the following manner:               "
say "                                                                          "
say "        TSO "ex_nam"  parameters     ((  debug-options                    "
say "                                                                          "
say "   For example:                                                           "
say "                                                                          "
say "        TSO "ex_nam"  (( MONITOR TRACE ?R                                 "

address ISPEXEC "CONTROL DISPLAY REFRESH"
exit                                   /*@ HELP                      */
/* 			REXXSKEL back-end removed for space 					*/
/*
)))PLIB HLPARM
)ATTR
  % TYPE(TEXT)   INTENS(HIGH) SKIP(ON)
  + TYPE(TEXT)   INTENS(LOW) SKIP(ON)
  _ TYPE(INPUT)  INTENS(LOW)
  @ TYPE(TEXT)   INTENS(HIGH) COLOR(YELLOW)
  ! TYPE(INPUT)  INTENS(NON)
)BODY EXPAND(¬∫¬∫) WIDTH(&ZSCREENW)
@¬∫-¬∫% Verify Parameters for HLIST @¬∫-¬∫
%COMMAND ===>_ZCMD
                                                             %SCROLL ===>_ZAMT+
+
         Catalog Level ===>_dslevel
+
)INIT
  .HELP = HLPARMH
)PROC
   VER (&DSLEVEL,NB,DSNAME)
)END
)))PLIB HLPARMH
)ATTR
  % TYPE(TEXT)   INTENS(HIGH)  SKIP(ON)
  + TYPE(TEXT)   INTENS(LOW)   SKIP(ON)
  _ TYPE(INPUT)  INTENS(HIGH)
  ! TYPE(OUTPUT) INTENS(HIGH)  SKIP(ON)
  @ TYPE(OUTPUT) INTENS(LOW)   SKIP(ON)
)BODY EXPAND(¬∫¬∫) WIDTH(&ZSCREENW)
%TUTORIAL ¬∫-¬∫ Verify Parameters for HLIST ¬∫-¬∫ TUTORIAL
%Next Selection ===>_ZCMD

+
    Specify the high-level qualifiers you wish to have displayed.  The
    specification should be unquoted.

    The more precise this specification, the shorter will be the list,
    and the quicker the display will be ready.  Example:

         Catalog Level ===> ntin.ts.d822.lib

)PROC
)END
)))PLIB HLDETL
)ATTR
  % TYPE(TEXT)   INTENS(HIGH) SKIP(ON)
  + TYPE(TEXT)   INTENS(LOW)  SKIP(ON)
  _ TYPE(INPUT)  INTENS(HIGH) CAPS(ON)
  ! TYPE(OUTPUT) INTENS(HIGH) SKIP(ON)
  @ TYPE(OUTPUT) INTENS(LOW)  SKIP(ON)
)BODY EXPAND(¬∫¬∫) WIDTH(&ZSCREENW)
%¬∫-¬∫ Available Migrated/Backed-up Datasets +¬∫-¬∫
%Command ===>_ZCMD
                                                             %Scroll ===>_ZAMT+
+              (See HELP-text for more information)          Back-Up
+V Gen M/B Dataset Name (Base)                             Date     Time
)MODEL
_z!gen+!z+!dsname                                        !backdt  !backtm
)INIT
  .ZVARS = '(ACTION TYPEMORB)'
  .HELP = HLDETLH
)REINIT
)PROC
)END
)))PLIB HLDETLH
)ATTR
  % TYPE(TEXT)   INTENS(HIGH)  SKIP(ON)
  + TYPE(TEXT)   INTENS(LOW)   SKIP(ON)
  _ TYPE(INPUT)  INTENS(HIGH)
  ! TYPE(OUTPUT) INTENS(HIGH)  SKIP(ON)
  @ TYPE(OUTPUT) INTENS(LOW)   SKIP(ON)
)BODY EXPAND(¬∫¬∫) WIDTH(&ZSCREENW)
%TUTORIAL ¬∫-¬∫ Available Migrated/Backed-up Datasets ....  ¬∫-¬∫ TUTORIAL
%Next Selection ===>_ZCMD

+
    The datasets available for HRECALL, HRECOVER, HDELETE, and HBDELETE are
    shown in a scrollable list.

    You may enter%D+next to any line to cause the shown dataset to be%HDELETEd+
    or%HBDELETEd+as appropriate.

    You may enter%R+next to any line to cause the shown dataset to be%HRECALLed+
    or%HRECOVERed+as appropriate.

    At any time you may get a list of the commands queued for execution by
    typing%RECAP+on the command line.

)PROC
)END
)))PLIB HLVERF
)ATTR
  % TYPE(TEXT)   INTENS(HIGH) SKIP(ON)
  + TYPE(TEXT)   INTENS(LOW) SKIP(ON)
  _ TYPE(INPUT)  INTENS(LOW) CAPS(ON)
  @ TYPE(TEXT)   INTENS(HIGH) COLOR(YELLOW)
  { TYPE(OUTPUT) INTENS(HIGH) COLOR(YELLOW)
)BODY EXPAND(¬∫¬∫) WIDTH(&ZSCREENW)
@¬∫-¬∫% HRECOVER Options @¬∫-¬∫
%COMMAND ===>_ZCMD
                                                             %SCROLL ===>_ZAMT+
+
+  Dataset{dsname
+  exists.  Specify a new dataset name for the HRECOVER operation,
+  or indicate REPLACE below.
+
+  New DSN ===>_newdsn
+              (Fully-qualified unquoted)
+
+
+  REPLACE ===>_Z+
+
)INIT
   .ZVARS = '(REPL)'
   &NEWDSN = &Z
   &REPL = &Z
)PROC
   IF (VER(&NEWDSN,DSNAME))
   ELSE
      &ZERRHM = 'ISR00000'
      &ZERRSM = 'NEWDSN invalid'
      &ZERRLM = 'NEWDSN must be a valid DSNAME.'
      &ZERRALRM = 'YES'
      .MSG = ISRZ002
      EXIT

   IF (&REPL EQ &Z)
      IF (&NEWDSN EQ &Z)
         &ZERRHM = 'ISR00000'
         &ZERRSM = 'Nothing selected'
         &ZERRLM = 'One and only one field may be filled.  When REPLACE +
                    is empty, NEW DSN may not be blank.'
         &ZERRALRM = 'YES'
         .MSG = ISRZ002
   ELSE
      IF (&NEWDSN NE &Z)
         &ZERRHM = 'ISR00000'
         &ZERRSM = 'Too much data'
         &ZERRLM = 'One and only one field may be filled.  When REPLACE +
                    is used, NEW DSN must be blank.'
         &ZERRALRM = 'YES'
         .MSG = ISRZ002
)END
)))PLIB HLRECAP
)ATTR
  % TYPE(TEXT)   INTENS(HIGH) SKIP(ON)
  + TYPE(TEXT)   INTENS(LOW)  SKIP(ON)
  _ TYPE(INPUT)  INTENS(HIGH) CAPS(ON)
  ! TYPE(OUTPUT) INTENS(HIGH) SKIP(ON)
  @ TYPE(OUTPUT) INTENS(LOW)  SKIP(ON)
)BODY EXPAND(¬∫¬∫) WIDTH(&ZSCREENW)
%¬∫-¬∫ HSMLIST Commands in storage +¬∫-¬∫
%Command ===>_ZCMD
                                                             %Scroll ===>_ZAMT+
+  /------- %D+to drop this HSM command
+ /
+V Command
)MODEL
_z!hscmd
)INIT
  .ZVARS = '(SEL)'
  .HELP = HLDETLH
)REINIT
)PROC
)END
)))PLIB POP40BY4
)ATTR
    %  TYPE(TEXT)   INTENS(HIGH)   SKIP(ON)
)BODY WINDOW(40,4)
+&pop1
+&pop2
+&pop3
+&pop4
)INIT
)PROC
)END
*/

./ ADD NAME=IDI
/* rexx */
trace all
/*IBM Fault Analyzer for zOS User's Guide and Reference Version 14 */
ADDRESS TSO
"ALTLIB ACT APPLICATION(CLIST) DA('IDI.SIDIEXEC')"
addRESS ISPEXEC
"LIBDEF ISPMLIB DATASET ID('IDI.SIDIMLIB')"
"LIBDEF ISPPLIB DATASET ID('IDI.SIDIPLIB')"
"LIBDEF ISPSLIB DATASET ID('IDI.SIDISLIB')"
"LIBDEF ISPTLIB DATASET ID('IDI.SIDITLIB')"
"SELECT CMD(IDISFA) NEWAPPL(IDI) PASSLIB"
ISPEXEC LIBDEF ISPPLIB /* free plib */
ISPEXEC LIBDEF ISPMLIB /* free mlib */
ISPEXEC LIBDEF ISPSLIB /* free slib */
ISPEXEC LIBDEF ISPTLIB /* free tlib */
ADDRESS TSO
"ALTLIB DEA APPLICATION(CLIST)" /* deactivate clist library */
"END"

./ ADD NAME=IDI$
/* rexx */
/*IBM Fault Analyzer for zOS User's Guide and Reference Version 14 */
ADDRESS TSO
"ALTLIB ACT APPLICATION(CLIST) DA('IDI.SIDIEXEC')"
addRESS ISPEXEC
"LIBDEF ISPMLIB DATASET ID('IDI.SIDIMLIB')"
"LIBDEF ISPPLIB DATASET ID('IDI.SIDIPLIB')"
"LIBDEF ISPSLIB DATASET ID('IDI.SIDISLIB')"
"LIBDEF ISPTLIB DATASET ID('IDI.SIDITLIB')"
"SELECT CMD(IDISFA) NEWAPPL(IDI) PASSLIB STE58.OSEO.LOAD"
ISPEXEC LIBDEF ISPPLIB /* free plib */
ISPEXEC LIBDEF ISPMLIB /* free mlib */
ISPEXEC LIBDEF ISPSLIB /* free slib */
ISPEXEC LIBDEF ISPTLIB /* free tlib */
ADDRESS TSO
"ALTLIB DEA APPLICATION(CLIST)" /* deactivate clist library */
"END"

./ ADD NAME=IKJADHEL
*****START OF SPECIFICATIONS******************************************* 00050000
* *01* PROPRIETARY STATEMENT=                                         * 00100000
*  **PROPRIETARY_STATEMENT********************************************* 00150000
*                                                                     * 00200000
*                                                                     * 00250000
*   LICENSED MATERIALS - PROPERTY OF IBM                              * 00300000
*   THIS MACRO IS "RESTRICTED MATERIALS OF IBM"                       * 00350000
*   5685-025 (C) COPYRIGHT IBM CORP. 1988, 1992                       * 00400000
*   SEE COPYRIGHT INSTRUCTIONS                                        * 00450000
*                                                                     * 00500000
*   STATUS= HTE24D2                                                   * 00550000
*                                                                     * 00600000
*  **END_OF_PROPRIETARY_STATEMENT************************************** 00650000
* CHANGE ACTIVITY =                                                   * 00700000
*                                                                     * 00750000
*    Created for TSO/E 2.1.0                                 ‡E21D2JC * 00800000
*                                                                     * 00850000
*    PTM PEI0869 - Update to include LRECL in help message.  ‡PEI0869 * 00900000
*                                                                     * 00950000
*    PTM PEI0979 - Update help text to reflect REXX EXECs.   ‡PEI0979 * 01000000
*        OY28059 - Added help text for IKJ79341I, IKJ79342I. ‡YA28059 * 01050000
*        DID0010 - Updated help text for IKJ79339I, IKJ79340I         * 01100000
*                  and IKJ79338I                             ‡DID0010 * 01150000
*        OY50210 - Correct syntax diagram so that EXEC, CLIST, and    * 01200000
*                  * all line up:                                     * 01250000
*                       ALTLIB ACTIVATE SYSTEM(EXEC)                  * 01300000
*                                             (CLIST)                 * 01350000
*                                             (*)                     * 01400000
*                                                                     * 01450000
*                              DEACTIVATE USER(EXEC)                  * 01500000
*                                             (CLIST)                 * 01550000
*                                             (*)            ‡YA50210 * 01600000
*    PTM PMH0005 - Correctly align the help text.            ‡PMH0005 * 01650000
*                  This is APAR OY50210                               * 01700000
*****END OF SPECIFICATIONS********************************************* 01750000
)F Function:                                                            01800000
  Lets the TSO/E user define optional, user-level or application-level  01850000
  sets of libraries containing REXX EXECs or CLISTs.  These libraries   01900000
  are searched before the system-level REXX EXECs and CLISTs.           01950000
                                                                        02000000
  This capability eliminates the need for all application-level REXX    02050000
  EXECs and CLISTs to be contained in either the user's LOGON procedure 02100000
  or allocated to the appropriate DDNAME before executing REXX EXECs    02150000
  or CLISTs implicitly.                                                 02200000
                                                                        02250000
)X Syntax:                                                              02300000
  ALTLIB-.-ACTIVATE  -QUIET-.-USER(EXEC)                                02350000
         !            blank !     (CLIST)                               02400000
         !                  !     (*)                                   02450000
         !                  !-APPLICATION(EXEC)                         02500000
         !                  !   !        (CLIST)                        02550000
         !                  !   !                                       02600000
         !                  !   '--.-DATASET(dslist)-.-UNCOND           02650000
         !                  !      !-DSNAME(dslist)  '-COND             02700000
         !                  !      !-FILE(ddname)                       02750000
         !                  !      !-DDNAME(ddname)                     02800000
         !                  !      '-LIBRARY(ddname)                    02850000
         !                  !                                           02900000
         !                  '-SYSTEM(EXEC)                              02950000
         !                          (CLIST)                             03000000
         !                          (*)                                 03050000
         !-DEACTIVATE-QUIET-.-USER(EXEC)                                03100000
         !            blank !     (CLIST)                               03150000
         !                  !     (*)                                   03200000
         !                  !-APPLICATION(EXEC)                         03250000
         !                  !            (CLIST)                        03300000
         !                  !            (*)                            03350000
         !                  !-SYSTEM(EXEC)                              03400000
         !                  !       (CLIST)                             03450000
         !                  !       (*)                                 03500000
         !                  '-ALL                                       03550000
         !-RESET     -QUIET                                             03600000
         !            blank                                             03650000
         '-DISPLAY   -QUIET                                             03700000
                      blank                                             03750000
                                                                        03800000
Defaults:                                                               03850000
                                                                        03900000
            1.  APPLICATION when USER, APPLICATION, or SYSTEM is not    03950000
                specified and required.                                 04000000
                                                                        04050000
            2.  DATASET when DATASET, DSNAME, FILE, DDNAME, or LIBRARY  04100000
                is not specified and required.                          04150000
                                                                        04200000
                Note that due to a PARSE restriction, only one data     04250000
                set can be specified if PARSE prompts - a list of data  04300000
                sets cannot be specified.                               04350000
                                                                        04400000
            3.  UNCOND when UNCOND or COND is not specified and         04450000
                required.                                               04500000
                                                                        04550000
Return Codes:                                                           04600000
                                                                        04650000
            0 - Normal completion, but messages may be issued.  For     04700000
                example:                                                04750000
                                                                        04800000
                    IKJ79320I Unable to free previously allocated       04850000
                    DATASETS.  ENTER ? FOR MORE INFORMATION.            04900000
                                                                        04950000
            4 - An alternative library does not exist for this type     05000000
                (when deactivating an alternative library)              05050000
                                                                        05100000
            8 - Application library already exists for this type (when  05150000
                COND is used)                                           05200000
                                                                        05250000
           10 - User-level or system-level CLIST activated; user-level  05300000
                or system-level EXEC cannot be activated.  This return  05350000
                code is issued when you request that either both        05400000
                user levels or both system levels be activated, but     05450000
                an EXEC environment does not exist.                     05500000
                                                                        05550000
           16 - A required DDNAME was not previously allocated.  For    05600000
                example:                                                05650000
                                                                        05700000
                    The user specifies "ALTLIB ACTIVATE USER(CLIST)"    05750000
                    and DDNAME SYSUPROC is not currently allocated.     05800000
                                                                        05850000
                    The user specifies "ALTLIB ACTIVATE                 05900000
                    APPLICATION(EXEC) FILE(XXX)" and DDNAME XXX         05950000
                    is not currently allocated.                         06000000
                                                                        06050000
                    The user specifies "ALTLIB ACTIVATE                 06100000
                    SYSTEM(CLIST)" and DDNAME SYSPROC is not            06150000
                    currently allocated.                                06200000
                                                                        06250000
           20 - Severe error. More information is contained in the      06300000
                messages.                                               06350000
                                                                        06400000
Notes:                                                                  06450000
                                                                        06500000
            1.  The application level can be stacked in a "last in      06550000
                first out" (LIFO) manner.                               06600000
                                                                        06650000
                For example:                                            06700000
                                                                        06750000
                    If the user activates an application level for      06800000
                    EXEC and then activates another application level   06850000
                    for EXEC unconditionally, ALTLIB makes the second   06900000
                    request current and stacks the first request        06950000
                    underneath.  When the user deactivates the          07000000
                    application level for EXEC, the second request is   07050000
                    removed and the first request becomes current.      07100000
                                                                        07150000
                    Up to eight EXEC requests and eight CLIST requests  07200000
                    can be stacked.                                     07250000
                                                                        07300000
                The following command invocations remove all DDNAMEs    07350000
                from the stacks:                                        07400000
                                                                        07450000
                o   ALTLIB DEACTIVATE APPLICATION(*)                    07500000
                o   ALTLIB DEACTIVATE ALL                               07550000
                o   ALTLIB RESET                                        07600000
                                                                        07650000
            2.  Just as REXX EXECs and CLISTs can be contained in       07700000
                the concatenation for DDNAME SYSPROC but only REXX      07750000
                EXECs can be contained in the concatenation for DDNAME  07800000
                SYSEXEC, so is the case for the user-level and          07850000
                application-level libraries.                            07900000
                                                                        07950000
                For example, if the application activates an            08000000
                application-level library with the following commands:  08050000
                                                                        08100000
                ALTLIB ACTIVATE APPLICATION(EXEC)  DA(DS1 DS2 DS3)      08150000
                ALTLIB ACTIVATE APPLICATION(CLIST) DA(DSA DSB DSC)      08200000
                                                                        08250000
                then data sets DS1, DS2, and DS3 must contain only      08300000
                REXX EXECs while data sets DSA, DSB, and DSC can        08350000
                contain REXX EXECs or CLISTs.                           08400000
                                                                        08450000
)M Messages:                                                            08500000
                                                                        08550000
))IKJ79301I ALTLIB terminated.  Insufficient virtual storage            08600000
            to satisfy request.+                                        08650000
                                                                        08700000
            EXPLANATION: The ALTLIB command processor needs to obtain   08750000
            more virtual storage than is currently available.           08800000
                                                                        08850000
            SYSTEM ACTION: The ALTLIB command processor considers       08900000
            this error to be serious and terminates.                    08950000
                                                                        09000000
            USER ACTION: If ISPF is currently active, try leaving at    09050000
            least one active application.  If this does not help or     09100000
            if ISPF is not currently active, logon with a larger        09150000
            region size.  For help, contact your TSO administrator.     09200000
                                                                        09250000
                                                                        09300000
))IKJ79307I ALTLIB terminated.  Extraneous information specified.+      09350000
                                                                        09400000
            EXPLANATION: You specified two or more operands on the      09450000
            ALTLIB command that conflict with one another.  This        09500000
            message is accompanied by one of the following messages     09550000
            describing what operands are in error.                      09600000
                                                                        09650000
            o    Specify a data set list or DDNAME only when            09700000
                 activating an application-level alternative library.   09750000
                                                                        09800000
            o    Specify the COND or UNCOND keywords only when          09850000
                 activating an application-level alternative library.   09900000
                                                                        09950000
            o    Specify USER, APPLICATION, SYSTEM, or ALL only when    10000000
                 activating or deactivating.                            10050000
                                                                        10100000
            SYSTEM ACTION: The ALTLIB command processor considers       10150000
            this error to be serious and terminates.                    10200000
                                                                        10250000
            USER ACTION: Check the operands entered to see which of     10300000
            the operands was in error.                                  10350000
                                                                        10400000
                                                                        10450000
))IKJ79308I ALTLIB terminated.  Exceeded maximum number of stacked      10500000
            application levels.+                                        10550000
                                                                        10600000
            EXPLANATION: You currently have eight application-level     10650000
            DDNAMEs stacked for the type of application you are         10700000
            activating.  No more than eight can be stacked.             10750000
                                                                        10800000
            SYSTEM ACTION: The ALTLIB command processor considers       10850000
            this error to be serious and terminates.                    10900000
                                                                        10950000
            USER ACTION: Issue the ALTLIB command with the DEACTIVATE   11000000
            operand for the specified type of application before        11050000
            trying to activate another of the same type.                11100000
                                                                        11150000
                                                                        11200000
))IKJ79309I ALTLIB terminated.  Member names are not allowed.+          11250000
                                                                        11300000
            EXPLANATION: You specified a member name in the list        11350000
            of data sets for the DATASET or DSNAME operand.  A          11400000
            member name is not allowed.                                 11450000
                                                                        11500000
            SYSTEM ACTION: The ALTLIB command processor considers       11550000
            this error to be serious and terminates.                    11600000
                                                                        11650000
            USER ACTION: Issue the ALTLIB command specifying only the   11700000
            names of partitioned data sets in the list of data set      11750000
            names.                                                      11800000
                                                                        11850000
                                                                        11900000
))IKJ79310I ALTLIB terminated.  Exceeded maximum number of data sets.+  11950000
                                                                        12000000
            EXPLANATION: You specified more than 15 data sets in the    12050000
            list of data sets for the DATASET or DSNAME operand.        12100000
                                                                        12150000
            SYSTEM ACTION: The ALTLIB command processor considers       12200000
            this error to be serious and terminates.                    12250000
                                                                        12300000
            USER ACTION: Issue the ALTLIB command specifying fewer      12350000
            data set names.                                             12400000
                                                                        12450000
                                                                        12500000
))IKJ79311I  ALTLIB terminated.  'ALL' operand is not valid with        12550000
             activate.+                                                 12600000
                                                                        12650000
            EXPLANATION: You specified the 'ALL' operand when           12700000
            activating an alternative library. This is not valid.       12750000
                                                                        12800000
            SYSTEM ACTION: The ALTLIB command processor considers       12850000
            this error to be serious and terminates.                    12900000
                                                                        12950000
            USER ACTION: To activate the user, application, and system  13000000
            levels, issue the ALTLIB command multiple times.            13050000
                                                                        13100000
                                                                        13150000
))IKJ79312I  ALTLIB terminated.  Incorrect use of '*' keyword.+         13200000
                                                                        13250000
            EXPLANATION: You specified an asterisk when activating an   13300000
            alternative library at the application level. This is not   13350000
            valid.                                                      13400000
                                                                        13450000
            SYSTEM ACTION: The ALTLIB command processor considers       13500000
            this error to be serious and terminates.                    13550000
                                                                        13600000
            USER ACTION: To activate both an application library for    13650000
            EXEC and for CLIST, issue the ALTLIB command two separate   13700000
            times.                                                      13750000
                                                                        13800000
                                                                        13850000
))IKJ79313I  ALTLIB terminated.  'value' is not valid for the           13900000
             (USER!APPLICATION!SYSTEM) OPERAND.+                        13950000
                                                                        14000000
            EXPLANATION: The value you specified for the named operand  14050000
            is not valid.  The only valid values are 'EXEC', 'CLIST',   14100000
            or '*'.                                                     14150000
                                                                        14200000
            SYSTEM ACTION: The ALTLIB command processor considers       14250000
            this error to be serious and terminates.                    14300000
                                                                        14350000
            USER ACTION: Specify one of the valid values:  'EXEC',      14400000
            'CLIST', or '*'.                                            14450000
                                                                        14500000
                                                                        14550000
))IKJ79314I ALTLIB terminated.  DDNAME 'ddname' not previously          14600000
            allocated.+                                                 14650000
                                                                        14700000
            EXPLANATION: The DDNAME you specified to act as the         14750000
            application level library is either only dynamically        14800000
            allocated or not allocated at all.                          14850000
                                                                        14900000
            SYSTEM ACTION: The ALTLIB command processor considers       14950000
            this error to be serious and terminates.                    15000000
                                                                        15050000
            USER ACTION: Before issuing the ALTLIB command, issue       15100000
            the ALLOCATE command specifying a list of data set and      15150000
            the same file name you specified for the ALTLIB command.    15200000
            Then, reissue the ALTLIB command.  This process ensures     15250000
            that the DDNAME is permanently allocated.  When you are     15300000
            ready to deactivate the DDNAME, you can also free the       15350000
            file name with the FREE command.                            15400000
                                                                        15450000
                                                                        15500000
))IKJ79315I ALTLIB terminated.  Application level                       15550000
            (EXEC!CLIST) library already active and COND                15600000
            keyword was specified.                                      15650000
                                                                        15700000
            EXPLANATION: Using the COND keyword, you specified that     15750000
            you only wanted the application-level library activated if  15800000
            there was not another library of the same type active.      15850000
            There is at least one library of the same type active.      15900000
                                                                        15950000
            SYSTEM ACTION: The ALTLIB command processor considers       16000000
            this error to be serious and terminates.                    16050000
                                                                        16100000
            USER ACTION: Issue the ALTLIB command with the DISPLAY      16150000
            operand and, from the messages that ALTLIB displays,        16200000
            decide if you need to activate another application-level    16250000
            library of the same type.                                   16300000
                                                                        16350000
                                                                        16400000
))IKJ79316I ALTLIB terminated.  DDNAME 'ddname' is allocated to         16450000
            the terminal.+                                              16500000
                                                                        16550000
            EXPLANATION: The DDNAME you specified to act as the         16600000
            application level library is allocated to the terminal.     16650000
            ALTLIB does not allow you to use the terminal as the        16700000
            device from which read an EXEC or CLIST.                    16750000
                                                                        16800000
            SYSTEM ACTION: The ALTLIB command processor considers       16850000
            this error to be serious and terminates.                    16900000
                                                                        16950000
            USER ACTION: Issue the ALLOCATE command specifying a list   17000000
            of data sets.                                               17050000
                                                                        17100000
                                                                        17150000
))IKJ79317I ALTLIB terminated.  Sever error occurred in IKJDAIR.+       17200000
                                                                        17250000
            EXPLANATION: The TSO/E program IKJDAIR encountered an       17300000
            error when attempting to check the allocation of a DDNAME.  17350000
            This message is accompanied by the following message:       17400000
                                                                        17450000
            o    IKJDAIR return code is return-code.                    17500000
                                                                        17550000
            SYSTEM ACTION: The ALTLIB command processor considers       17600000
            this error to be serious and terminates.                    17650000
                                                                        17700000
            USER ACTION: Reissue the ALTLIB command. If the problem     17750000
            recurs, contact your TSO administrator for assistance, or   17800000
            consult "TSO/E Programming Services" to interpret the       17850000
            return code.                                                17900000
                                                                        17950000
                                                                        18000000
))IKJ79319I ALTLIB terminated.  Severe error allocating data sets       18050000
            for the DATASET keyword.+                                   18100000
                                                                        18150000
            EXPLANATION: Dynamic allocation encountered an error        18200000
            when attempting to allocate a data set.                     18250000
                                                                        18300000
            SYSTEM ACTION: The ALTLIB command processor considers this  18350000
            error to be serious and terminates.                         18400000
                                                                        18450000
            This message is accompanied by further messages describing  18500000
            the reason why the ALTLIB command failed:                   18550000
                                                                        18600000
            o   <Message text provided by dynamic allocation regarding  18650000
                the SVC99 error>                                        18700000
                                                                        18750000
                USER ACTION: Check the specified data set to see if     18800000
                the cause of the error can be determined.               18850000
                                                                        18900000
            o   Dynamic allocation return code RETURN-CODE reason       18950000
                code REASON-CODE.                                       19000000
                                                                        19050000
                USER ACTION: Reissue the ALTLIB command. If the         19100000
                problem recurs, contact your TSO administrator for      19150000
                assistance, or consult "System Programming Library:     19200000
                System Macros and Facilities Volume 1" to interpret     19250000
                the return and reason codes.                            19300000
                                                                        19350000
            o   Data set DATA-SET-NAME is not a partitioned data set.   19400000
                                                                        19450000
                USER ACTION: A data set that is not partitioned         19500000
                is specified in the list of data sets.  Only            19550000
                partitioned data sets can be specified using the        19600000
                ALTLIB command.  Issue the ALTLIB command               19650000
                specifying only the names of partitioned data           19700000
                sets.                                                   19750000
                                                                        19800000
                                                                        19850000
))IKJ79320I Unable to free previously allocated data sets.  Enter       19900000
            ? for more information.+                                    19950000
                                                                        20000000
            EXPLANATION: Dynamic allocation encountered an error        20050000
            when attempting to unallocate a data set.                   20100000
                                                                        20150000
            SYSTEM ACTION: This is a warning. The ALTLIB command        20200000
            continues after issuing the message.                        20250000
                                                                        20300000
            This message is accompanied by further messages describing  20350000
            the reason why the ALTLIB command failed:                   20400000
                                                                        20450000
            o   <Message text provided by dynamic allocation regarding  20500000
                the SVC99 error>                                        20550000
                                                                        20600000
                USER ACTION: Check the specified data set to see if     20650000
                the cause of the error can be determined.               20700000
                                                                        20750000
            o   Dynamic allocation return code RETURN-CODE reason       20800000
                code REASON-CODE.                                       20850000
                                                                        20900000
                USER ACTION: Contact your TSO administrator for         20950000
                assistance, or consult "System Programming Library:     21000000
                System Macros and Facilities Volume 1" to interpret     21050000
                the return and reason codes.                            21100000
                                                                        21150000
                                                                        21200000
))IKJ79321I                Stacked DDNAME=xxxxxxxx                      21250000
                                                                        21300000
            EXPLANATION: You specified the ALTLIB command with the      21350000
            DISPLAY operand.  The ALTLIB command processor issues       21400000
            this message to show any DDNAMEs that are stacked for the   21450000
            given application-level.                                    21500000
                                                                        21550000
            SYSTEM ACTION: This is information only.                    21600000
                                                                        21650000
            USER ACTION: None.                                          21700000
                                                                        21750000
                                                                        21800000
))IKJ79322I Current search order (by DDNAME) is:                        21850000
                                                                        21900000
            EXPLANATION: You specified the ALTLIB command with the      21950000
            DISPLAY operand.  The ALTLIB command processor issues       22000000
            this message to show any DDNAMEs that are currently being   22050000
            searched.                                                   22100000
                                                                        22150000
            SYSTEM ACTION: This is information only.                    22200000
                                                                        22250000
            USER ACTION: None.                                          22300000
                                                                        22350000
                                                                        22400000
))IKJ79323I User-level EXEC        DDNAME=SYSUEXEC                      22450000
                                                                        22500000
            EXPLANATION: You specified the ALTLIB command with the      22550000
            DISPLAY operand.  The ALTLIB command processor issues       22600000
            this message to show that the user-level EXEC DDNAME        22650000
            is being searched.                                          22700000
                                                                        22750000
            SYSTEM ACTION: This is information only.                    22800000
                                                                        22850000
            USER ACTION: None.                                          22900000
                                                                        22950000
                                                                        23000000
))IKJ79324I User-level CLIST       DDNAME=SYSUPROC                      23050000
                                                                        23100000
            EXPLANATION: You specified the ALTLIB command with the      23150000
            DISPLAY operand.  The ALTLIB command processor issues       23200000
            this message to show that the user-level CLIST DDNAME       23250000
            is being searched.                                          23300000
                                                                        23350000
            SYSTEM ACTION: This is information only.                    23400000
                                                                        23450000
            USER ACTION: None.                                          23500000
                                                                        23550000
                                                                        23600000
))IKJ79325I   Application-level EXEC  DDNAME=xxxxxxxx                   23650000
                                                                        23700000
            EXPLANATION: You specified the ALTLIB command with the      23750000
            DISPLAY operand.  The ALTLIB command processor issues       23800000
            this message to show that the application-level EXEC        23850000
            DDNAME is being searched.                                   23900000
                                                                        23950000
            SYSTEM ACTION: This is information only.                    24000000
                                                                        24050000
            USER ACTION: None.                                          24100000
                                                                        24150000
                                                                        24200000
))IKJ79326I Application-level CLIST DDNAME=xxxxxxxx                     24250000
                                                                        24300000
            EXPLANATION: You specified the ALTLIB command with the      24350000
            DISPLAY operand.  The ALTLIB command processor issues       24400000
            this message to show that the application-level CLIST       24450000
            DDNAME is being searched.                                   24500000
                                                                        24550000
            SYSTEM ACTION: This is information only.                    24600000
                                                                        24650000
            USER ACTION: None.                                          24700000
                                                                        24750000
                                                                        24800000
))IKJ79327I   System-level EXEC       DDNAME=xxxxxxxx                   24850000
                                                                        24900000
            EXPLANATION: You specified the ALTLIB command with the      24950000
            DISPLAY operand.  The ALTLIB command processor issues       25000000
            this message to show that the system-level EXEC DDNAME is   25050000
            being searched.                                             25100000
                                                                        25150000
            SYSTEM ACTION: This is information only.                    25200000
                                                                        25250000
            USER ACTION: None.                                          25300000
                                                                        25350000
                                                                        25400000
))IKJ79328I System-level CLIST      DDNAME=xxxxxxxx                     25450000
                                                                        25500000
            EXPLANATION: You specified the ALTLIB command with the      25550000
            DISPLAY operand.  The ALTLIB command processor issues       25600000
            this message to show that the system-level CLIST DDNAME is  25650000
            being searched.                                             25700000
                                                                        25750000
            SYSTEM ACTION: This is information only.                    25800000
                                                                        25850000
            USER ACTION: None.                                          25900000
                                                                        25950000
                                                                        26000000
))IKJ79329I No levels are currently being searched.                     26050000
                                                                        26100000
            EXPLANATION: You specified the ALTLIB command with the      26150000
            DISPLAY operand or deactivated all levels of searching      26200000
            with the DEACTIVATE and ALL operands.  The ALTLIB command   26250000
            processor issues this message to show that no levels are    26300000
            currently being searched.                                   26350000
                                                                        26400000
            SYSTEM ACTION: This is information only.                    26450000
                                                                        26500000
            USER ACTION: Use the ACTIVATE operand to activate           26550000
            one or more levels or searching.                            26600000
                                                                        26650000
                                                                        26700000
))IKJ79330I ALTLIB terminated.  Unable to establish an alternative      26750000
            library environment.+                                       26800000
                                                                        26850000
            EXPLANATION: The TSO/E program IKJADTAB encountered an      26900000
            error when attempting to establish an alternative           26950000
            library environment.  This message is accompanied           27000000
            by the following message:                                   27050000
                                                                        27100000
            o    IKJADTAB return code RETURN-CODE.                      27150000
                                                                        27200000
            SYSTEM ACTION: The ALTLIB command processor considers       27250000
            this error to be serious and terminates.                    27300000
                                                                        27350000
            USER ACTION: Reissue the ALTLIB command. If the problem     27400000
            recurs, contact your TSO administrator for assistance, or   27450000
            consult "TSO/E Programming Services" to interpret the       27500000
            return code.                                                27550000
                                                                        27600000
                                                                        27650000
))IKJ79332I ALTLIB terminated.  Unable to establish recovery            27700000
            environment.+                                               27750000
                                                                        27800000
            EXPLANATION: The ALTLIB command processor could not         27850000
            establish recovery.  This message is accompanied            27900000
            by the following message:                                   27950000
                                                                        28000000
            o    ESTAE macro return code RETURN-CODE.                   28050000
                                                                        28100000
            SYSTEM ACTION: The ALTLIB command processor considers       28150000
            this error to be serious and terminates.                    28200000
                                                                        28250000
            USER ACTION: Reissue the ALTLIB command. If the             28300000
            problem recurs, contact your TSO administrator for          28350000
            assistance.                                                 28400000
                                                                        28450000
                                                                        28500000
))IKJ79333I IKJADTAB terminated.  Unable to establish recovery          28550000
            environment.+                                               28600000
                                                                        28650000
            EXPLANATION: The TSO/E program IKJADTAB could not           28700000
            establish recovery.  This message is accompanied            28750000
            by the following message:                                   28800000
                                                                        28850000
            o    ESTAE macro return code RETURN-CODE.                   28900000
                                                                        28950000
            SYSTEM ACTION: IKJADTAB considers this error to be          29000000
            serious and terminates.                                     29050000
                                                                        29100000
            USER ACTION: Contact your TSO administrator for             29150000
            assistance.                                                 29200000
                                                                        29250000
                                                                        29300000
))IKJ79334I IKJADTAB terminated.  Insufficient virtual storage          29350000
            to satisfy request.+                                        29400000
                                                                        29450000
            EXPLANATION: The TSO/E program IKJADTAB needs to obtain     29500000
            more virtual storage than is currently available.           29550000
                                                                        29600000
            SYSTEM ACTION: IKJADTAB considers this error to be          29650000
            serious and terminates.                                     29700000
                                                                        29750000
            USER ACTION: If ISPF is currently active, try leaving at    29800000
            least one active application.  If this does not help or     29850000
            if ISPF is not currently active, logon with a larger        29900000
            region size.  For help, contact your TSO administrator.     29950000
                                                                        30000000
                                                                        30050000
))IKJ79335I IKJADTAB terminated.  Inconsistent or invalid parameters    30100000
            passed to IKJADTAB.+                                        30150000
                                                                        30200000
            EXPLANATION: A program that invoked the TSO/E program       30250000
            IKJADTAB is passing inconsistent or invalid parameters.     30300000
            This message is accompanied by the following message:       30350000
                                                                        30400000
            o    IKJADTAB return code RETURN-CODE.                      30450000
                                                                        30500000
            SYSTEM ACTION: IKJADTAB considers this error to be          30550000
            serious and terminates.                                     30600000
                                                                        30650000
            USER ACTION: Reinvoke the program that invoked IKJADTAB.    30700000
            If the problem recurs, contact your TSO administrator for   30750000
            assistance, or consult "TSO/E Programming Services" to      30800000
            interpret the return code.                                  30850000
                                                                        30900000
                                                                        30950000
))IKJ79336I IKJADTAB terminated.  Invalid ADTAB_LIKE parameter passed   31000000
            to IKJADTAB.+                                               31050000
                                                                        31100000
            EXPLANATION: A program that invoked the TSO/E program       31150000
            IKJADTAB is passing an invalid ADTAB_LIKE parameter.        31200000
            This message is accompanied by the following message:       31250000
                                                                        31300000
            o    IKJADTAB return code RETURN-CODE.                      31350000
                                                                        31400000
            SYSTEM ACTION: IKJADTAB considers this error to be          31450000
            serious and terminates.                                     31500000
                                                                        31550000
            USER ACTION: Reinvoke the program that invoked IKJADTAB.    31600000
            If the problem recurs, contact your TSO administrator for   31650000
            assistance, or consult "TSO/E Programming Services" to      31700000
            interpret the return code.                                  31750000
                                                                        31800000
                                                                        31850000
))IKJ79337I IKJADTAB terminated.  Invalid token passed to IKJADTAB.+    31900000
                                                                        31950000
            EXPLANATION: A program that invoked the TSO/E program       32000000
            IKJADTAB is passing an invalid token.  This message is      32050000
            accompanied by the following message:                       32100000
                                                                        32150000
            o    Invalid token is TOKEN.  IKJADTAB return               32200000
                 code RETURN-CODE.                                      32250000
                                                                        32300000
            SYSTEM ACTION: IKJADTAB considers this error to be          32350000
            serious and terminates.                                     32400000
                                                                        32450000
            USER ACTION: Reinvoke the program that invoked IKJADTAB.    32500000
            If the problem recurs, contact your TSO administrator for   32550000
            assistance, or consult "TSO/E Programming Services" to      32600000
            interpret the return code.                                  32650000
                                                                        32700000
                                                                        32750000
))IKJ79338I ALTLIB terminated.  An EXEC environment does not exist.+    32800000
                                                                        32850000
            EXPLANATION: The ALTLIB action you are requesting           32900000
            requires that an EXEC environment be available, but         32950000
            it is not available.                                        33000000
                                                                        33050000
            SYSTEM ACTION: ALTLIB considers this error to be            33100000
            serious and terminates.                                     33150000
                                                                        33200000
            USER ACTION: Contact your system programmer to diagnose     33250000
            problems with the availability of a language processor      33300000
            environment for REXX.                                       33350000
                                                                        33400000
                                                                        33450000
))IKJ79339I (USER!SYSTEM)-LEVEL CLIST activated; (USER!SYSTEM)-LEVEL    33500000
            EXEC cannot be activated.+                                  33550000
                                                                        33600000
            EXPLANATION: You requested that both the CLIST DDNAME and   33650000
            the EXEC DDNAME at either the user level or system level be 33700000
            activated.  This message is accompanied by the following    33750000
            message:                                                    33800000
                                                                        33850000
            o    An EXEC environment does not exist.                    33900000
                                                                        33950000
            SYSTEM ACTION: This is a warning.  Because the user-level   34000000
            CLIST DDNAME is defined as "SYSUPROC" and the system-level  34050000
            DDNAME is defined as "SYSPROC," the CLIST DDNAME for the    34100000
            level you specified can be activated.  Because the EXEC     34150000
            environment contains information needed to execute an EXEC  34200000
            and it is not available, it is not activated.  The ALTLIB   34250000
            command continues after issuing the message.                34300000
                                                                        34350000
            USER ACTION: Contact your system programmer to diagnose     34400000
            problems with the availability of a language processor      34450000
            environment for REXX.                                       34500000
                                                                        34550000
                                                                        34600000
))IKJ79340I ALTLIB EXEC levels are not available for searching.+        34650000
                                                                        34700000
            EXPLANATION: The ALTLIB command encountered an error        34750000
            during DISPLAY processing.                                  34800000
                                                                        34850000
            SYSTEM ACTION: This is a warning.  Because the EXEC         34900000
            environment contains information needed to execute an EXEC  34950000
            and it is not available, if you try to activate an ALTLIB   35000000
            level for EXEC it will result in an error.  The ALTLIB      35050000
            command continues after issuing the message.                35100000
                                                                        35150000
            USER ACTION: Contact your system programmer to diagnose     35200000
            problems with the availability of a language processor      35250000
            environment for REXX.                                       35300000
                                                                        35350000
))IKJ79341I The ALTLIB command abnormally terminated.+                  35400000
                                                                        35450000
            EXPLANATION: An unexpected error occurred in the ALTLIB     35500000
            command, causing it to abnormally terminate.  The message   35550000
            is accompanied by the following message:                    35600000
                                                                        35650000
            o    (SYSTEM!USER) ABEND CODE 'code' REASON CODE 'code'.    35700000
                                                                        35750000
            SYSTEM ACTION: The ALTLIB command processor considers       35800000
            this error to be serious and terminates.                    35850000
                                                                        35900000
            USER ACTION: Contact your system programmer to diagnose     35950000
            problems with the ALTLIB command processor.                 36000000
                                                                        36050000
))IKJ79342I ALTLIB terminated.  A valid ALTLIB environment does         36100000
            not exist.+                                                 36150000
                                                                        36200000
            EXPLANATION: The system previously created an environment   36250000
            that it expected to use for the current request.  The       36300000
            ALTLIB command determined that this environment is in       36350000
            error.  The message is accompanied by the following         36400000
            message:                                                    36450000
                                                                        36500000
            o    Contact your system programmer to diagnose problems    36550000
                 with the ALTLIB environment.                           36600000
                                                                        36650000
            SYSTEM ACTION: The ALTLIB command processor considers       36700000
            this error to be serious and terminates.                    36750000
                                                                        36800000
            USER ACTION: Contact your system programmer to diagnose     36850000
            problems with the ALTLIB environment.                       36900000
                                                                        36950000
))                                                                      37000000
)O Operands:                                                            37050000
            ACTIVATE, DEACTIVATE, RESET, and DISPLAY are positional     37100000
            operands, one of which must follow the ALTLIB command.      37150000
)P                                                                      37200000
))ACTIVATE                                                              37250000
            Includes the specified level when searching for an REXX     37300000
            EXEC or CLIST.                                              37350000
                                                                        37400000
            This operand can be shortened to "ACT."                     37450000
                                                                        37500000
)P                                                                      37550000
))DEACTIVATE                                                            37600000
            Excludes the specified level when searching for an REXX     37650000
            EXEC or CLIST.                                              37700000
                                                                        37750000
            This keyword can be shortened to "DEA" or "DEACT."          37800000
                                                                        37850000
)P                                                                      37900000
))RESET                                                                 37950000
            Resets searching back to the original method of searching   38000000
            for system-level REXX EXECs or CLISTs only.  Issuing        38050000
            both "ALTLIB DEACTIVATE ALL" and "ALTLIB ACTIVATE           38100000
            SYSTEM(*)" is equivalent to "ALTLIB RESET".  Users should   38150000
            issue the "ALTLIB RESET" command when an application is     38200000
            completing.                                                 38250000
                                                                        38300000
            This keyword can be shortened to "RES."                     38350000
                                                                        38400000
)P                                                                      38450000
))DISPLAY                                                               38500000
            Issues messages (or sets ISPF shared pool variables if the  38550000
            QUIET operand is used when ISPF is active) that show the    38600000
            current search sequence the EXEC command processor uses to  38650000
            find an REXX EXEC or CLIST.                                 38700000
                                                                        38750000
            This keyword can be shortened to "DIS" or "DISP."           38800000
                                                                        38850000
))QUIET                                                                 38900000
            Indicates that the user does not want messages returned to  38950000
            the screen.  Instead, if ISPF is active, variables are put  39000000
            into the ISPF shared pool as follows:                       39050000
                                                                        39100000
            o   Variable IKJADM contains the number of non-blank        39150000
                messages being returned for this invocation of the      39200000
                ALTLIB command with the QUIET operand.                  39250000
                                                                        39300000
            o   Variable IKJADM1 contains the first message,            39350000
                variable IKJADM2 contains the second message, and so    39400000
                on.  Up to 99 messages can be saved in IKJADM1          39450000
                through IKJADM99.                                       39500000
                                                                        39550000
            If ISPF is not active, then the messages are not            39600000
            saved.                                                      39650000
                                                                        39700000
            The QUIET operand can primarily be used when the ALTLIB     39750000
            command is invoked from within a program.  The program      39800000
            will need access to the messages, but will not want to      39850000
            display them and trapping messages is not available         39900000
            because SYSOUTTRAP cannot be used in a program.             39950000
                                                                        40000000
            Notes:                                                      40050000
                                                                        40100000
            1.  The variables put to the ISPF shared pool are the       40150000
                actual messages that would have been put to the         40200000
                screen.  The length of the messages are not restricted  40250000
                to 80 characters.                                       40300000
                                                                        40350000
            2.  QUIET does not take affect until after the command      40400000
                buffer is known to be syntactically correct.  If PARSE  40450000
                finds an error or needs to prompt for input, it will    40500000
                issue messages and obtain input from the terminal as    40550000
                necessary.                                              40600000
                                                                        40650000
            3.  The ISPF shared pool variables are only set when        40700000
                needed.  They are not blanked out if they are not       40750000
                needed.                                                 40800000
                                                                        40850000
))USER(EXEC/CLIST/*)                                                    40900000
            Indicates the user-level REXX EXECs and CLISTs are to       40950000
            be activated or deactivated.  The user level is defined as  41000000
            the data sets concatenated to the DDNAME SYSUEXEC for       41050000
            REXX EXECs and the DDNAME SYSUPROC for both CLISTs and      41100000
            REXX EXECs.                                                 41150000
                                                                        41200000
))APPLICATION(EXEC/CLIST/*)                                             41250000
            Indicates the application-level REXX EXECs and CLISTs       41300000
            are to be activated or deactivated.  The application level  41350000
            is defined using one of the following:                      41400000
                                                                        41450000
            o   The DATASET keyword to identify a list of data sets     41500000
                                                                        41550000
            o   The FILE keyword to identify any previously allocated   41600000
                DDNAME.                                                 41650000
                                                                        41700000
            When defining the APPLICATION level for EXEC, the list of   41750000
            data sets or file can contain only REXX EXECs.  When        41800000
            defining the APPLICATION level CLIST, the list of data      41850000
            sets or file can contain both CLISTs and REXX EXECs.        41900000
                                                                        41950000
            Note that APPLICATION(*) is only valid when deactivating    42000000
            the application level.                                      42050000
                                                                        42100000
))SYSTEM(EXEC/CLIST/*)                                                  42150000
            Indicates the system-level REXX EXECs and CLISTs are to     42200000
            be activated or deactivated.  The system level is defined   42250000
            as the data sets concatenated to the DDNAME SYSEXEC (by     42300000
            default) for REXX EXECs or the data sets concatenated to    42350000
            the DDNAME SYSPROC for both CLISTs and REXX EXECs.          42400000
                                                                        42450000
            TSO/E provides your installation with the ability to        42500000
            change the DDNAME under which the system searches for       42550000
            REXX EXECs.                                                 42600000
                                                                        42650000
))ALL                                                                   42700000
            Indicates all levels (that is, user, application, and       42750000
            system) of REXX EXECs and CLISTs are to be                  42800000
            deactivated.                                                42850000
                                                                        42900000
            Note that "ALTLIB DEACTIVATE ALL" is not equivalent to      42950000
            "ALTLIB RESET".  "ALTLIB DEACTIVATE ALL" deactivates the    43000000
            user, application, and system levels while "ALTLIB RESET"   43050000
            deactivates the user and application levels and activates   43100000
            the system level.  "ALTLIB RESET" is equivalent to the      43150000
            state before any ALTLIBs are issued.                        43200000
                                                                        43250000
))DATASET(data-set-list),DSNAME(data-set-list)                          43300000
            Indicates the list of data sets defines the                 43350000
            application-level library of REXX EXECs or CLISTs.          43400000
                                                                        43450000
            Each data set must exist as a cataloged partitioned data    43500000
            set at the time that ALTLIB is issued.  A maximum of        43550000
            fifteen data set names can be listed.  Each data set        43600000
            in the list must have the same record format (RECFM) and    43650000
            logical record length (LRECL).  If the data sets have       43700000
            different block sizes, you must specify the data set with   43750000
            the largest block size first.                               43800000
                                                                        43850000
            An alternative form of DATASET is DSNAME.                   43900000
                                                                        43950000
))DSNAME(data-set-list)                                                 44000000
            DSNAME is an alternative form of DATASET.  For more         44050000
            information, refer to the DATASET operand.                  44100000
                                                                        44150000
))FILE(ddname),DDNAME(ddname),LIBRARY(ddname)                           44200000
            Indicates the DDNAME defines the application-level library  44250000
            of REXX EXECs or CLISTs.                                    44300000
                                                                        44350000
            The DDNAME must be previously allocated before issuing the  44400000
            ALTLIB command.                                             44450000
                                                                        44500000
            Alternative forms of FILE are DDNAME and LIBRARY.           44550000
                                                                        44600000
))DDNAME(ddname)                                                        44650000
            DDNAME is an alternative form of FILE.  For more            44700000
            information, refer to the FILE operand.                     44750000
                                                                        44800000
))LIBRARY(ddname)                                                       44850000
            LIBRARY is an alternative form of FILE.  For more           44900000
            information, refer to the FILE operand.                     44950000
                                                                        45000000
))UNCOND                                                                45050000
            Indicates the application-level library should be           45100000
            activated even if another application-level library is      45150000
            already active for the same type (either CLIST or EXEC)     45200000
            within the current application.                             45250000
                                                                        45300000
            If a previous application-level library is in effect, then  45350000
            the second request becomes current and the first request    45400000
            is stacked underneath.  Up to eight REXX requests and       45450000
            eight CLIST requests can be stacked.                        45500000
                                                                        45550000
            For more information about starting a new application,      45600000
            refer to the ISPF/PDF Dialog Management Services.  The      45650000
            ISPSTART command and ISPEXEC SELECT service describe        45700000
            starting new applications.                                  45750000
                                                                        45800000
))COND                                                                  45850000
            Indicates the application-level library should be           45900000
            activated only if there is no active application-level      45950000
            library for the same type (either CLIST or EXEC) within     46000000
            the current application.                                    46050000
                                                                        46100000
            If a previous application-level library is in effect, then  46150000
            a message is displayed and a non-zero return code is set.   46200000
                                                                        46250000
            For more information about starting a new application,      46300000
            refer to the ISPF/PDF Dialog Management Services.  The      46350000
            ISPSTART command and ISPEXEC SELECT service describe        46400000
            starting new applications.                                  46450000
                                                                        46500000

./ ADD NAME=IOAVERFY
PROC 0  DEBUG +
        STEPLIB ('SYS4.IOA920.LOAD') +
        ILPREFA('SYS4.IOA920') +
        OUTDUMP(A)
/********************************************************************/
/*                                                                  */
/*                 IOA VERIFICATION PROGRAM                         */
/*                 ------------------------                         */
/*                                                                  */
/*    THIS PROGRAM VERIFIES THE STATUS OF IOA DATA-SETS AND         */
/*    INSTALLATION PROBLEMS.                                        */
/*                                                                  */
/********************************************************************/
CONTROL MAIN NOLIST NOCONLIST NOSYMLIST NOMSG
IF &DEBUG=DEBUG THEN CONTROL MAIN LIST CONLIST SYMLIST MSG

GLOBAL IOAVAR

%IOAENVC IOAVAR(ILPREFA)
IF &ILPREFA = &STR() THEN SET &ILPREFA = &IOAVAR
%IOAENVC IOAVAR(STEPLIB)
IF &STEPLIB = &STR() THEN SET &STEPLIB = &IOAVAR
%IOAENVC IOAVAR(OUTDUMP)
IF &OUTDUMP = &STR() THEN SET &OUTDUMP = &IOAVAR

  ALLOC DD(DAPARM) +
     DSN('&ILPREFA..PARM','&ILPREFA..IOAENV') SHR REU

FREE FI(DAALOCIN)
FREE FI(DADUMP)
FREE FI(DAVRFIN)
FREE FI(DAVRFOUT)
FREE FI(DAVRFREP)
FREE FI(DAVRFPRT)
FREE FI(PRTDBG)
FREE FI(SYSPRINT)
FREE FI(SYSUDUMP)
ALLOC FI(DAALOCIN) DA('&ILPREFA..IOAENV(ALCIOVFY)') SHR
ALLOC FI(DADUMP)   DA(*)
ALLOC FI(DAVRFIN)  DA(*)
ALLOC FI(DAVRFOUT) DA(*)
ALLOC FI(DAVRFREP) DA(*)
ALLOC FI(DAVRFPRT) DA(*)
ALLOC FI(PRTDBG)   DA(*)
ALLOC FI(SYSPRINT) DA(*)
ALLOC FI(SYSUDUMP) SYSOUT(&OUTDUMP)
WRITE TYPE IN INPUT PARAMETERS
CALL '&STEPLIB(CTMVRF10)'
FREE FI(DAALOCIN)
FREE FI(DADUMP)
FREE FI(DAVRFIN)
FREE FI(DAVRFOUT)
FREE FI(DAVRFREP)
FREE FI(DAVRFPRT)
FREE FI(PRTDBG)
FREE FI(SYSPRINT)
FREE FI(SYSUDUMP)

./ ADD NAME=IOA9P0
/*       REXX      $IOAISPF */                                          00010000
X = MSG('OFF')                                                          00020000
/* DEBUT MODIFS DL  */                                                  00020100
SELECT                                                                  00020200
WHEN SUBSTR(USERID(),1,3) ^= 'APT' THEN  CALL DEBUT                     00020300
OTHERWISE                                                               00020400
SAY 'VOUS N ETES PAS AUTORISE A CETTE FONCTION'                         00020500
  EXIT                                                                  00020600
END                                                                     00020700
DEBUT:                                                                  00020800
/* FIN MODIFS DL  */                                                    00020900
"FREE FI(DALOG)"                                                        00021000
"FREE FI(DACNDIN)"                                                      00022000
ADDRESS ISPEXEC                                                         00023000
"LIBDEF  ISPLLIB  DATASET                                               00024000
           ID('SYS4.IOA918P0.LOAD','SYS4.IOA918P0.LOADE')"              00025001
ADDRESS ISPEXEC                                                         00026000
"LIBDEF  ISPMLIB  DATASET                                               00027000
           ID('S28P.P0.IOA918.ISMSGENG')"                               00028000
ADDRESS ISPEXEC                                                         00029000
"LIBDEF  ISPPLIB  DATASET                                               00030000
           ID('S28P.P0.IOA918.PANELENG')"                               00040000
ADDRESS ISPEXEC                                                         00050000
"LIBDEF  ISPSLIB  DATASET                                               00060000
           ID('S28P.P0.IOA918.JCL')"                                    00070000
ADDRESS ISPEXEC                                                         00080000
"LIBDEF  ISPTLIB  DATASET                                               00090000
           ID('S28P.P0.IOA918.PANELENG')"                               00100000
ADDRESS TSO "ALLOC DD(PIOACLIB) DA('S28P.P0.IOA918.CLIST') SHR REUSE"   00110000
ADDRESS TSO "ALTLIB ACTIVATE APPLICATION(CLIST) LIBRARY(PIOACLIB)"      00120000
"SELECT CMD(IOAISPF)"                                                   00130000

./ ADD NAME=IOA9R1
/*       REXX      $IOAISPF */                                          00010000
X = MSG('OFF')                                                          00020000
/* DEBUT MODIFS DL  */                                                  00020100
SELECT                                                                  00020200
WHEN SUBSTR(USERID(),1,3) ^= 'APT' THEN  CALL DEBUT                     00020300
OTHERWISE                                                               00020400
SAY 'VOUS N ETES PAS AUTORISE A CETTE FONCTION'                         00020500
  EXIT                                                                  00020600
END                                                                     00020700
DEBUT:                                                                  00020800
/* FIN MODIFS DL  */                                                    00020900
"FREE FI(DALOG)"                                                        00021000
"FREE FI(DACNDIN)"                                                      00022000
ADDRESS ISPEXEC                                                         00023000
"LIBDEF  ISPLLIB  DATASET                                               00024000
           ID('SYS4.IOA918R1.LOAD','SYS4.IOA918R1.LOADE')"              00025002
ADDRESS ISPEXEC                                                         00026000
"LIBDEF  ISPMLIB  DATASET                                               00027000
           ID('S28P.R1.IOA918.ISMSGENG')"                               00028000
ADDRESS ISPEXEC                                                         00029000
"LIBDEF  ISPPLIB  DATASET                                               00030000
           ID('S28P.R1.IOA918.PANELENG')"                               00040000
ADDRESS ISPEXEC                                                         00050000
"LIBDEF  ISPSLIB  DATASET                                               00060000
           ID('S28P.R1.IOA918.JCL')"                                    00070000
ADDRESS ISPEXEC                                                         00080000
"LIBDEF  ISPTLIB  DATASET                                               00090000
           ID('S28P.R1.IOA918.PANELENG')"                               00100000
ADDRESS TSO "ALLOC DD(PIOACLIB) DA('S28P.R1.IOA918.CLIST') SHR REUSE"   00110000
ADDRESS TSO "ALTLIB ACTIVATE APPLICATION(CLIST) LIBRARY(PIOACLIB)"      00120000
"SELECT CMD(IOAISPF)"                                                   00130000

./ ADD NAME=IOA9U1
/*       REXX      $IOAISPF */                                          00010000
X = MSG('OFF')                                                          00020000
/* DEBUT MODIFS DL  */                                                  00020100
SELECT                                                                  00020200
WHEN SUBSTR(USERID(),1,3) ^= 'APT' THEN  CALL DEBUT                     00020300
OTHERWISE                                                               00020400
SAY 'VOUS N ETES PAS AUTORISE A CETTE FONCTION'                         00020500
  EXIT                                                                  00020600
END                                                                     00020700
DEBUT:                                                                  00020800
/* FIN MODIFS DL  */                                                    00020900
"FREE FI(DALOG)"                                                        00021000
"FREE FI(DACNDIN)"                                                      00022000
ADDRESS ISPEXEC                                                         00023000
"LIBDEF  ISPLLIB  DATASET                                               00024000
           ID('SYS4.IOA920U1.LOAD','SYS4.IOA920U1.LOADE')"              00025000
ADDRESS ISPEXEC                                                         00026000
"LIBDEF  ISPMLIB  DATASET                                               00027000
           ID('S28P.U1.IOA920.ISMSGENG')"                               00028000
ADDRESS ISPEXEC                                                         00029000
"LIBDEF  ISPPLIB  DATASET                                               00030000
           ID('S28P.U1.IOA920.PANELENG')"                               00040000
ADDRESS ISPEXEC                                                         00050000
"LIBDEF  ISPSLIB  DATASET                                               00060000
           ID('S28P.U1.IOA920.JCL')"                                    00070000
ADDRESS ISPEXEC                                                         00080000
"LIBDEF  ISPTLIB  DATASET                                               00090000
           ID('S28P.U1.IOA920.PANELENG')"                               00100000
ADDRESS TSO "ALLOC DD(PIOACLIB) DA('S28P.U1.IOA920.CLIST') SHR REUSE"   00110000
ADDRESS TSO "ALTLIB ACTIVATE APPLICATION(CLIST) LIBRARY(PIOACLIB)"      00120000
"SELECT CMD(IOAISPF)"                                                   00130000

./ ADD NAME=IOA9U1$
/*       REXX      $IOAISPF */                                          00010000
X = MSG('OFF')                                                          00020000
/* DEBUT MODIFS DL  */                                                  00020100
SELECT                                                                  00020200
WHEN SUBSTR(USERID(),1,3) ^= 'APT' THEN  CALL DEBUT                     00020300
OTHERWISE                                                               00020400
SAY 'VOUS N ETES PAS AUTORISE A CETTE FONCTION'                         00020500
  EXIT                                                                  00020600
END                                                                     00020700
DEBUT:                                                                  00020800
/* FIN MODIFS DL  */                                                    00020900
"FREE FI(DALOG)"                                                        00021000
"FREE FI(DACNDIN)"                                                      00022000
ADDRESS ISPEXEC                                                         00023000
"LIBDEF  ISPLLIB  DATASET                                               00024000
           ID('SYS4.IOA918U1.LOAD','SYS4.IOA918U1.LOADE')"              00025002
ADDRESS ISPEXEC                                                         00026000
"LIBDEF  ISPMLIB  DATASET                                               00027000
           ID('S28P.U1.IOA918.ISMSGENG')"                               00028000
ADDRESS ISPEXEC                                                         00029000
"LIBDEF  ISPPLIB  DATASET                                               00030000
           ID('S28P.U1.IOA918.PANELENG')"                               00040000
ADDRESS ISPEXEC                                                         00050000
"LIBDEF  ISPSLIB  DATASET                                               00060000
           ID('S28P.U1.IOA918.JCL')"                                    00070000
ADDRESS ISPEXEC                                                         00080000
"LIBDEF  ISPTLIB  DATASET                                               00090000
           ID('S28P.U1.IOA918.PANELENG')"                               00100000
ADDRESS TSO "ALLOC DD(PIOACLIB) DA('S28P.U1.IOA918.CLIST') SHR REUSE"   00110000
ADDRESS TSO "ALTLIB ACTIVATE APPLICATION(CLIST) LIBRARY(PIOACLIB)"      00120000
"SELECT CMD(IOAISPF)"                                                   00130000

./ ADD NAME=IPCS
address TSO "ALLOC F("ipcsrint") DA('"dsns.i"') SHR REUS"
ALLOC FI(SYSPRINT) DA(*)
ALLOC FI(ipcsprnt) SYSOUT(&OUTDUMP)
ALLOC FI(ipcsprnt) SYSOUT(*)

./ ADD NAME=IPLINFO
/* REXX */
/*                                       */
/* AUTHOR: Mark Zelden                   */
/*                                       */
/* Trace ?r */
/*                                                                   */
/*********************************************************************/
/*                                                                   */
/*   D I S C L A I M E R                                             */
/*   -------------------                                             */
/*                                                                   */
/* This program is FREEWARE. Use at your own risk.  Neither Mark     */
/* Zelden, nor other contributing organizations or individuals       */
/* accept any liability of any kind howsoever arising out of the use */
/* of this program. You are free to use and modify this program as   */
/* you desire, however, the author does ask that you leave his name  */
/* in the source and give credit to him as the original programmer.  */
/*                                                                   */
/*********************************************************************/
/* IPLINFO:  DISPLAY SYSTEM INFORMATION ON TERMINAL                  */
/*********************************************************************/
/*                                                                   */
/* IPLINFO can be called as an interactive exec / ISPF edit macro    */
/* or in batch to display various system information.  The result    */
/* will be displayed in an ISPF browse data set if ISPF is active.   */
/*                                                                   */
/* IPLINFO can also be called as a REXX function to return from 1    */
/* to 20 variables used in the exec at their final value.  If more   */
/* than one variable is requested the variables are returned with    */
/* a blank or user defined delimiter between each variable so they   */
/* may be parsed if desired.                                         */
/*                                                                   */
/* See below for the sytax of each method.                           */
/*                                                                   */
/*********************************************************************/
/*                                                                   */
/* EXECUTION SYNTAX:                                                 */
/*                                                                   */
/* TSO %IPLINFO <option>                                             */
/*                                                                   */
/* VALID OPTIONS ARE 'ALL', 'IPL', 'VERsion', 'STOrage', 'CPU',      */
/*                   'IPA', 'SYMbols', 'VMAp', 'PAGe', 'SMF', 'SUB', */
/*                   'ASId', 'LPA', 'LNKlst', 'APF' and 'SVC'        */
/*                                                                   */
/* ** 'ALL' is the default option                                    */
/* ** Options may be abbreviated by using 3 or more characters       */
/*                                                                   */
/* ** A 2nd parameter option of 'NOBrowse' may also be specified to  */
/*    eliminate browsing the output even when ISPF is active. This   */
/*    will allow any IPLINFO output to be trapped and parsed from    */
/*    another exec or edit macro if desired.  The 'NOBrowse' option  */
/*    can also be specified as the only option and it will produce   */
/*    all IPLINFO output without browsing it.                        */
/*                                                                   */
/* ** A 2nd parameter option of 'EDIt' may also be specified to      */
/*    EDIT the output instead of browsing it. The 'EDIt' option      */
/*    can also be specified as the only option and it will produce   */
/*    all IPLINFO output without editing it.                         */
/*                                                                   */
/* ** The following options are not documented above as standard     */
/*    options nor in the help panel:                                 */
/*      "ASVt"   - an alias for the "ASId" option                    */
/*      "ASM"    - an alias for the "PAGE" option                    */
/*      "SSI"    - an alias for the "SUB"  option                    */
/*      "SSN"    - an alias for the "SUB"  option                    */
/*      "STOre"  - an alias for the "STORage"  option                */
/*      "MEMory" - an alias for the "STORage"  option                */
/*      "SUBsystems" - an alias for the "SUB"  option                */
/*      "NOBrowse"   - the NOBrowse option                           */
/*      "EDIt"       - the EDIt option                               */
/*                                                                   */
/* Examples:                                                         */
/*  TSO %IPLINFO         (Display all information)                   */
/*  TSO %IPLINFO VMAP    (Display a Virtual Storage Map)             */
/*  TSO %IPLINFO SYM     (Display Static System Symbols)             */
/*  TSO %IPLINFO SUB     (Display Subsystem Information)             */
/*  TSO %IPLINFO APF     (Display APF Library List)                  */
/*  TSO %IPLINFO ALL NOB (Display all infomation, don't browse O/P)  */
/*  TSO %IPLINFO SUB NOB (Display subsys info, don't browse O/P)     */
/*  TSO %IPLINFO NOBROWSE (Display all infomation, don't browse O/P) */
/*  TSO %IPLINFO ALL EDI (Display all infomation, edit O/P)          */
/*  TSO %IPLINFO SUB EDI (Display subsys info, edit O/P)             */
/*  TSO %IPLINFO EDIT    (Display all infomation, edit O/P)          */
/*                                                                   */
/* Edit macro invocation:                                            */
/*  IPLINFO              (Display all information)                   */
/*  IPLINFO VMAP         (Display a Virtual Storage Map)             */
/*  IPLINFO SYM          (Display Static System Symbols)             */
/*  IPLINFO SUB          (Display Subsystem Information)             */
/*  IPLINFO APF          (Display APF Library List)                  */
/*  IPLINFO ALL NOB      (Display all infomation, don't browse O/P)  */
/*  IPLINFO SUB NOB      (Display subsys info, don't browse O/P)     */
/*  IPLINFO NOBROWSE     (Display all infomation, don't browse O/P)  */
/*  IPLINFO ALL EDIT     (Display all infomation, edit O/P)          */
/*  IPLINFO SUB EDIT     (Display subsys info, edit O/P)             */
/*  IPLINFO EDIT         (Display all infomation, edit O/P)          */
/*                                                                   */
/* Sample Unix System Services WEB Server execution via links:       */
/*  <a href="/cgi-bin/iplinfo">MVS Information</a>                   */
/*  <a href="/cgi-bin/iplinfo?vmap">Virtual Storage Map</a>          */
/*  <a href="/cgi-bin/iplinfo?symbols">Static System Symbols</a>     */
/*  <a href="/cgi-bin/iplinfo?sub">Subsystem Information</a>         */
/*  <a href="/cgi-bin/iplinfo?apf">APF Library List</a>              */
/*                                                                   */
/*********************************************************************/
/*                                                                   */
/* FUNCTION SYNTAX:                                                  */
/*                                                                   */
/* IPLINFO(VAR,var1_name)                                            */
/* IPLINFO(VAR,var1_name,var2_name,var3_name, ... var20_name)        */
/*                                                                   */
/* Examples:                                                         */
/*  sysname = IPLINFO(VAR,GRSNAME)                                   */
/*  pvtsize = IPLINFO(VAR,GDAPVTSZ)                                  */
/*                                                                   */
/*                                                                   */
/*  /* REXX one line IPL information using IPLINFO rexx function */  */
/*  IPL_SUM  = IPLINFO(VAR,ipldate,ipltime,iplvol,ipladdr,iplparm)   */
/*  Parse var IPL_SUM ipldate ipltime iplvol ipladdr iplparm         */
/*  Say 'Date:'ipldate  ' Time:'ipltime ' Vol:'iplvol ,              */
/*      ' Load addr:'ipladdr ' LOADPARM:'iplparm                     */
/*                                                                   */
/*                                                                   */
/*  NOTE: The default delimeter between returned variables is a      */
/*        blank. However, this can be problematic when the returned  */
/*        value contains a blank or is null. You can optionally      */
/*        change the delimiter from a blank to one of your choice    */
/*        by using "VAR2" instead of "VAR" in the function call and  */
/*        specifying the delimiter character(s) as the next operand  */
/*        prior to the list of variables you want returned.          */
/*                                                                   */
/*                                                                   */
/* FUNCTION SYNTAX - "VAR2" / USER DEFINED DELIMITER:                */
/*                                                                   */
/* IPLINFO(VAR2,'dlm',var1_name)                                     */
/* IPLINFO(VAR2,'dlm',var1_name,var2_name,var3_name, ... var20_name) */
/*                                                                   */
/* Example:                                                          */
/*  /* REXX one line IPL information using IPLINFO rexx function */  */
/*  IPL_SUM  = IPLINFO(VAR2,'@@',ipldate,ipltime,iplvol, ,           */
/*                     ipladdr,iplparm)                              */
/*  Parse var IPL_SUM ipldate '@@' ipltime '@@' iplvol '@@' ,        */
/*                    ipladdr '@@' iplparm                           */
/*  Say 'Date:'ipldate  ' Time:'ipltime ' Vol:'iplvol ,              */
/*      ' Load addr:'ipladdr ' LOADPARM:'iplparm                     */
/*                                                                   */
/*********************************************************************/
/*                                                                   */
/* NOTE: The dynamic APF and dynamic LNKLST code in this exec        */
/*       use undocumented IBM control blocks and may break at        */
/*       any time!                                                   */
/*     ... tested on MVS ESA V4.3 up through z/OS 2.3.               */
/*                                                                   */
/* NOTE: The LNKLST SET displayed is the LNKLST SET of the address   */
/*       space running this exec, not necessarily the most           */
/*       current one. For the current LNKLST SET either:             */
/*       1) Run this exec in batch.                                  */
/*       2) Log off and on TSO before executing this exec.           */
/*       3) Issue SETPROG LNKLST,UPDATE,JOB=userid  (B4 execution)   */
/*                                                                   */
/* NOTE: The APF flag in the LNKLST display is the status if the     */
/*       data set is accessed VIA LNKLST. Therefore, if IEASYSxx     */
/*       specifies LNKAUTH=LNKLST, all entires are marked as APF=Y.  */
/*                                                                   */
/*********************************************************************/
LASTUPD = '09/24/2020'                       /* date of last update  */
/*********************************************************************/
/*                                                                   */
/* B E G I N    C U S T O M I Z A T I O N    S E C T I O N           */
/*                                                                   */
/*   You may changes the variables below to your preference.         */
/*   You may only choose the options that are commented out.         */
/*                                                                   */
/*  DATEFMT - Controls date format:   ISO ; USA ; EUR                */
/*  VMAP    - Controls VMAP order:    HIGHFIRST ; LOWFIRST           */
/*                                                                   */
/*********************************************************************/
DATEFMT = 'ISO'          /* ISO 8601 format YYYY-MM-DD (new default) */
/* DATEFMT = 'USA' */    /* USA format MM/DD/YYYY (original format)  */
/* DATEFMT = 'EUR' */    /* EUR format DD/MM/YYYY                    */
/*********************************************************************/
VMAP = 'HIGHFIRST'       /* new default - show VMAP from top down    */
/* VMAP = 'LOWFIRST' */  /* the old way - show from bottom up        */
/*  Please let me know if you "need" the old way (LOWFIRST) as I     */
/*  will probably remove the duplicate code in the future.           */
/*********************************************************************/
/*                                                                   */
/* E N D    C U S T O M I Z A T I O N    S E C T I O N               */
/*                                                                   */
/*********************************************************************/
Signal On  Syntax  name SIG_ALL     /* trap syntax errors            */
Signal On  Novalue name SIG_ALL     /* trap uninitialized variables  */
Arg OPTION,VAR.1,VAR.2,VAR.3,VAR.4,VAR.5,VAR.6,VAR.7,VAR.8,VAR.9, ,
  VAR.10,VAR.11,VAR.12,VAR.13,VAR.14,VAR.15,VAR.16,VAR.17,VAR.18, ,
  VAR.19,VAR.20,VAR.21
Parse source . EXEC_TYPE . . . . . ENV . .
MML      = Substr(LASTUPD,1,2)             /* MM from MM/DD/YYYY     */
DDL      = Substr(LASTUPD,4,2)             /* DD from MM/DD/YYYY     */
YYYYL    = Substr(LASTUPD,7,4)             /* YYYY from MM/DD/YYYY   */
If DATEFMT = 'USA' then ,                  /* USA format date?       */
  LASTUPD  = LASTUPD                       /* date as MM/DD/YYYY     */
If DATEFMT = 'EUR' then ,                  /* EUR format date?       */
  LASTUPD  = DDL'/'MML'/'YYYYL             /* date as DD/MM/YYYY     */
If DATEFMT = 'ISO' then ,                  /* ISO format date?       */
  LASTUPD  = YYYYL'-'MML'-'DDL             /* date as YYYY-MM-DD     */
SYSISPF = 'NOT ACTIVE'                     /* set SYSISPF=NOT ACTIVE */
FUNCDLM = ' '               /* Delimiter default for function call   */
If ENV <> 'OMVS' then                      /* are we under unix ?    */
  If Sysvar('SYSISPF')='ACTIVE' then do    /* no, is ISPF active?    */
    If Pos('NOB',OPTION) = 0 then ,        /* NOBrowse not used?     */
      Address ISREDIT "MACRO (OPTION)"     /* YES,allow use as macro */
    OPTION = Translate(OPTION)   /* ensure upper case for edit macro */
    Address ISPEXEC "VGET ZENVIR"          /* ispf version           */
    SYSISPF = 'ACTIVE'                     /* set SYSISPF = ACTIVE   */
  End
/*********************************************************************/
/* Process options                                                   */
/*********************************************************************/
BROWSEOP = 'YES'            /* default is to browse OP under ISPF    */
EDITOP   = 'NO'             /* output is not in edit mode            */
/*********************************************************************/
If SYSISPF = 'NOT ACTIVE' & Pos('EDI',OPTION) <> 0 then /* EDIT is   */
  call INVALID_OPTION       /* not valid if ISPF isn't active        */
If OPTION = '' then OPTION = 'ALL' /* Default option. Change to IPL  */
     /* or something else - may want to change help panel if changed */
If Abbrev('NOBROWSE',OPTION,3) = 1 then ,   /* NOBROWSE only opt?    */
  OPTION = 'ALL NOBROWSE'                /* yes, use all option      */
If Abbrev('EDIT',OPTION,3) = 1 then ,    /* EDITonly opt?            */
  OPTION = 'ALL EDIT'                    /* yes, use all option      */
If Abbrev('NOBROWSE',Word(OPTION,2),3) = 1 then do /* NOBROWSE USED? */
  OPTION = Word(OPTION,1)                /* separate out option      */
  BROWSEOP = 'NO'                        /* set BROWSEOP flag to NO  */
End
If Abbrev('EDIT',Word(OPTION,2),3) = 1 then do     /* EDIT USED?     */
  OPTION = Word(OPTION,1)                /* separate out option      */
  EDITOP   = 'YES'                       /* set EDITOP flag to YES   */
End
/*********************************************************************/
If OPTION <> 'IPL'                 & ,   /* check for IPL option     */
   Abbrev('VERSION',OPTION,3) <> 1 & ,   /* check for VERsion option */
   Abbrev('STORAGE',OPTION,3) <> 1 & ,   /* check for STOrage option */
   Abbrev('STORE',OPTION,3)   <> 1 & ,   /* check for STOre   option */
   Abbrev('MEMORY',OPTION,3)  <> 1 & ,   /* check for MEMory  option */
   OPTION <> 'CPU'                 & ,   /* check for CPU option     */
   OPTION <> 'IPA'                 & ,   /* check for IPA option     */
   Abbrev('SYMBOLS',OPTION,3) <> 1 & ,   /* check for SYMbols option */
   Abbrev('VMAP',OPTION,3) <> 1    & ,   /* check for VMAp option    */
   Abbrev('PAGE',OPTION,3) <> 1    & ,   /* check for PAGe option    */
   Abbrev('ASM',OPTION,3) <> 1     & ,   /* check for ASM option     */
   Abbrev('AUX',OPTION,3) <> 1     & ,   /* check for ASM option     */
   OPTION <> 'SMF'                 & ,   /* check for SMF option     */
   OPTION <> 'SSI'                 & ,   /* check for SSI option     */
   OPTION <> 'SSN'                 & ,   /* check for SSN option     */
   OPTION <> 'SUB'                 & ,   /* check for SUB option     */
   Abbrev('SUBSYSTEMS',OPTION,3) <> 1  & ,  /* check for SUB option  */
   Abbrev('ASID',OPTION,3) <> 1    & ,   /* check for ASId option    */
   Abbrev('ASVT',OPTION,3) <> 1    & ,   /* check for ASVt option    */
   OPTION <> 'LPA'                 & ,   /* check for LPA option     */
   Abbrev('LNKLST',OPTION,3) <> 1  & ,   /* check for LNKlst option  */
   Abbrev('LINKLIST',OPTION,3) <> 1 & ,  /* check for LINklist option*/
   OPTION <> 'APF'                 & ,   /* check for APF option     */
   OPTION <> 'SVC'                 & ,   /* check for SVC option     */
   OPTION <> 'ALL'                 & ,   /* check for ALL option     */
   Substr(OPTION,1,3) <> 'VAR'       ,   /* check for VAR option     */
   then call INVALID_OPTION              /* no valid option...       */
Numeric digits 20                           /* dflt of 9 not enough  */
                                            /* 20 can handle 64-bit  */
Call COMMON            /* control blocks needed by multiple routines */
Call HEADING                                /* Heading sub-routine   */
Select
  When OPTION = 'ALL' !  Substr(OPTION,1,3) = 'VAR' then do
    Call IPL                                /* IPL information       */
    Call VERSION                            /* Version information   */
    Call STOR                               /* Storage information   */
    Call CPU                                /* CPU information       */
    Call IPA                                /* Initialization info.  */
    Call SYMBOLS                            /* Symbols information   */
    Call VMAP                               /* Virt. Storage Map     */
    Call PAGE                               /* Page DSN information  */
    Call SMF                                /* SMF DSN information   */
    Call SUB                                /* Subsystem information */
    Call ASID                               /* ASID usage information*/
    Call LPA                                /* LPA List information  */
    Call LNKLST                             /* LNKLST information    */
    Call APF                                /* APF List information  */
    Call SVC                                /* SVC information       */
  End /* when OPTION = 'ALL' */
  When Abbrev('VERSION',OPTION,3)  = 1 then call VERSION
  When Abbrev('STORAGE',OPTION,3)  = 1 then call STOR
  When Abbrev('STORE',OPTION,3)    = 1 then call STOR
  When Abbrev('MEMORY',OPTION,3)   = 1 then call STOR
  When Abbrev('SYMBOLS',OPTION,3)  = 1 then call SYMBOLS
  When Abbrev('VMAP',OPTION,3)     = 1 then call VMAP
  When Abbrev('ASM',OPTION,3)      = 1 then call PAGE
  When Abbrev('AUX',OPTION,3)      = 1 then call PAGE
  When Abbrev('SSI',OPTION,3)      = 1 then call SUB
  When Abbrev('SSN',OPTION,3)      = 1 then call SUB
  When Abbrev('SUBSYSTEMS',OPTION,3) = 1 then call SUB
  When Abbrev('PAGE',OPTION,3)     = 1 then call PAGE
  When Abbrev('ASID',OPTION,3)     = 1 then call ASID
  When Abbrev('ASVT',OPTION,3)     = 1 then call ASID
  When Abbrev('LNKLST',OPTION,3)   = 1 then call LNKLST
  When Abbrev('LINKLIST',OPTION,3) = 1 then call LNKLST
  Otherwise interpret "Call" OPTION
End /* select */
/*********************************************************************/
/* Done looking at all control blocks                                */
/*********************************************************************/
/*********************************************************************/
/* IPLINFO called as a function with an alternate delimiter.         */
/* Return variable names and exit                                    */
/*********************************************************************/
If Substr(OPTION,1,4) = 'VAR2' & EXEC_TYPE='FUNCTION' then do
  "DROPBUF"                                   /* remove data stack   */
  FUNCDLM  = VAR.1                            /* function delimiter  */
  ALL_VARS = Value(VAR.2)                     /* at least one var    */
  Do V = 3 to 21                              /* check for others    */
    If VAR.V = '' then leave                  /* done, leave loop    */
    Else ALL_VARS = ALL_VARS !! ,             /* concat additional   */
                   FUNCDLM !! Value(VAR.V)    /*  var + dlm at end   */
  End  /* end Do V */
  Return ALL_VARS                             /* return vars         */
End
/*********************************************************************/
/* IPLINFO called as a function. Return variable names and exit      */
/*********************************************************************/
If Substr(OPTION,1,3) = 'VAR' & EXEC_TYPE='FUNCTION' then do
  "DROPBUF"                                   /* remove data stack   */
  ALL_VARS = Value(VAR.1)                     /* at least one var    */
  Do V = 2 to 20                              /* check for others    */
    If VAR.V = '' then leave                  /* done, leave loop    */
    Else ALL_VARS = ALL_VARS !! ,             /* concat additional   */
                   FUNCDLM !! Value(VAR.V)    /*  var + dlm at end   */
  End  /* end Do V */
  Return ALL_VARS                             /* return vars         */
End
/*********************************************************************/
/* If ISPF is active and the BROWSEOP option is set (default) then   */
/* browse the output - otherwise write to the terminal               */
/*********************************************************************/
If SYSISPF = 'ACTIVE' & BROWSEOP = 'YES' ,   /* ISPF active and      */
 then call BROWSE_ISPF                       /* BROWSEOP option set? */
Else do queued()                             /* ISPF is not active   */
  Parse pull line                            /* pull queued lines    */
  Say line                                   /* say lines            */
End /* else do  */
Exit 0                                       /* End IPLINFO - RC 0   */
/*********************************************************************/
/*  End of main IPLINFO code                                         */
/*********************************************************************/
/*********************************************************************/
/*  Start of sub-routines                                            */
/*********************************************************************/
INVALID_OPTION:      /* Invalid option sub-routine                   */
If SYSISPF = 'ACTIVE' then do
  Queue ' '
  Queue '   ******************************************************'
  If OPTION <> '?' then,
    Queue '   *            Invalid IPLINFO option.                 *'
  Queue '   *   Please hit PF1/HELP two times for valid options. *'
  Queue '   ******************************************************'
  Queue ' '
  OPTION = 'Invalid'
  Call BROWSE_ISPF
  Exit 16
  End
Else do
  Call CKWEB                               /* call CKWEB sub-routine */
  Say Copies('*',79)
  Say " "
  If OPTION <> '?' then,
    Say "Invalid IPLINFO option."
  Say " "
  Say "EXECUTION SYNTAX: %IPLINFO <option>"
  Say " "
  Say "VALID OPTIONS ARE 'ALL', 'IPL', 'VERsion'," ,
      "'STOrage', 'CPU', 'IPA', 'SYMbols',"
  Say " 'VMAp', 'PAGe', 'SMF', 'SUB'," ,
      "'ASId', 'LPA', 'LNKlst' or 'LINklist' and 'APF'"
  Say " "
  Say "** 'ALL' is the default option"
  Say "** OPTIONS may be abbreviated by using 3 or more characters"
  Say " "
  Say Copies('*',79)
  If OPTION = '?' then Exit 0
    Else exit 16
End
return

HEADING:             /* Heading sub-routine                          */
Call CKWEB                                 /* call CKWEB sub-routine */
Call RDATE 'TODAY'                         /* call RDATE sub-routine */
DAY      = Word(RESULT,3)                  /* weekday from RDATE     */
MMT      = Substr(RESULT,1,2)              /* MM from MM/DD/YYYY     */
DDT      = Substr(RESULT,4,2)              /* DD from MM/DD/YYYY     */
YYYYT    = Substr(RESULT,7,4)              /* YYYY from MM/DD/YYYY   */
If DATEFMT = 'USA' then ,                  /* USA format date?       */
  DATE     = Substr(RESULT,1,10)           /* date as MM/DD/YYYY     */
If DATEFMT = 'EUR' then ,                  /* EUR format date?       */
  DATE     = DDT'/'MMT'/'YYYYT             /* date as DD/MM/YYYY     */
If DATEFMT = 'ISO' then ,                  /* ISO format date?       */
  DATE     = YYYYT'-'MMT'-'DDT             /* date as YYYY-MM-DD     */
JUL      = Substr(RESULT,7,8)              /* date as YYYY.DDD       */
CURNNNNN = Substr(RESULT,16,5)             /* date as NNNNN          */
Queue Copies('*',79)
Queue Copies('*',15) !! ,
      Center('IPLINFO - SYSTEM INFORMATION FOR' GRSNAME,49) !! ,
      Copies('*',15)
Queue Copies('*',79)
Queue ' '
Queue 'Today is 'DAY DATE '('JUL'). The local time is 'TIME()'.'
Return

CKWEB:         /* Create HTML needed for web page output sub-routine */
If ENV = 'OMVS' then do                    /* Are we under OMVS?     */
  Do CKWEB = __ENVIRONMENT.0 to 1 by -1    /* check env. vars        */
     If pos('HTTP_',__ENVIRONMENT.CKWEB) <> 0 then do  /* web server */
       Say 'Content-type: text/html'
       Say ''
       Say '<title>Mark''s MVS Utilities - IPLINFO</title>'
       Say '<meta name="author" content="Mark Zelden -' ,
           'mark@mzelden.com">'
       Say '<meta name="description" content="' !! ,
           'IPLINFO -' OPTION 'option.' ,
           'Last updated on' LASTUPD !!'. Written by' ,
           'Mark Zelden. Mark''s MVS Utilities -' ,
           'http://www.mzelden.com/mvsutil.html">'
       Say '<meta http-equiv="pragma" content="no-cache">'
       Say '<body BGCOLOR="#000000" TEXT="#00FFFF">'
       Say '<pre>'
       Leave                               /* exit loop              */
     End /* if pos */
  End /* do CKWEB */
End
Return

COMMON:              /* Control blocks needed by multiple routines   */
CVT      = C2d(Storage(10,4))                /* point to CVT         */
CVTFLAG2 = Storage(D2x(CVT+377),1)           /* CVT flag byte 2      */
CVTEXT2  = C2d(Storage(D2x(CVT + 328),4))    /* point to CVTEXT2     */
PRODNAME = Storage(D2x(CVT - 40),7)          /* point to mvs version */
If Substr(PRODNAME,3,1) >= 3 then do         /* HBB3310 ESA V3 & >   */
  CVTOSLV0   = Storage(D2x(CVT + 1264),1)    /* Byte 0 of CVTOSLVL   */
  CVTOSLV1   = Storage(D2x(CVT + 1265),1)    /* Byte 1 of CVTOSLVL   */
  CVTOSLV2   = Storage(D2x(CVT + 1266),1)    /* Byte 2 of CVTOSLVL   */
  CVTOSLV3   = Storage(D2x(CVT + 1267),1)    /* Byte 3 of CVTOSLVL   */
  CVTOSLV4   = Storage(D2x(CVT + 1268),1)    /* Byte 4 of CVTOSLVL   */
  CVTOSLV5   = Storage(D2x(CVT + 1269),1)    /* Byte 5 of CVTOSLVL   */
  CVTOSLV6   = Storage(D2x(CVT + 1270),1)    /* Byte 6 of CVTOSLVL   */
  CVTOSLV7   = Storage(D2x(CVT + 1271),1)    /* Byte 7 of CVTOSLVL   */
  CVTOSLV8   = Storage(D2x(CVT + 1272),1)    /* Byte 8 of CVTOSLVL   */
  CVTOSLV9   = Storage(D2x(CVT + 1273),1)    /* Byte 9 of CVTOSLVL   */
End
If Bitand(CVTOSLV0,'08'x) = '08'x then ,     /* HBB4410 ESA V4 & >   */
  ECVT     = C2d(Storage(D2x(CVT + 140),4))  /* point to CVTECVT     */
FMIDNUM  = Storage(D2x(CVT - 32),7)          /* point to fmid        */
JESCT    = C2d(Storage(D2x(CVT + 296),4))    /* point to JESCT       */
JESCTEXT = C2d(Storage(D2x(JESCT +100),4))   /* point to JESPEXT     */
JESPJESN = Storage(D2x(JESCT + 28),4)        /* name of primary JES  */
CVTSNAME = Storage(D2x(CVT + 340),8)         /* point to system name */
GRSNAME  = Strip(CVTSNAME,'T')               /* del trailing blanks  */
CSD      = C2d(Storage(D2x(CVT + 660),4))    /* point to CSD         */
SMCA     = Storage(D2x(CVT + 196),4)         /* point to SMCA        */
SMCA     = Bitand(SMCA,'7FFFFFFF'x)          /* zero high order bit  */
SMCA     = C2d(SMCA)                         /* convert to decimal   */
ASMVT    = C2d(Storage(D2x(CVT + 704),4))    /* point to ASMVT       */
CVTSCPIN = D2x(CVT+832)                      /* point to SCPINFO     */
If Bitand(CVTOSLV5,'08'x) = '08'x then do    /* z/OS 1.10 and above  */
  ECVTSCPIN = D2x(ECVT+876)                  /* point to cur SCPINFO */
  SCCB      = C2d(Storage(ECVTSCPIN,4))      /* Service Call Cntl Blk*/
End
Else SCCB   = C2d(Storage(CVTSCPIN,4))       /* Service Call Cntl Blk*/
RCE      = C2d(Storage(D2x(CVT + 1168),4))   /* point to RCE         */
MODEL    = C2d(Storage(D2x(CVT - 6),2))      /* point to cpu model   */
/*********************************************************************/
/*  The CPU model is stored in packed decimal format with no sign,   */
/*  so to make the model printable, it needs to be converted back    */
/*  to hex.                                                          */
/*********************************************************************/
MODEL    = D2x(MODEL)                        /* convert back to hex  */
PCCAVT    = C2d(Storage(D2x(CVT + 764),4))   /* point to PCCA vect tb*/
If Bitand(CVTOSLV1,'01'x) = '01'x then do    /* OS/390 R2 and above  */
  ECVTIPA  = C2d(Storage(D2x(ECVT + 392),4)) /* point to IPA         */
  IPASCAT  = Storage(D2x(ECVTIPA + 224),63)  /* SYSCAT  card image   */
End
zARCH = 1                                    /* default ARCHLVL      */
If Bitand(CVTOSLV2,'01'x) = '01'x then do    /* OS/390 R10 and above */
  FLCARCH  = Storage('A3',1)                 /* FLCARCH in PSA       */
  If C2d(FLCARCH) <> 0 then zARCH=2          /* non-zero is z/Arch.  */
End
Return

IPL:                 /* IPL information sub-routine                  */
Queue ' '
/*********************************************************************/
/*  The IPL date is stored in packed decimal format - so to make     */
/*  the date printable, it needs to be converted back to hex and     */
/*  the packed sign needs to be removed.                             */
/*********************************************************************/
/*  Converting binary fields to time of day format is described      */
/*  in the MVS SMF manual.                                           */
/*********************************************************************/
IPLTIME  = C2d(Storage(D2x(SMCA + 336),4))   /* IPL Time - binary    */
IPLDATE  = C2d(Storage(D2x(SMCA + 340),4))   /* IPL Date - 0CYYDDDF  */
If IPLDATE  >= 16777231 then do              /*          is C = 1 ?  */
  IPLDATE  = D2x(IPLDATE)                    /* convert back to hex  */
  IPLDATE  = Substr(IPLDATE,2,5)             /* keep YYDDD           */
  IPLDATE  = '20'IPLDATE                     /* use 21st century date*/
End
Else do
  IPLDATE  = D2x(IPLDATE)                    /* convert back to hex  */
  IPLDATE  = Left(IPLDATE,5)                 /* keep YYDDD           */
  IPLDATE  = '19'IPLDATE                     /* use 20th century date*/
End
IPLYYYY  = Substr(IPLDATE,1,4)               /* YYYY portion of date */
IPLDDD   = Substr(IPLDATE,5,3)               /* DDD  portion of date */
Call RDATE IPLYYYY IPLDDD                    /* call RDATE subroutine*/
IPLDAY   = Word(RESULT,3)                    /* weekday from RDATE   */
MMI      = Substr(RESULT,1,2)                /* MM from MM/DD/YYYY   */
DDI      = Substr(RESULT,4,2)                /* DD from MM/DD/YYYY   */
YYYYI    = Substr(RESULT,7,4)                /* YYYY from MM/DD/YYYY */
If DATEFMT = 'USA' then ,                    /* USA format date?     */
  IPLDATE  = Substr(RESULT,1,10)             /* date as MM/DD/YYYY   */
If DATEFMT = 'EUR' then ,                    /* EUR format date?     */
  IPLDATE  = DDI'/'MMI'/'YYYYI               /* date as DD/MM/YYYY   */
If DATEFMT = 'ISO' then ,                    /* ISO format date?     */
  IPLDATE  = YYYYI'-'MMI'-'DDI               /* date as YYYY-MM-DD   */
IPLJUL   = Substr(RESULT,7,8)                /* date as YYYY.DDD     */
IPLNNNNN = Substr(RESULT,16,5)               /* date as NNNNN        */
IPLHH    = Right(IPLTIME%100%3600,2,'0')     /* IPL hour             */
IPLMM    = Right(IPLTIME%100//3600%60,2,'0') /* IPL minute           */
IPLSS    = Right(IPLTIME%100//60,2,'0')      /* IPL seconds          */
IPLTIME  = IPLHH':'IPLMM':'IPLSS             /* time in HH:MM:SS     */
/*                                                                   */
ASMFLAG2 = Storage(D2x(ASMVT + 1),1)         /* point to ASMFLAG2    */
If Bitand(ASMFLAG2,'08'x) = '08'x then ,     /* Check ASMQUICK bit   */
  IPLCLPA    = 'without CLPA'                /* bit on  - no CLPA    */
Else IPLCLPA = 'with CLPA'                   /* bit off - CLPA       */
RESUCB   = C2d(Storage(D2x(JESCT + 4),4))    /* point to SYSRES UCB  */
IPLVOL   = Storage(D2x(RESUCB + 28),6)       /* point to IPL volume  */
If Bitand(CVTOSLV1,'20'x) <> '20'x then ,    /* Below HBB5510 ESA V5 */
  IPLADDR  = Storage(D2x(RESUCB + 13),3)     /* point to IPL address */
Else do
  CVTSYSAD = C2d(Storage(D2x(CVT + 48),4))   /* point to UCB address */
  IPLADDR  = Storage(D2x(CVTSYSAD + 4),2)    /* point to IPL UCB     */
  IPLADDR  = C2x(IPLADDR)                    /* convert to EBCDIC    */
End
SMFNAME  = Storage(D2x(SMCA + 16),4)         /* point to SMF name    */
SMFNAME  = Strip(SMFNAME,'T')                /* del trailing blanks  */
AMCBS    = C2d(Storage(D2x(CVT + 256),4))    /* point to AMCBS       */
If Bitand(CVTOSLV2,'80'x) <> '80'x then do   /*Use CAXWA B4 OS/390 R4*/
  ACB      = C2d(Storage(D2x(AMCBS + 8),4))  /* point to ACB         */
  CAXWA    = C2d(Storage(D2x(ACB + 64),4))   /* point to CAXWA       */
  MCATDSN  = Storage(D2x(CAXWA + 52),44)     /* master catalog dsn   */
  MCATDSN  = Strip(MCATDSN,'T')              /* remove trailing blnks*/
  MCATUCB  = C2d(Storage(D2x(CAXWA + 28),4)) /* point to mcat UCB    */
  MCATVOL  = Storage(D2x(MCATUCB + 28),6)    /* master catalog VOLSER*/
End
Else do                                      /* OS/390 R4 and above  */
  MCATDSN  = Strip(Substr(IPASCAT,11,44))    /* master catalog dsn   */
  MCATVOL  = Substr(IPASCAT,1,6)             /* master catalog VOLSER*/
  IPASCANL = Storage(d2x(ECVTIPA+231),1)     /* mcat alias level     */
  IPASCTYP = Storage(d2x(ECVTIPA+230),1)     /* mcat catalog type    */
  AMCBSFLG = Storage(D2x(AMCBS + 96),1)      /* AMCBS flags          */
  AMCBSALV = C2d(Storage(D2x(AMCBS + 155),1)) /* AMCBS - alias level */
  If IPASCANL = ' ' then IPASCANL = 1  /* SYSCAT col 17 blank / dflt */
  If IPASCTYP = ' ' then IPASCTYP = 1  /* SYSCAT col 16 blank / dflt */
  CTYP.0   = 'VSAM'
  CTYP.1   = 'ICF. SYS%-SYS1 conversion was not active at IPL time'
  CTYP.2   = 'ICF. SYS%-SYS1 conversion was active at IPL time'
End
Queue 'The last IPL was 'IPLDAY IPLDATE '('IPLJUL')' ,
      'at 'IPLTIME' ('CURNNNNN - IPLNNNNN' days ago).'
Queue 'The IPL was done 'IPLCLPA'.'
Queue 'The system IPL address was 'IPLADDR' ('IPLVOL').'
If Bitand(CVTOSLV0,'08'x) = '08'x then do    /* HBB4410 ESA V4 1 & > */
  ECVTSPLX = Storage(D2x(ECVT+8),8)          /* point to SYSPLEX name*/
  ECVTLOAD = Storage(D2x(ECVT+160),8)        /* point to LOAD PARM   */
  IPLPARM  = Strip(ECVTLOAD,'T')             /* del trailing blanks  */
  SEPPARM  = Substr(IPLPARM,1,4) Substr(IPLPARM,5,2),
             Substr(IPLPARM,7,1) Substr(IPLPARM,8,1)
  SEPPARM  = Strip(SEPPARM,'T')              /* del trailing blanks  */
  Queue 'The IPL LOAD PARM used was 'IPLPARM' ('SEPPARM').'
  If Bitand(CVTOSLV1,'20'x) = '20'x then do  /* HBB5510 ESA V5 & >   */
    CVTIXAVL = C2d(Storage(D2x(CVT+124),4))      /* point to IOCM    */
    IOCIOVTP = C2d(Storage(D2x(CVTIXAVL+208),4)) /* IOS Vector Table */
    CDA      = C2d(Storage(D2x(IOCIOVTP+24),4))  /* point to CDA     */
  End
  CVTTZ      = Storage(D2x(CVT + 304),4)     /* point to cvttz       */
  CKTZBYTE   = Storage(D2x(CVT + 304),1)     /* need to chk 1st byte */
  If bitand(CKTZBYTE,'80'x) = '80'x then ,   /* chk for negative     */
    CVTTZ    = C2d(CVTTZ,4)                  /* negative offset C2d  */
  Else CVTTZ = C2d(CVTTZ)                    /* postitive offset C2d */
  CVTTZ      = CVTTZ * 1.048576 / 3600       /* convert to hours     */
  If Format(CVTTZ,3,1) = Format(CVTTZ,3,0) , /* don't use decimal if */
   then CVTTZ = Strip(Format(CVTTZ,3,0))     /* not needed           */
  Else  CVTTZ = Strip(Format(CVTTZ,3,1))     /* display 1 decimal    */
  Queue 'The local time offset from GMT time is' CVTTZ 'hours.'
  If Bitand(CVTOSLV1,'10'x) = '10'x then do  /* HBB5520 ESA V5.2 & > */
    ECVTHDNM = Storage(D2x(ECVT+336),8)      /* point to hardware nam*/
    ECVTLPNM = Storage(D2x(ECVT+344),8)      /* point to LPAR name   */
    If Bitand(CVTOSLV2,'01'x) = '01'x then do  /* OS/390 R10 & above */
      MIFID    = C2d(Storage(D2X(CDA+252),1))  /* MIF ID in decimal  */
      MIFID    = D2x(MIFID)                    /* MIF ID in hex      */
      If Bitand(CVTOSLV3,'04'x) = '04'x then do /* z/OS 1.4 and above*/
        IOCCSSID = C2d(Storage(d2x(CVTIXAVL+275),1))
        IOCCSSID = D2x(IOCCSSID)                /* CSS ID in hex     */
      End
      If zARCH = 2 then ,                    /* z/Architechture      */
        Queue 'The system is running in z/Architecture mode' ,
               '(ARCHLVL = 2).'
      Else ,                                 /* ESA/390 mode         */
        Queue 'The system is running in ESA/390 mode (ARCHLVL = 1).'
    End /* If Bitand(CVTOSLV2,'01'x) = '01'x */
    If ECVTHDNM <> ' ' & ECVTLPNM <> ' ' then do
      CSDPLPN  = C2d(Storage(D2x(CSD + 252),1))    /* point to LPAR #*/
   /* CSDPLPN not valid for z990 (T-REX) or z890 for LPAR number     */
      CPOFF = 0  /* init offset to next PCCA entry                   */
      PCCA  = 0  /* init PCCA to 0                                   */
      Do until PCCA <> 0   /* do until we find a valid PCCA          */
        PCCA = C2d(Storage(D2x(PCCAVT + CPOFF),4)) /* point to PCCA  */
        If PCCA <> 0 then do
          LPAR_#  = X2d(Storage(D2x(PCCA + 6),2))  /* LPAR # in hex  */
          LPAR_#  = D2x(LPAR_#)                    /* display as hex */
        End /* if PCCA <> 0 */
        Else CPOFF = CPOFF + 4  /* bump up offset for next PCCA      */
      End /* do until PCCA <> 0 */
      If Bitand(CVTOSLV2,'01'x) = '01'x then do    /* OS/390 R10 & > */
        Queue 'The Processor name is' Strip(ECVTHDNM)'.' ,
               'The LPAR name is' Strip(ECVTLPNM)'.'
        If Bitand(CVTOSLV3,'04'x) = '04'x then  /* z/OS 1.4 and above*/
          Queue ' ' Strip(ECVTLPNM) 'is (HMC defined) LPAR ID =' ,
                LPAR_#', MIF ID =' mifid 'and CSS ID = 'IOCCSSID'.'
        Else ,
          Queue ' ' Strip(ECVTLPNM) 'is (HMC defined) LPAR ID =' ,
                LPAR_# 'and MIF ID =' mifid'.'
        Queue ' ' Strip(ECVTLPNM) 'is PR/SM partition number' ,
                   CSDPLPN' (internal value from the CSD).'
      End /* If Bitand(CVTOSLV2,'01'x) = '01'x */
      Else ,
        Queue 'The Processor name is' Strip(ECVTHDNM)'.' ,
               'The LPAR name is' Strip(ECVTLPNM)' (LPAR #'CSDPLPN').'
    End  /* If ECVTHDNM <> ' ' & ECVTLPNM <> ' '   */
    Else if ECVTHDNM <> ' ' then ,
      Queue 'The Processor name is' Strip(ECVTHDNM)'.'
    If Bitand(CVTOSLV1,'20'x) = '20'x ,   /* HBB5510 ESA V5 & above  */
       & ECVTSPLX <> 'LOCAL' then do      /* and not a local sysplex */
      JESDSNID = X2d(Storage(D2x(JESCTEXT+120),2)) /*ID for temp dsns*/
      Queue 'The sysplex name is' Strip(ECVTSPLX)'. This was system' ,
            'number' Format(JESDSNID) 'added to the sysplex.'
    End /* If Bitand(CVTOSLV1,'20'x) = '20'x */
    Else queue 'The sysplex name is' Strip(ECVTSPLX)'.'
  End  /* If Bitand(CVTOSLV1,'10'x) = '10'x */
End
Queue 'The GRS system id (SYSNAME) is 'GRSNAME'.'
If Bitand(CVTOSLV1,'10'x) = '10'x then do  /* HBB5520 ESA V5.2 & > */
  ECVTGMOD   = C2d(Storage(D2x(ECVT + 266),1)) /* GRS mode         */
  GMOD.0     = "NONE"  /* Stem for GRS mode: ECVTGNON EQU 0        */
  GMOD.1     = "RING"  /* Stem for GRS mode: ECVTGRNG EQU 1        */
  GMOD.2     = "STAR"  /* Stem for GRS mode: ECVTGSTA EQU 2        */
  Queue '  The GRS mode is' GMOD.ECVTGMOD' (NONE, RING or STAR).'
End
Queue 'The SMF system id (SID) is 'SMFNAME'.'
If Bitand(CVTOSLV1,'20'x) <> '20'x then do   /* Below HBB5510 ESA V5 */
  IOCON    = Storage(D2x(CVTEXT2 + 6),2)       /* HCD IODFxx or MVSCP*/
                                               /* IOCONFIG ID=xx     */
  Queue 'The currently active IOCONFIG or HCD IODF is 'IOCON'.'
End
Else do
  IODF     = Storage(D2X(CDA+32),44)           /* point to IODF name */
  IODF     = Strip(IODF,'T')                   /* del trailing blanks*/
  CONFIGID = Storage(D2X(CDA+92),8)            /* point to CONFIG    */
  EDT      = Storage(D2X(CDA+104),2)           /* point to EDT       */
  IOPROC   = Storage(D2X(CDA+124),8)           /* point to IODF Proc */
  IODATE   = Storage(D2X(CDA+156),8)           /* point to IODF date */
  IOTIME   = Storage(D2X(CDA+164),8)           /* point to IODF time */
  IODESC   = Storage(D2X(CDA+172),16)          /* point to IODF desc */
  Queue 'The currently active IODF data set is 'IODF'.'
  Queue '  Configuration ID =' CONFIGID ' EDT ID =' EDT
  If Substr(IOPROC,1,1) <> '00'x  & ,
     Substr(IOPROC,1,1) <> '40'x then do       /* is token there?    */
    Queue '  TOKEN: Processor  Date      Time      Description'
    Queue '         'IOPROC'   'IODATE'  'IOTIME'  'IODESC
  End
End
Queue 'The Master Catalog is 'MCATDSN' on 'MCATVOL'.'
If Bitand(CVTOSLV2,'80'x) = '80'x then do    /* OS/390 R4 and above  */
 Queue '  The catalog alias level was 'IPASCANL' at IPL time.'
 Queue '    The catalog alias level is currently' AMCBSALV'.'
 Queue '  The catalog type is 'CTYP.IPASCTYP'.'
 If Bitand(AMCBSFLG,'40'x) = '40'x then ,
   Queue '    SYS%-SYS1 conversion is currently active.'
 Else ,
   Queue '    SYS%-SYS1 conversion is not currently active.'
End
/*If OPTION = 'IPL' then interpret call 'VERSION' */ /* incl version*/
Return

VERSION:             /* Version information sub-routine              */
Queue ' '
Call SUB 'FINDJES'   /* call SUB routine with FINDJES option         */
If JESPJESN = 'JES3' then do                 /* Is this JES3?        */
  If ENV = 'OMVS' then do  /* running under Unix System Services     */
    JES3FMID = Storage(D2x(JESSSVT+644),8)      /* JES3 FMID         */
    Select  /* determine JES3 version from FMID  */
      When JES3FMID = 'HJS5521' then JESLEV = 'SP 5.2.1'
      When JES3FMID = 'HJS6601' then JESLEV = 'OS 1.1.0'
      When JES3FMID = 'HJS6604' then JESLEV = 'OS 2.4.0'
      When JES3FMID = 'HJS6606' then JESLEV = 'OS 2.6.0'
      When JES3FMID = 'HJS6608' then JESLEV = 'OS 2.8.0'
      When JES3FMID = 'HJS6609' then JESLEV = 'OS 2.9.0'
      When JES3FMID = 'HJS7703' then JESLEV = 'OS 2.10.0'
      When JES3FMID = 'HJS7705' then JESLEV = 'z 1.2.0'
      When JES3FMID = 'HJS7707' then JESLEV = 'z 1.4.0'
      When JES3FMID = 'HJS7708' then JESLEV = 'z 1.5.0'
      When JES3FMID = 'HJS7720' then JESLEV = 'z 1.7.0'
      When JES3FMID = 'HJS7730' then JESLEV = 'z 1.8.0'
      When JES3FMID = 'HJS7740' then JESLEV = 'z 1.9.0'
      When JES3FMID = 'HJS7750' then JESLEV = 'z 1.10.0'
      When JES3FMID = 'HJS7760' then JESLEV = 'z 1.11.0'
      When JES3FMID = 'HJS7770' then JESLEV = 'z 1.12.0'
      When JES3FMID = 'HJS7780' then JESLEV = 'z 1.13.0'
      When JES3FMID = 'HJS7790' then JESLEV = 'z 2.1.0'
      When JES3FMID = 'HJS77A0' then JESLEV = 'z 2.2.0'
      When JES3FMID = 'HJS77B0' then JESLEV = 'z 2.3.0'
      When JES3FMID = 'HJS77C0' then JESLEV = 'z 2.4.0'
      Otherwise JESLEV = JES3FMID /* if not in tbl, use FMID as ver  */
    End /* select */
    JESNODE  = '*not_avail*'                 /* can't do under USS   */
  End /* if env = 'omvs' */
  Else do /* if not running under Unix System Services, use TSO VARs */
    JESLEV   = SYSVAR('SYSJES')              /* TSO/E VAR for JESLVL */
    JESNODE  = SYSVAR('SYSNODE')             /* TSO/E VAR for JESNODE*/
  End
End
Else do  /* JES2 */
  JESLEV   = Strip(Storage(D2x(JESSUSE),8))  /* JES2 Version         */
  /* offset in $HCCT - CCTNDENM */
  Select
    When Substr(JESLEV,1,8) == 'z/OS 2.4' then, /* z/OS 2.4          */
      JESNODE  = Strip(Storage(D2x(JESSUS2+696),8)) /* JES2 NODE     */
    When Substr(JESLEV,1,8) == 'z/OS 2.3' ! ,   /* z/OS 2.3          */
      Substr(JESLEV,1,8) == 'z/OS 2.2'  then,   /* z/OS 2.2          */
      JESNODE  = Strip(Storage(D2x(JESSUS2+664),8)) /* JES2 NODE     */
    When Substr(JESLEV,1,8) == 'z/OS 2.1' ! ,   /* z/OS 2.1          */
      Substr(JESLEV,1,8) == 'z/OS1.13'    ! ,   /* z/OS 1.13         */
      Substr(JESLEV,1,8) == 'z/OS1.12'    ! ,   /* z/OS 1.12         */
      Substr(JESLEV,1,8) == 'z/OS1.11'  then,   /* z/OS 1.11         */
      JESNODE  = Strip(Storage(D2x(JESSUS2+656),8)) /* JES2 NODE     */
    When Substr(JESLEV,1,8) == 'z/OS1.10' ! ,  /* z/OS 1.10          */
      Substr(JESLEV,1,8) == 'z/OS 1.9' then,    /* z/OS 1.9          */
      JESNODE  = Strip(Storage(D2x(JESSUS2+708),8)) /* JES2 NODE     */
    When Substr(JESLEV,1,8) == 'z/OS 1.8' then, /* z/OS 1.8          */
      JESNODE  = Strip(Storage(D2x(JESSUS2+620),8)) /* JES2 NODE     */
    When Substr(JESLEV,1,8) == 'z/OS 1.7' then, /* z/OS 1.7          */
      JESNODE  = Strip(Storage(D2x(JESSUS2+616),8)) /* JES2 NODE     */
    When Substr(JESLEV,1,8) == 'z/OS 1.5' ! , /* z/OS 1.5 & 1.6      */
      Substr(JESLEV,1,8) == 'z/OS 1.4' then   /* z/OS 1.4            */
      JESNODE  = Strip(Storage(D2x(JESSUS2+532),8)) /* JES2 NODE     */
    When Substr(JESLEV,1,7) == 'OS 2.10' ! ,  /* OS/390 2.10 and     */
      Substr(JESLEV,1,8) == 'z/OS 1.2' then,  /* z/OS 1.2            */
      JESNODE  = Strip(Storage(D2x(JESSUS2+452),8)) /* JES2 NODE     */
    When Substr(JESLEV,1,6) == 'OS 1.1' ! , /* OS/390 1.1  or        */
      Substr(JESLEV,1,4) == 'SP 5' then ,    /* ESA V5 JES2          */
      JESNODE  = Strip(Storage(D2x(JESSUS2+336),8)) /*   JES2 NODE   */
    When Substr(JESLEV,1,5) == 'OS 1.' ! ,   /* OS/390 1.2           */
      Substr(JESLEV,1,5) == 'OS 2.' then,    /*  through OS/390 2.9  */
      JESNODE  = Strip(Storage(D2x(JESSUS2+372),8)) /* JES2 NODE     */
    Otherwise ,                              /* Lower than ESA V5    */
      If ENV = 'OMVS' then JESNODE = '*not_avail*'
      else JESNODE  = SYSVAR('SYSNODE')      /* TSO/E VAR for JESNODE*/
  End  /* select */
End /* else do */
/*                                                                   */
CVTVERID = Storage(D2x(CVT - 24),16)         /* "user" software vers.*/
CVTRAC   = C2d(Storage(D2x(CVT + 992),4))    /* point to RACF CVT    */
RCVT     = CVTRAC                            /* use RCVT name        */
RCVTID   = Storage(D2x(RCVT),4)              /* point to RCVTID      */
                                             /* RCVT, ACF2, or RTSS  */
SECNAM = RCVTID                              /* ACF2 SECNAME = RCVTID*/
If RCVTID = 'RCVT' then SECNAM = 'RACF'      /* RCVT is RACF         */
If RCVTID = 'RTSS' then SECNAM = 'Top Secret'  /* RTSS is Top Secret */
RACFVRM  = Storage(D2x(RCVT + 616),4)        /* RACF Ver/Rel/Mod     */
RACFVER  = Substr(RACFVRM,1,1)               /* RACF Version         */
RACFREL  = Substr(RACFVRM,2,2)               /* RACF Release         */
If Bitand(CVTOSLV2,'01'x) <> '01'x then ,    /* below OS/390 R10     */
  RACFREL  = Format(RACFREL)                 /* Remove leading 0     */
RACFMOD  = Substr(RACFVRM,4,1)               /* RACF MOD level       */
RACFLEV  = RACFVER !! '.' !! RACFREL !! '.' !! RACFMOD
If RCVTID = 'RCVT' ! RCVTID = 'RTSS' then ,
 RCVTDSN = Strip(Storage(D2x(RCVT + 56),44))    /* RACF prim dsn or  */
                                                /* TSS Security File */
If SECNAM = 'ACF2' then do
  SSCVT    = C2d(Storage(D2x(JESCT+24),4))   /* point to SSCVT       */
  Do while SSCVT <> 0
    SSCTSNAM = Storage(D2x(SSCVT+8),4)       /* subsystem name       */
    If SSCTSNAM = 'ACF2' then do
      ACCVT    = C2d(Storage(D2x(SSCVT + 20),4)) /* ACF2 CVT         */
      ACCPFXP  = C2d(Storage(D2x(ACCVT - 4),4))  /* ACCVT prefix     */
      ACCPIDL  = C2d(Storage(D2x(ACCPFXP + 8),2))  /* Len ident area */
      LEN_ID   = ACCPIDL-4 /* don't count ACCPIDL and ACCPIDO in len */
      ACCPIDS  = Strip(Storage(D2x(ACCPFXP + 12),LEN_ID)) /*sys ident*/
      ACF2DSNS = C2d(Storage(D2x(ACCVT + 252) ,4)) /* ACF2 DSNs      */
      ACF2DNUM = C2d(Storage(D2x(ACF2DSNS + 16),2)) /* # OF DSNs     */
      Leave
    End
  SSCVT    = C2d(Storage(D2x(SSCVT+4),4))    /* next sscvt or zero   */
  End  /*  Do while SSCVT <> 0 */
End
/*                                                                   */
CVTDFA   = C2d(Storage(D2x(CVT + 1216),4))   /* point to DFP ID table*/
DFAPROD  = C2d(Storage(D2x(CVTDFA +16),1))   /* point to product byte*/
If DFAPROD = 0 then do                       /* DFP not DF/SMS       */
  DFAREL   = C2x(Storage(D2x(CVTDFA+2),2))   /* point to DFP release */
  DFPVER   = Substr(DFAREL,1,1)              /* DFP Version          */
  DFPREL   = Substr(DFAREL,2,1)              /* DFP Release          */
  DFPMOD   = Substr(DFAREL,3,1)              /* DFP Mod Lvl          */
  DFPRD    = 'DFP'                           /* product is DFP       */
  DFLEV    = DFPVER !! '.' !! DFPREL !! '.' !! DFPMOD
End
Else do                                      /* DFSMS not DFP        */
  DFARELS  = C2x(Storage(D2x(CVTDFA+16),4))  /* point to DF/SMS rel  */
  DFAVER   = X2d(Substr(DFARELS,3,2))        /* DF/SMS Version       */
  DFAREL   = X2d(Substr(DFARELS,5,2))        /* DF/SMS Release       */
  DFAMOD   = X2d(Substr(DFARELS,7,2))        /* DF/SMS Mod Lvl       */
  DFPRD    = 'DFSMS'                         /* product is DF/SMS    */
  DFLEV    = DFAVER !! '.' !! DFAREL !! '.' !! DFAMOD
  If DFAPROD = 2 then DFLEV = 'OS/390' DFLEV
  If DFAPROD = 3 then do
    DFLEV    = 'z/OS' DFLEV
    /* Next section of code doesn't work because CRT is in key 5 */
       /*
    CVTCBSP  = C2d(Storage(D2x(CVT + 256),4))      /* point to AMCBS */
    CRT      = C2d(Storage(D2x(CVTCBSP + 124),4))  /* point to CRT   */
    CRTFMID  = Storage(D2x(CRT + 472),7)           /* DFSMS FMID     */
       */
  End /* if DFAPROD = 3 */
  JESSMSIB = C2d(Storage(D2x(JESCTEXT+84),4)) /* point to SMS SSIB   */
  IGDSSIVT = C2d(Storage(D2x(JESSMSIB+32),4))  /* SMS vector table   */
  IGDSMS   = Storage(D2x(IGDSSIVT+132),2)      /* IGDSMSxx suffix    */
  SMSACDS  = Strip(Storage(D2x(IGDSSIVT+44),44))   /* ACDS           */
  SMSCMDS  = Strip(Storage(D2x(IGDSSIVT+88),44))   /* COMMDS         */
End
/*                                                                   */
CVTTVT   = C2d(Storage(D2x(CVT + 156),4))    /* point to TSO vect tbl*/
TSVTLVER = Storage(D2x(CVTTVT+100),1)        /* point to TSO Version */
TSVTLREL = Storage(D2x(CVTTVT+101),2)        /* point to TSO Release */
TSVTLREL = Format(TSVTLREL)                  /* Remove leading 0     */
TSVTLMOD = Storage(D2x(CVTTVT+103),1)        /* point to TSO Mod Lvl */
TSOLEV   = TSVTLVER !! '.' !! TSVTLREL !! '.' !! TSVTLMOD
/*                                                                   */
CHKVTACT = Storage(D2x(CVTEXT2+64),1)        /* VTAM active flag     */
If bitand(CHKVTACT,'80'x) = '80'x then do      /* vtam is active     */
  CVTATCVT = C2d(Storage(D2x(CVTEXT2 + 65),3)) /* point to VTAM AVT  */
  ISTATCVT = C2d(Storage(D2x(CVTATCVT + 0),4)) /* point to VTAM CVT  */
  ATCVTLVL = Storage(D2x(ISTATCVT + 0),8)      /* VTAM Rel Lvl VOVRP */
  VTAMVER  = Substr(ATCVTLVL,3,1)              /* VTAM Version   V   */
  VTAMREL  = Substr(ATCVTLVL,4,1)              /* VTAM Release    R  */
  VTAMMOD  = Substr(ATCVTLVL,5,1)              /* VTAM Mod Lvl     P */
  If VTAMMOD = ' ' then VTAMLEV =  VTAMVER !! '.' !! VTAMREL
    else VTAMLEV =  VTAMVER !! '.' !! VTAMREL !! '.' !! VTAMMOD
/*                                                                   */
  ATCNETID = Strip(Storage(D2x(ISTATCVT + 2080),8))  /* VTAM NETID   */
  ATCNQNAM = Strip(Storage(D2x(ISTATCVT + 2412),17)) /* VTAM SSCPNAME*/
  VTAM_ACTIVE = 'YES'
End /* if bitand (vtam is active) */
Else VTAM_ACTIVE = 'NO'
If Bitand(CVTOSLV1,'80'x) = '80'x then do    /* HBB4430 ESA V4.3 & > */
  ECVTTCP     = D2x(ECVT + 176)              /* TCPIP                */
  TSAB        = C2d(Storage(ECVTTCP,4))      /* point to TSAB        */
  TSABLEN     = C2d(Storage(D2x(TSAB+4),2))  /* Length of TSAB       */
  TSEBNUM     = (TSABLEN - 64) / 128         /* Number of TSEBs      */
  TCPANUM     = 0                            /* counter of act TSEBs */
  TCP_ACTIVE  = 'NO'                         /* Init active flag     */
  Do SCNTSEBS = 1 to TSEBNUM                 /* Scan TSEB loop       */
    TSEB = TSAB + 64 + (SCNTSEBS-1)*128
    TCPASID = C2x(Storage(D2x(TSEB + 56),2)) /* asid or zero         */
    If TCPASID <> 0 then do                  /* active asid          */
      TCP_ACTIVE = 'YES'
      TCPANUM = TCPANUM + 1                /* add 1 to active count  */
      TCPSTATUS           =     Storage(D2x(TSEB +  8),1)
      TCPNAME.TCPANUM     =     Storage(D2x(TSEB + 16),8)
      TCPNUM.TCPANUM      = C2x(Storage(D2x(TSEB + 24),1))
      TCPVER.TCPANUM      = C2x(Storage(D2x(TSEB + 26),2))
      TCPASID.TCPANUM     = TCPASID '('Right(X2d(TCPASID),4)')'
      Select
        When Bitand(TCPSTATUS,'80'x) = '80'x then TCPST = 'Active'
        When Bitand(TCPSTATUS,'40'x) = '40'x then TCPST = 'Terminating'
        When Bitand(TCPSTATUS,'20'x) = '20'x then TCPST = 'Down'
        When Bitand(TCPSTATUS,'10'x) = '10'x then TCPST = 'Stopped'
        Otherwise say 'Bad TCPSTATUS! Contact Mark Zelden' TCPSTATUS
      End /*  select  */
      TCPST.TCPANUM     = TCPST
    End /* If TCPASID <> 0 */
  End /* Do SCNTSEBS = 1 to TSEBNUM */
End /* If Bitand(CVTOSLV1,'80'x) = '80'x */
If Bitand(CVTOSLV1,'02'x) <> '02'x then ,    /* Below OS/390 R1      */
  Queue 'The MVS version is 'PRODNAME' - FMID 'FMIDNUM'.'
Else do
  PRODNAM2 = Storage(D2x(ECVT+496),16)       /* point to product name*/
  PRODNAM2 = Strip(PRODNAM2,'T')             /* del trailing blanks  */
  VER      = Storage(D2x(ECVT+512),2)        /* point to version     */
  REL      = Storage(D2x(ECVT+514),2)        /* point to release     */
  MOD      = Storage(D2x(ECVT+516),2)        /* point to mod level   */
  VRM      = VER'.'REL'.'MOD
  Queue 'The OS version is 'PRODNAM2 VRM' - FMID' ,
         FMIDNUM' ('PRODNAME').'
End
If CVTVERID <> ' ' then ,
  Queue 'The "user" system software version is' Strip(CVTVERID,'T')'.'
Queue 'The primary job entry subsystem is 'JESPJESN'.'
Queue 'The 'JESPJESN 'level is 'JESLEV'.' ,
      'The 'JESPJESN 'node name is 'JESNODE'.'
If SECNAM <> 'RACF' ! RACFVRM < '2608' then do
  Queue 'The security software is 'SECNAM'.'
  If SECNAM = 'ACF2' then do
    Queue 'The ACF2 level is' ACCPIDS'.'
    Queue '  There are 'ACF2DNUM' ACF2 data sets in use:'
    Do ADSNS = 1 to ACF2DNUM
      ADSOFF   = ACF2DSNS + 24 + (ADSNS-1)*64
      ACF2TYPE = Storage(D2x(ADSOFF) , 8)
      ACF2DSN  = Storage(D2x(ADSOFF + 16),44)
      Queue '   ' ACF2TYPE '-' ACF2DSN
    End
  End /* if secname = 'ACF2' */
  If Bitand(CVTOSLV6,'40'x) = '40'x then nop /* z/OS 2.2 and above */
    Else Queue '  The RACF level is 'RACFLEV'.' /*dont show racflev*/
  If SECNAM = 'Top Secret' then ,
   Queue '  The TSS Security File data set is' RCVTDSN'.'
  If SECNAM = 'RACF' then ,
   Queue '  The RACF primary data set is' RCVTDSN'.'
End
Else do
  /* RACF system */
  RCVTDSDT  = C2d(Storage(D2x(RCVT + 224),4))  /* point to RACFDSDT*/
  DSDTNUM   = C2d(Storage(D2x(RCVTDSDT+4),4))  /* num RACF dsns    */
  DSDTPRIM  = Storage(D2x(RCVTDSDT+177),44)    /* point to prim ds */
  DSDTPRIM  = Strip(DSDTPRIM,'T')              /* del trail blanks */
  DSDTBACK  = Storage(D2x(RCVTDSDT+353),44)    /* point to back ds */
  DSDTBACK  = Strip(DSDTBACK,'T')              /* del trail blanks */
  If Bitand(CVTOSLV6,'40'x) = '40'x then do /* z/OS 2.2 and above  */
    Queue 'The security software is' Word(PRODNAM2,1) ,
          'Security Server (RACF).'
    Queue 'The RACF level is' PRODNAM2 VRM !! '.'
  End
  Else do
    Queue 'The security software is' Word(PRODNAM2,1) ,
          'Security Server (RACF).' ,
          'The FMID is HRF' !! RACFVRM !! '.'
  End
  If DSDTNUM = 1 then do
    Queue '  The RACF primary data set is' DSDTPRIM'.'
    Queue '  The RACF backup  data set is' DSDTBACK'.'
  End
  Else do
    Queue '  RACF is using a split database. There are' DSDTNUM ,
          'pairs of RACF data sets:'
    RDTOFF = 0                            /* init cur offset to 0 */
    DSDTENTY_SIZE = 352                   /* dsdtenty size        */
    Do RDSNS = 1 to DSDTNUM
      DSDTPRIM  = Storage(D2x(RCVTDSDT+177+RDTOFF),44) /* prim dsn */
      DSDTPRIM  = Strip(DSDTPRIM,'T')                  /* del blnks*/
      DSDTBACK  = Storage(D2x(RCVTDSDT+353+RDTOFF),44) /* bkup dsn */
      DSDTBACK  = Strip(DSDTBACK,'T')                  /* del blnks*/
      RDTOFF = RDTOFF + DSDTENTY_SIZE            /* next tbl entry */
      Queue '    Primary #'RDSNS' - ' DSDTPRIM
      Queue '    Backup  #'RDSNS' - ' DSDTBACK
    End  /* do RDSNS = 1 to DSDTNUM */
  End
End /* else do */
Queue 'The' DFPRD 'level is' DFLEV'.'
If DFPRD = 'DFSMS' then do
  Queue '  The SMS parmlib member is IGDSMS'igdsms'.'
  Queue '  The SMS ACDS data set name is' SMSACDS'.'
  Queue '  The SMS COMMDS data set name is' SMSCMDS'.'
End
Queue 'The TSO level is 'TSOLEV'.'
If SYSISPF = 'ACTIVE' then do                /* is ISPF active?      */
  Address ISPEXEC "VGET ZISPFOS"             /* yes, is it OS?390?   */
  If RC = 0 then do                          /* yes, get OS/390 var  */
    ISPFLEV = Strip(Substr(ZISPFOS,10,15))   /* only need version    */
    Address ISPEXEC "VGET ZENVIR"            /* ispf internal rel var*/
    ISPFLEVI = Substr(ZENVIR,1,8)            /* internal ISPF release*/
    Queue 'The ISPF level is 'ISPFLEV' ('ISPFLEVI').'
  End  /* if RC */
  Else do                          /* not OS/390 - use old variables */
    Address ISPEXEC "VGET ZPDFREL"           /* get pdf release info */
    ISPFLEV  = Substr(ZENVIR,6,3)            /* ISPF level           */
    PDFLEV   = Substr(ZPDFREL,5,3)           /* PDF  level           */
    Queue 'The ISPF level is 'ISPFLEV'. The PDF level is' PDFLEV'.'
  End /* else do */
End  /* if SYSISPF */
If VTAM_ACTIVE = 'YES' then do
  Queue 'The VTAM level is 'VTAMLEV'.'
  Queue '  The NETID is' ATCNETID'. The SSCPNAME is' ATCNQNAM'.'
End /* if VTAM_ACTIVE = YES */
Else Queue 'The VTAM level is not available - VTAM is not active.'
If Bitand(CVTOSLV1,'80'x) = '80'x then do    /* HBB4430 ESA V4.3 & > */
  If TCP_ACTIVE = 'YES' then do
    Queue 'The TCP/IP stack is active. ',
          'There are 'TCPANUM' active TSEBs out of 'TSEBNUM'.'
    Queue '  SI Proc       Vers   ASID ( dec)   Status'
    Queue '  -- --------   ----   ---- ------   ------'
    Do LSI = 1 to TCPANUM
      Queue '  'Right(TCPNUM.LSI,2)' 'TCPNAME.LSI'   'TCPVER.LSI'  ',
            TCPASID.LSI'   'TCPST.LSI
    End
  End /* if TCP_ACTIVE = YES */
  Else Queue 'The TCP level is not available - TCP is not active.'
End /*  If Bitand(CVTOSLV1,'80'x) = '80'x   */
Return

STOR:                /* Storage information sub-routine              */
Queue ' '
CVTRLSTG = C2d(Storage(D2x(CVT + 856),4))    /* point to store at IPL*/
CVTRLSTG = CVTRLSTG/1024                     /* convert to Megabytes */
If zARCH <> 2 then do                        /* not valid in 64-bit  */
  CVTEORM  = C2d(Storage(D2x(CVT + 312),4))  /* potential real high  */
  CVTEORM  = (CVTEORM+1)/1024/1024           /* convert to Megabytes */
  ESTOR    = C2d(Storage(D2x(RCE + 160),4))  /* point to ESTOR frames*/
  ESTOR    = ESTOR*4/1024                    /* convert to Megabytes */
End
  /**********************************************************/
  /* At z/OS 2.1 CVTRLSTG was not always correct. The code  */
  /* below gets the value from the RSM Internal Table       */
  /* field 'RITTOTALONLINESTORAGEATIPL'.                    */
  /* The RIT is documented in the MVS Data Areas manual     */
  /*  - This was a bug fixed by APAR OA48094                */
  /**********************************************************/
 /*
If Bitand(CVTOSLV6,'80'x) = '80'x then do    /* z/OS 2.1  and above  */
CVTPVTP  = C2d(Storage(D2x(CVT+356),4))      /* point page vect tbl  */
PVTRIT   = C2x(Storage(D2x(CVTPVTP+4),4))    /* RSM internal tbl OCO */
RITOLSTG = X2d(C2x(Storage(D2x(X2d(PVTRIT)+X2d(128)),8)))
RITOLSTG = RITOLSTG/1024/1024                /* convert to Megabytes */
CVTRLSTG = RITOLSTG            /* change the name for code below     */
End
  */
If Bitand(CVTOSLV0,'08'x) = '08'x then do    /* HBB4410 ESA V4 & >   */
  ECVTEORM  = C2d(Storage(d2x(ECVT+600),8))  /* potential real high  */
  RECONFIG  = (ECVTEORM-CVTRLSTG*1024*1024+1)/(1024*1024) /* amt of  */
                                             /* reconfigurable stor  */
End
If Bitand(CVTOSLV5,'40'x) = '40'x then do    /* z/OS 1.7 and above   */
  RCECADSUsed = C2d(Storage(D2x(RCE + 572),2)) /* CADS current use   */
  RCECADSHW   = C2d(Storage(D2x(RCE + 574),2)) /* CADS high water    */
End
Call STORAGE_GDA_LDA
If Bitand(CVTOSLV2,'01'x) = '01'x then do    /* OS/390 R10 and above */
  SCCBSAI  = C2d(Storage(D2x(SCCB + 10),1))  /* real stor incr. in M */
  If SCCBSAI =  0 then do                    /* If 0, use SCCBSAIX   */
    SCCBSAIX = C2d(Storage(D2x(SCCB + 100),4)) /* real stor incr in M*/
    SCCBSAI  = SCCBSAIX                      /* using SCCBSAI later  */
  End
  SCCBSAR  = C2d(Storage(D2x(SCCB + 8),2))   /* # of. incr installed */
End
If zARCH <> 2 then do       /* not valid in 64-bit */
  Queue 'The real storage size at IPL time was 'Format(CVTRLSTG,,0)'M.'
  Queue 'The potential real storage size is' ,
         Format(CVTEORM,,0)'M.'
  If ESTOR > 0 then
    Queue 'The expanded storage size is 'ESTOR'M.'
  Else
    Queue 'The system has no expanded storage.'
End /* If zARCH <> 2 */
Else Queue 'The real storage online at IPL time' ,
           'was 'Format(CVTRLSTG,,0)'M.'
If Bitand(CVTOSLV2,'01'x) = '01'x then ,     /* OS/390 R10 and above */
  If SCCBSAI <> 0 then ,
    Queue 'The real storage increment size is 'SCCBSAI'M with' ,
           SCCBSAR 'increments installed.'
If Bitand(CVTOSLV0,'08'x) = '08'x then do    /* HBB4410 ESA V4 & >   */
  Queue 'The potential real storage size is' ,
         (ECVTEORM+1)/(1024*1024)'M.'
  Queue 'The reconfigurable storage size is 'reconfig'MB.'
End
Queue 'The private area size <16M is 'GDAPVTSZ'K.'
Queue 'The private area size >16M is 'GDAEPVTS'M.'
Queue 'The CSA size <16M is 'GDACSASZ'K.'
Queue 'The CSA size >16M is 'GDAECSAS'K.'
Queue 'The SQA size <16M is 'GDASQASZ'K.'
Queue 'The SQA size >16M is 'GDAESQAS'K.'
Queue 'The maximum V=R region size is 'GDAVRSZ'K.'
Queue 'The default V=R region size is 'GDAVREGS'K.'
Queue 'The maximum V=V region size is 'LDASIZEA'K.'
If Bitand(CVTOSLV5,'40'x) = '40'x then do    /* z/OS 1.7 and above   */
  Queue 'The current number of CADS (MAXCADs)' ,
        'in use is 'RCECADSUsed'.'
  Queue 'The maximum number of CADS (MAXCADs)' ,
        'used since IPL is 'RCECADSHW'.'
End
Return

CPU:                 /* CPU information sub-routine                  */
Queue ' '
If Bitand(CVTOSLV3,'01'x) = '01'x then ,  /* z/OS 1.6 & above >16 CPs*/
  NUMCPU   = C2d(Storage(D2x(CSD + 212),4))  /* point to # of CPUS   */
Else,
  NUMCPU   = C2d(Storage(D2x(CSD + 10),2))   /* point to # of CPUS   */
SCCBNCPS = C2d(Storage(d2x(SCCB + 16),2))    /* Max No. of CPUs      */
/*                                                                   */
Queue 'The CPU model number is 'MODEL'.'
Queue 'The number of online CPUs is 'NUMCPU'.' ,
      'The maximum number of CPUs is 'SCCBNCPS'.'
If Bitand(CVTOSLV3,'20'x) = '20'x & ,        /* z/OS 1.1 and above   */
   Bitand(CVTOSLV3,'01'x) <> '01'x then do   /* but below z/OS 1.6   */
  CSDICPUS = C2d(Storage(D2x(CSD+161),1))    /* CPUs online @ IPL    */
  Queue '  The number of CPUs online at IPL time was 'CSDICPUS'.'
End
If Bitand(CVTOSLV3,'01'x) = '01'x then do    /* z/OS 1.6 and above   */
  CSDICPUS = C2d(Storage(D2x(CSD+161),1))    /* CPUs online @ IPL    */
  CSDIIFAS = C2d(Storage(D2x(CSD+162),1))    /* zAAPs online @ IPL   */
  Queue '  The number of GPs online at IPL time was 'CSDICPUS'.'
  If CSDIIFAS <> 0 then ,
  Queue '  The number of zAAPs online at IPL time was 'CSDIIFAS'.'
  If Bitand(CVTOSLV4,'02'x) = '02'x then do /* zIIP (SUP) support    */
    CSDISUPS = C2d(Storage(D2x(CSD+163),1))  /* zIIPs online @ IPL   */
    If CSDISUPS <> 0 then ,
    Queue '  The number of zIIPs online at IPL time was 'CSDISUPS'.'
  End
End
/*                                                                   */
CPNUM     = 0
FOUNDCPUS = 0
FOUNDZAPS = 0
FOUNDZIPS = 0
Do until FOUNDCPUS = NUMCPU
PCCA = C2d(Storage(D2x(PCCAVT + CPNUM*4),4)) /* point to PCCA        */
  If PCCA <> 0 then do
    CPUVER   = Storage(D2x(PCCA + 4),2)      /* point to VERSION     */
    CPUID    = Storage(D2x(PCCA + 6),10)     /* point to CPUID       */
    IDSHORT  = Substr(CPUID,2,5)
    PCCAATTR = Storage(D2x(PCCA + 376),1)    /* attribute byte       */
    PCCARCFF = Storage(D2x(PCCA + 379),1)    /* reconfig flag        */
    CP_TYP   = ''                            /* init to null for now */
    If Bitand(PCCAATTR,'01'x) = '01'x then do  /* check PCCAIFA      */
       CP_TYP = '(zAAP)'                       /* zAAP / IFA CP      */
       FOUNDZAPS = FOUNDZAPS + 1
    End
    If Bitand(PCCAATTR,'04'x) = '04'x then do  /* check PCCAzIIP     */
       CP_TYP = '(zIIP)'                       /* zIIP processor     */
       FOUNDZIPS = FOUNDZIPS + 1
    End
    If Bitand(PCCARCFF,'80'x) = '80'x then ,   /* check PCCACWLM     */
       CP_TYP = '(WLM)'                        /* WLM controlled CP  */
    CPNUM_M = D2x(CPNUM)                       /* display in hex     */
    If Bitand(CVTOSLV3,'01'x) = '01'x then ,   /* z/OS 1.6 & above   */
      CPNUM_M = Right(CPNUM_M,2,'0')           /* display as 2 digits*/
    Queue 'The CPU serial number for CPU 'CPNUM_M' is ' !! ,
     CPUID' ('IDSHORT'), version code' CPUVER'.' CP_TYP
    FOUNDCPUS = FOUNDCPUS + 1
  End
CPNUM = CPNUM + 1
End  /* do until  */
/**************************************************/
/* SUs/SEC and MIPS calculations                  */
/* SYS1.NUCLEUS(IEAVNP10) CSECT IRARMCPU          */
/**************************************************/
RMCT     = C2d(Storage(D2x(CVT+604),4))      /* point to RMCT        */
SU       = C2d(Storage(D2x(RMCT+64),4))      /* CPU Rate Adjustment  */
SUSEC    = Format((16000000/SU),7,2)         /* SUs per second       */
MIPSCP   = NUMCPU-FOUNDZAPS-FOUNDZIPS        /* Don't include special*/
                                             /* processors for MIPs  */
MIPS     = Format((SUSEC/48.5) * MIPSCP,6,2) /* SRM MIPS calculation */
                                             /* (48.5) borrowed from */
                                             /* Thierry Falissard    */
Queue 'The service units per second per online CPU is' Strip(SUSEC)'.'
Queue 'The approximate total MIPS (SUs/SEC / 48.5 * # general CPUs)' ,
      'is' Strip(MIPS)'.'
  /*
RMCTCCT  = C2d(Storage(D2x(RMCT+4),4))       /* cpu mgmt control tbl */
CCVUTILP = C2d(Storage(D2x(RMCTCCT+102),2))  /* CPU Utilization      */
Queue 'The approximate CPU utilization is' CCVUTILP'%.'
       */
If Bitand(CVTOSLV3,'20'x) = '20'x then do    /* z/OS 1.1 and above   */
                                             /* w/APAR OW55509       */
  RCT      = C2d(Storage(D2x(RMCT+228),4))   /* Resource Control Tbl */
  RCTLACS  = C2d(Storage(D2x(RCT+196),4))    /* 4 hr MSU average     */
  RCTIMGWU = C2d(Storage(D2x(RCT+28),4))     /* Image defined MSUs   */
  RCTCECWU = C2d(Storage(D2x(RCT+32),4))     /* CEC MSU Capacity     */
  If RCTCECWU <> 0 then do
    Queue 'The MSU capacity for this CEC is' RCTCECWU'.'
    Queue 'The defined MSU capacity for this LPAR is' RCTIMGWU'.'
  End
  If RCTLACS <> 0 then do
    Queue 'The 4 hour MSU average usage is' RCTLACS'.'
    If RCTLACS >= RCTIMGWU & RCTIMGWU <> RCTCECWU then ,
      Queue ' ** This LPAR is currently being "soft capped". **'
  End
End
/*                                                                   */
If Bitand(CVTOSLV5,'20'x) = '20'x then do    /* z/OS 1.8 and above   */
  IEAVESVT = C2d(Storage(D2x(CVT + 868),4))  /* supv. vect tbl IHASVT*/
  SVTAFFB  = Storage(D2x(IEAVESVT + 12),1)   /* aff-dispatch byte    */
  If Bitand(SVTAFFB,'80'x) = '80'x then ,
    Queue 'The HiperDispatch feature is active on this LPAR.'
  Else Queue 'The HiperDispatch feature is not active on this LPAR.'
  CPCRPERC = C2d(Storage(D2x(IEAVESVT+1008),4)) /* CPCR Percent      */
  If CPCRPERC <> 0 then
    Queue 'The CP Credits feature is active on this CPC/LPAR' ,
          'at' CPCRPERC'%.'
End
/**************************************************/
/* Central Processing Complex Node Descriptor     */
/**************************************************/
If Bitand(CVTOSLV1,'20'x) = '20'x then do      /* HBB5510 ESA V5 & > */
  CVTHID   = C2d(Storage(D2x(CVT + 1068),4))   /* point to SHID      */
  CPCND_FLAGS = Storage(D2x(CVTHID+22),1)      /* pnt to CPCND FLAGS */
  If CPCND_FLAGS <> 0 then do                  /* Is there a CPC?    */
    CPCND_VALID = Bitand(CPCND_FLAGS,'E0'x)    /* Valid flags        */
    CPCND_INVALID = Bitand('40'x)              /* Invalid flag       */
    If CPCND_VALID <> CPCND_INVALID then do    /* Is it valid?       */
      CPCND_TYPE  = Storage(D2x(CVTHID+26),6)  /* Type               */
      CPCND_MODEL = Storage(D2x(CVTHID+32),3)  /* Model              */
      CPCND_MAN   = Storage(D2x(CVTHID+35),3)  /* Manufacturer       */
      CPCND_PLANT = Storage(D2x(CVTHID+38),2)  /* Plant of manufact. */
      CPCND_SEQNO = Storage(D2x(CVTHID+40),12) /* Sequence number    */
      CPC_ID      = C2x(Storage(D2x(CVTHID+55),1))  /* CPC ID        */
      Queue ' '
   /* Queue 'Central Processing Complex (CPC) Node Descriptor:' */
      Queue 'Central Processing Complex (CPC) Information:'
      Queue '  CPC ND =',
       CPCND_TYPE'.'CPCND_MODEL'.'CPCND_MAN'.'CPCND_PLANT'.'CPCND_SEQNO
      If Bitand(CVTOSLV3,'10'x) = '10'x then do    /*z/OS 1.2 & above*/
        Call GET_CPCSI /* Get CPC SI (STSI) information sub-routine  */
        Queue '  CPC SI ='  CPCSI_TYPE'.'CPCSI_MODEL'.'  !! ,
               CPCSI_MAN'.'CPCSI_PLANT'.'CPCSI_CPUID
        Queue '           Model:' CPCSI_MODELID
      End /* If Bitand(CVTOSLV3,'10'x) = '10'x */
      Queue '  CPC ID =' CPC_ID
      Queue '  Type('CPCND_TYPE') Model('CPCND_MODEL')',
            'Manufacturer('CPCND_MAN') Plant('CPCND_PLANT')',
            'Seq Num('CPCND_SEQNO')'
      If Bitand(CVTOSLV3,'20'x) = '20'x then do    /*z/OS 1.1 & above*/
        RMCTX1M  = Storage(D2x(RMCT+500),4)        /* Microcode addr */
                                                   /*   in RMCTX1    */
        If RMCTX1M  <> '7FFFF000'x then do         /* skip VM/FLEX/ES*/
          RMCTX1M  = C2d(RMCTX1M)                  /* change to dec. */
          MCL      = Storage(D2x(RMCTX1M + 40),8)  /* Microcode lvl  */
          MCLDRV   = Substr(MCL,1,4)               /* Driver only..  */
          If Datatype(MCLDRV,'Number') = 1 then ,  /* if all numeric */
             MCLDRV = Format(MCLDRV)               /* rmv leading 0s */
          Queue '  The Microcode level of this CPC is' MCL !! ,
                ' (Driver' MCLDRV').'
        End /* If RMCTX1M  <> '7FFFF000'x */
      End /* If Bitand(CVTOSLV3,'20'x) = '20'x */
    End /* if CPCND_VALID <> CPCND_INVALID */
    Else do
      If Bitand(CVTOSLV3,'10'x) = '10'x then do    /*z/OS 1.2 & above*/
        Call GET_CPCSI /* Get CPC SI (STSI) information sub-routine  */
        Queue ' '
        Queue 'Central Processing Complex (CPC) Information:'
        Queue '  CPC SI ='  CPCSI_TYPE'.'CPCSI_MODEL'.'  !! ,
               CPCSI_MAN'.'CPCSI_PLANT'.'CPCSI_CPUID
        Queue '           Model:' CPCSI_MODELID
      End /* if Bitand(CVTOSLV3,'10'x) = '10'x */
    End /* else do */
  End  /* if CPCND_FLAGS <>0  */
End
Return

IPA:                 /* IPA information sub-routine                  */
Queue ' '
/*********************************************************************/
/* IPL parms from the IPA                                            */
/*********************************************************************/
If Bitand(CVTOSLV1,'01'x) = '01'x then do    /* OS/390 R2 and above  */
  IPAICTOD = Storage(D2x(ECVTIPA + 8),8)     /* point to IPL TOD     */
  IPALPARM = Storage(D2x(ECVTIPA + 16),8)    /* point to LOAD PARM   */
  IPALPDSN = Storage(D2x(ECVTIPA + 48),44)   /* load parm dsn name   */
  IPALPDDV = Storage(D2x(ECVTIPA + 92),4)    /* load parm dev number */
  IPAHWNAM = Storage(D2x(ECVTIPA + 24),8)    /* point to HWNAME      */
  IPAHWNAM = Strip(IPAHWNAM,'T')             /* del trailing blanks  */
  IPALPNAM = Storage(D2x(ECVTIPA + 32),8)    /* point to LPARNAME    */
  IPALPNAM = Strip(IPALPNAM,'T')             /* del trailing blanks  */
  IPAVMNAM = Storage(D2x(ECVTIPA + 40),8)    /* point to VMUSERID    */
  /**************************/
  /* PARMS in LOADxx        */
  /**************************/
  IPANUCID = Storage(D2x(ECVTIPA + 23),1)    /* NUCLEUS ID           */
  IPAIODF  = Storage(D2x(ECVTIPA + 96),63)   /* IODF    card image   */
  IPASPARM = Storage(D2x(ECVTIPA + 160),63)  /* SYSPARM card image   */
  /*IPASCAT= Storage(D2x(ECVTIPA + 224),63)*//* SYSCAT  card image   */
  IPASYM   = Storage(D2x(ECVTIPA + 288),63)  /* IEASYM  card image   */
  IPAPLEX  = Storage(D2x(ECVTIPA + 352),63)  /* SYSPLEX card image   */
  If Bitand(CVTOSLV2,'01'x) = '01'x then do  /* OS/390 R10 and above */
    IPAPLNUMX = Storage(D2x(ECVTIPA + 2134),2) /* number of parmlibs */
    IPAPLNUM  = IPAPLNUMX
  End
  Else ,                                     /* OS/390 R10 and above */
    IPAPLNUM = Storage(D2x(ECVTIPA + 2148),2) /* number of parmlibs  */
  IPAPLNUM = C2d(IPAPLNUM)                   /* convert to decimal   */
  POFF = 0
  Do P = 1 to IPAPLNUM
    IPAPLIB.P = Storage(D2x(ECVTIPA+416+POFF),63) /* PARMLIB cards   */
    IPAPLFLG.P = Storage(D2x(ECVTIPA+479+POFF),1)  /* flag bits      */
    If Bitand(IPAPLFLG.P,'20'x) = '20'x then ,   /* volser from cat? */
      IPAPLIB.P = Overlay('      ',IPAPLIB.P,46) /* no, clear it     */
    POFF = POFF + 64
  End
  IPANLID  = Storage(D2x(ECVTIPA + 2144),2)  /* NUCLSTxx member used */
  IPANUCW  = Storage(D2x(ECVTIPA + 2146),1)  /* load wait state char */
  IPAICTOD = C2x(IPAICTOD)   /* make "readable" for REXXTOD call     */
  Call REXXTOD IPAICTOD      /* convert TOD to YYYY.DDD HH:MM:SS.ttt */
  TOD_RESY = Substr(RESULT,1,4)      /* year portion from REXXTOD    */
  TOD_RESD = Substr(RESULT,6,3)      /* day  portion from REXXTOD    */
  TOD_REST = Substr(RESULT,10,8)     /* time portion from REXXTOD    */
  Call RDATE TOD_RESY TOD_RESD /* call RDATE- format for ISO/USA/EUR */
  MMIPA    = Substr(RESULT,1,2)              /* MM from MM/DD/YYYY   */
  DDIPA    = Substr(RESULT,4,2)              /* DD from MM/DD/YYYY   */
  YYYYIPA  = Substr(RESULT,7,4)              /* YYYY from MM/DD/YYYY */
  If DATEFMT = 'USA' then ,                  /* USA format date?     */
    IPAIDATE = Substr(RESULT,1,10)           /* date as MM/DD/YYYY   */
  If DATEFMT = 'EUR' then ,                  /* EUR format date?     */
    IPAIDATE = DDIPA'/'MMIPA'/'YYYYIPA       /* date as DD/MM/YYYY   */
  If DATEFMT = 'ISO' then ,                  /* ISO format date?     */
    IPAIDATE = YYYYIPA'-'MMIPA'-'DDIPA       /* date as YYYY-MM-DD   */
  Queue 'Initialization information from the IPA:'
  Queue '  IPL TIME (GMT):' IPAIDATE ,
           '('TOD_RESY'.'TOD_RESD') at' TOD_REST
  Queue '  IPLPARM =' IPALPARM   '(merged)'
  Queue '  IPL load parameter data set name: 'IPALPDSN
  Queue '  IPL load parameter data set device address: 'IPALPDDV
  Queue '  HWNAME='IPAHWNAM '  LPARNAME='IPALPNAM ,
        '  VMUSERID='IPAVMNAM
  Queue '  '                    /* add blank line for readability   */
  Queue '  LOADxx parameters from the IPA' ,
        '(LOAD' !! Substr(IPALPARM,5,2) !! '):'
  Queue '    *---+----1----+----2----+----3----+----4' !! ,
            '----+----5----+----6----+----7--'
  If Bitand(CVTOSLV2,'01'x) = '01'x then do    /* OS/390 R10 & above */
    IPAARCHL = Storage(D2x(ECVTIPA + 2143),1)  /* ARCHLVL (1 or 2)   */
    Queue '    ARCHLVL  'IPAARCHL
  End
  If IPASYM   <> '' then queue '    IEASYM   'IPASYM
  If IPAIODF  <> '' then queue '    IODF     'IPAIODF
  If IPANUCID <> '' then queue '    NUCLEUS  'IPANUCID
  If IPANLID  <> '' then queue '    NUCLST   'IPANLID' 'IPANUCW
  Do P = 1 to IPAPLNUM
    Queue '    PARMLIB  'IPAPLIB.P
  End
  If IPASCAT  <> '' then queue '    SYSCAT   'IPASCAT
  If IPASPARM <> '' then queue '    SYSPARM  'IPASPARM
  If IPAPLEX  <> '' then queue '    SYSPLEX  'IPAPLEX
  /**************************/
  /* PARMS in IEASYSxx      */
  /**************************/
  Queue '  '                    /* add blank line for readability   */
  Queue '  IEASYSxx parameters from the IPA:          ',
        '                     (Source)'
  Call BUILD_IPAPDETB    /* Build table for init parms               */
  TOTPRMS = 0            /* tot num of specified or defaulted parms  */
  Do I = 1 to IPAPDETB.0
    Call EXTRACT_SYSPARMS IPAPDETB.I   /* extract parms from the IPA */
  End
 /********************************************************************/
 /* Uncommment a sample below to test IPA PAGE parm "split" code:    */
 /*  PRMLINE.32 = 'SWAP SWAP=(SYS1.SWAP.TEST) IEASYSXX'              */
 /*  PRMLINE.32 = 'NONVIO NONVIO=(SYS1.PAGE.TEST) IEASYSXX'          */
 /*  PRMLINE.32 = 'NONVIO NONVIO=(SYS1.PAGE1,SYS1.PAGE2) IEASYSXX'   */
 /*  PRMLINE.32 = 'NONVIO ' !! ,                                     */
 /*  'NONVIO=(SYS1.PAGE1,SYS1.PAGE2,SYS1.PAGE3,SYS1.PAGE4) IEASYSXX' */
 /********************************************************************/
  Call SORT_IPA                       /* sort IPA parms              */
  Call SPLIT_IPA_PAGE                 /* split page/swap dsn parms   */
  Do I = 1 to TOT_IPALINES            /* add ipa parms               */
    If I = TOT_IPALINES then ,        /*   to stack and              */
      IPALINE.I = Translate(IPALINE.I,' ',',') /* remove comma       */
    Queue IPALINE.I                   /*           from last parm    */
  End
End
Return

SYMBOLS:             /* System Symbols information sub-routine       */
Queue ' '
/*********************************************************************/
/* Find System Symbols  - ASASYMBP MACRO                             */
/*  ECVT+X'128' = ECVTSYMT                                           */
/*  2nd half word = # of symbols , after that each entry is 4 words  */
/*  1st word = offset to symbol name                                 */
/*  2nd word = length of symbol name                                 */
/*  3rd word = offset to symbol value                                */
/*  4th word = length of symbol value                                */
/*********************************************************************/
If Bitand(CVTOSLV1,'10'x) = '10'x then do    /* HBB5520 ESA V5.2 & > */
  ECVTSYMT = C2d(Storage(D2x(ECVT + 296),4)) /* point to ECVTSYMT    */
  NUMSYMBS = C2d(Storage(D2x(ECVTSYMT + 2),2))  /* number of symbols */
  Queue 'Static System Symbol Values:'
  Do I = 1 to NUMSYMBS
    SOFF = I*16-16
    NAMOFF  = C2d(Storage(D2x(ECVTSYMT+4+SOFF),4))  /*offset to name */
    NAMLEN  = C2d(Storage(D2x(ECVTSYMT+8+SOFF),4))  /*length of name */
    VALOFF  = C2d(Storage(D2x(ECVTSYMT+12+SOFF),4)) /*offset to value*/
    VALLEN  = C2d(Storage(D2x(ECVTSYMT+16+SOFF),4)) /*length of value*/
    SYMNAME = Storage(D2x(ECVTSYMT+4+NAMOFF),NAMLEN) /*symbol name   */
    If VALLEN = 0 then VALNAME = ''                 /* null value    */
    Else ,
    VALNAME = Storage(D2x(ECVTSYMT+4+VALOFF),VALLEN) /* symbol value */
      If Bitand(CVTOSLV6,'40'x) = '40'x then ,   /* z/OS 2.2 and >   */
      Queue ' ' Left(SYMNAME,18,' ') '=' VALNAME /* max 16 + & + .   */
      Else ,
      Queue ' ' Left(SYMNAME,10,' ') '=' VALNAME /* max 8 + & + .    */
  End  /* do NUMSYMBS */
End
Return

VMAP:                /* Virtual Storage Map sub-routine              */
Arg VMAPOPT
If option <> 'ALL' then,
  Call STORAGE_GDA_LDA                       /* GDA/LDA stor routine */
SYSEND  = X2d(LDASTRTS) + (LDASIZS*1024) - 1 /* end of system area   */
SYSEND  = D2x(SYSEND)                        /* display in hex       */
If GDAVRSZ = 0 then do                       /* no v=r               */
  VRSTRT = 'N/A     '
  VREND  = 'N/A     '
  VVSTRT = LDASTRTA                          /* start of v=v         */
  VVEND  =  X2d(LDASTRTA) + (LDASIZEA*1024) - 1 /* end of v=v        */
  VVEND  =  D2x(VVEND)                       /* display in hex       */
End
Else do
  VRSTRT =  LDASTRTA                         /* start of v=r         */
  VREND  =  X2d(LDASTRTA) + (GDAVRSZ*1024) - 1 /* end of v=r         */
  VREND  =  D2X(VREND)                       /* display in hex       */
  VVSTRT =  LDASTRTA                         /* start of v=v         */
  VVEND  =  X2d(LDASTRTA) + (LDASIZEA*1024) - 1 /* end of v=v        */
  VVEND  =  D2x(VVEND)                       /* display in hex       */
End
GDACSA   = C2d(Storage(D2x(CVTGDA + 108),4)) /* start of CSA addr    */
GDACSAH  = D2x(GDACSA)                       /* display in hex       */
CSAEND   = (GDACSASZ*1024) + GDACSA - 1      /* end of CSA           */
CSAEND   = D2x(CSAEND)                       /* display in hex       */
CVTSMEXT = C2d(Storage(D2x(CVT +1196),4))    /* point to stg map ext.*/
CVTMLPAS = C2d(Storage(D2x(CVTSMEXT+ 8),4))  /* start of MLPA addr   */
CVTMLPAS = D2x(CVTMLPAS)                     /* display in hex       */
If CVTMLPAS <> 0 then do
  CVTMLPAE = C2d(Storage(D2x(CVTSMEXT+12),4))  /* end of MLPA addr   */
  CVTMLPAE = D2x(CVTMLPAE)                     /* display in hex     */
  MLPASZ   = X2d(CVTMLPAE) - X2d(CVTMLPAS) + 1 /* size of MLPA       */
  MLPASZ   = MLPASZ/1024                       /* convert to Kbytes  */
End
Else do /* no MLPA */
  CVTMLPAS = 'N/A     '
  CVTMLPAE = 'N/A     '
  MLPASZ   = 0
End
CVTFLPAS = C2d(Storage(D2x(CVTSMEXT+16),4))  /* start of FLPA addr   */
CVTFLPAS = D2x(CVTFLPAS)                     /* display in hex       */
If CVTFLPAS <> 0 then do
  CVTFLPAE = C2d(Storage(D2x(CVTSMEXT+20),4))  /* end of FLPA addr   */
  CVTFLPAE = D2x(CVTFLPAE)                     /* display in hex     */
  FLPASZ   = X2d(CVTFLPAE) - X2d(CVTFLPAS) + 1 /* size of FLPA       */
  FLPASZ   = FLPASZ/1024                       /* convert to Kbytes  */
End
Else do /* no FLPA */
  CVTFLPAS = 'N/A     '
  CVTFLPAE = 'N/A     '
  FLPASZ   = 0
End
CVTPLPAS = C2d(Storage(D2x(CVTSMEXT+24),4))  /* start of PLPA addr   */
CVTPLPAS = D2x(CVTPLPAS)                     /* display in hex       */
CVTPLPAE = C2d(Storage(D2x(CVTSMEXT+28),4))  /* end of PLPA addr     */
CVTPLPAE = D2x(CVTPLPAE)                     /* display in hex       */
PLPASZ   = X2d(CVTPLPAE) - X2d(CVTPLPAS) + 1 /* size of PLPA         */
PLPASZ   = PLPASZ/1024                       /* convert to Kbytes    */
GDASQA   = C2d(Storage(D2x(CVTGDA + 144),4)) /* start of SQA addr    */
GDASQAH  = D2x(GDASQA)                       /* display in hex       */
SQAEND   = (GDASQASZ*1024) + GDASQA - 1      /* end of SQA           */
SQAEND   = D2x(SQAEND)                       /* display in hex       */
CVTRWNS  = C2d(Storage(D2x(CVTSMEXT+32),4))  /* start of R/W nucleus */
CVTRWNS  = D2x(CVTRWNS)                      /* display in hex       */
CVTRWNE  = C2d(Storage(D2x(CVTSMEXT+36),4))  /* end of R/W nucleus   */
CVTRWNE  = D2x(CVTRWNE)                      /* display in hex       */
RWNUCSZ  = X2d(CVTRWNE)  - X2d(CVTRWNS)  + 1 /* size of R/W nucleus  */
RWNUCSZ  = Format(RWNUCSZ/1024,,0)           /* convert to Kbytes    */
CVTRONS  = C2d(Storage(D2x(CVTSMEXT+40),4))  /* start of R/O nucleus */
CVTRONS  = D2x(CVTRONS)                      /* display in hex       */
CVTRONE  = C2d(Storage(D2x(CVTSMEXT+44),4))  /* end of R/O nucleus   */
CVTRONE  = D2x(CVTRONE)                      /* display in hex       */
RONUCSZ  = X2d(CVTRONE)  - X2d(CVTRONS)  + 1 /* size of R/O nucleus  */
RONUCSZ  = Format(RONUCSZ/1024,,0)           /* convert to Kbytes    */
RONUCSZB = X2d('FFFFFF') - X2d(CVTRONS) + 1  /* size of R/O nuc <16M */
RONUCSZB = Format(RONUCSZB/1024,,0)          /* convert to Kbytes    */
RONUCSZA = X2d(CVTRONE) - X2d('1000000') + 1 /* size of R/O nuc >16M */
RONUCSZA = Format(RONUCSZA/1024,,0)          /* convert to Kbytes    */
CVTERWNS = C2d(Storage(D2x(CVTSMEXT+48),4))  /* start of E-R/W nuc   */
CVTERWNS = D2x(CVTERWNS)                     /* display in hex       */
CVTERWNE = C2d(Storage(D2x(CVTSMEXT+52),4))  /* end of E-R/W nuc     */
CVTERWNE = D2x(CVTERWNE)                     /* display in hex       */
ERWNUCSZ = X2d(CVTERWNE) - X2d(CVTERWNS) + 1 /* size of E-R/W nuc    */
ERWNUCSZ = ERWNUCSZ/1024                     /* convert to Kbytes    */
GDAESQA  = C2d(Storage(D2x(CVTGDA + 152),4)) /* start of ESQA addr   */
GDAESQAH = D2x(GDAESQA)                      /* display in hex       */
ESQAEND  = (GDAESQAS*1024) + GDAESQA - 1     /* end of ESQA          */
ESQAEND  = D2x(ESQAEND)                      /* display in hex       */
CVTEPLPS = C2d(Storage(D2x(CVTSMEXT+56),4))  /* start of EPLPA addr  */
CVTEPLPS = D2x(CVTEPLPS)                     /* display in hex       */
CVTEPLPE = C2d(Storage(D2x(CVTSMEXT+60),4))  /* end of EPLPA addr    */
CVTEPLPE = D2x(CVTEPLPE)                     /* display in hex       */
EPLPASZ  = X2d(CVTEPLPE) - X2d(CVTEPLPS) + 1 /* size of EPLPA        */
EPLPASZ  = EPLPASZ/1024                      /* convert to Kbytes    */
CVTEFLPS = C2d(Storage(D2x(CVTSMEXT+64),4))  /* start of EFLPA addr  */
CVTEFLPS = D2x(CVTEFLPS)                     /* display in hex       */
If CVTEFLPS <> 0 then do
  CVTEFLPE = C2d(Storage(D2x(CVTSMEXT+68),4))  /* end of EFLPA addr  */
  CVTEFLPE = D2x(CVTEFLPE)                     /* display in hex     */
  EFLPASZ  = X2d(CVTEFLPE) - X2d(CVTEFLPS) + 1 /* size of EFLPA      */
  EFLPASZ  = EFLPASZ/1024                      /* convert to Kbytes  */
End
Else do /* no EFLPA */
  CVTEFLPS = 'N/A     '
  CVTEFLPE = 'N/A     '
  EFLPASZ  = 0
End
CVTEMLPS = C2d(Storage(D2x(CVTSMEXT+72),4))  /* start of EMLPA addr  */
CVTEMLPS = D2x(CVTEMLPS)                     /* display in hex       */
If CVTEMLPS <> 0 then do
  CVTEMLPE = C2d(Storage(D2x(CVTSMEXT+76),4))  /* end of EMLPA addr  */
  CVTEMLPE = D2x(CVTEMLPE)                     /* display in hex     */
  EMLPASZ  = X2d(CVTEMLPE) - X2d(CVTEMLPS) + 1 /* size of EMLPA      */
  EMLPASZ  = EMLPASZ/1024                      /* convert to Kbytes  */
End
Else do /* no EMLPA */
  CVTEMLPS = 'N/A     '
  CVTEMLPE = 'N/A     '
  EMLPASZ  = 0
End
GDAECSA  = C2d(Storage(D2x(CVTGDA + 124),4)) /* start of ECSA addr   */
GDAECSAH = D2x(GDAECSA)                      /* display in hex       */
ECSAEND  = (GDAECSAS*1024) + GDAECSA - 1     /* end of ECSA          */
ECSAEND  = D2x(ECSAEND)                      /* display in hex       */
GDAEPVT  = C2d(Storage(D2x(CVTGDA + 168),4)) /* start of EPVT addr   */
GDAEPVTH = D2x(GDAEPVT)                      /* display in hex       */
EPVTEND  = (GDAEPVTS*1024*1024) + GDAEPVT - 1 /* end of EPVT         */
EPVTEND  = D2x(EPVTEND)                      /* display in hex       */
If VMAPOPT <> 'NODISP' then do         /* no display of vmap desired */
Queue ' '
Queue 'Virtual Storage Map:'
Queue '          '
If VMAP = 'HIGHFIRST' then do
If Bitand(CVTOSLV2,'01'x) = '01'x then ,     /* OS/390 R10 and above */
 Queue '     Storage Area     Start      End           Size' ,
       '     Used     Conv      HWM'
Else ,
 Queue '     Storage Area     Start      End           Size' ,
       '     Used     Conv'
Queue '          '
Queue '     Ext. Private    '     Right(GDAEPVTH,8,'0') ' ' ,
   Right(EPVTEND,8,'0')           Right(GDAEPVTS,8,' ')'M'
If Bitand(CVTOSLV2,'01'x) = '01'x then ,     /* OS/390 R10 and above */
Queue '         Ext. CSA    '     Right(GDAECSAH,8,'0') ' ' ,
   Right(ECSAEND,8,'0')           Right(GDAECSAS,8,' ')'K' ,
   Right(GDA_ECSA_ALLOC,8,' ')'K         ' ,
   Right(GDAECSAHWM,7,' ')'K'
Else ,
Queue '         Ext. CSA    '     Right(GDAECSAH,8,'0') ' ' ,
   Right(ECSAEND,8,'0')           Right(GDAECSAS,8,' ')'K' ,
   Right(GDA_ECSA_ALLOC,8,' ')'K'
Queue '        Ext. MLPA    '     Right(CVTEMLPS,8,'0') ' ' ,
   Right(CVTEMLPE,8,'0')          Right(EMLPASZ,8,' ')'K'
Queue '        Ext. FLPA    '     Right(CVTEFLPS,8,'0') ' ' ,
   Right(CVTEFLPE,8,'0')          Right(EFLPASZ,8,' ')'K'
Queue '        Ext. PLPA    '     Right(CVTEPLPS,8,'0') ' ' ,
   Right(CVTEPLPE,8,'0')          Right(EPLPASZ,8,' ')'K'
If Bitand(CVTOSLV2,'01'x) = '01'x then ,     /* OS/390 R10 and above */
Queue '         Ext. SQA    '     Right(GDAESQAH,8,'0') ' ' ,
   Right(ESQAEND,8,'0')           Right(GDAESQAS,8,' ')'K' ,
   Right(GDA_ESQA_ALLOC,8,' ')'K' Right(GDA_ECSA_CONV,7,' ')'K',
   Right(GDAESQAHWM,7,' ')'K'
Else ,
Queue '         Ext. SQA    '     Right(GDAESQAH,8,'0') ' ' ,
   Right(ESQAEND,8,'0')           Right(GDAESQAS,8,' ')'K' ,
   Right(GDA_ESQA_ALLOC,8,' ')'K' Right(GDA_ECSA_CONV,7,' ')'K'
Queue ' Ext. R/W Nucleus    '     Right(CVTERWNS,8,'0') ' ' ,
   Right(CVTERWNE,8,'0')          Right(ERWNUCSZ,8,' ')'K'
Queue ' Ext. R/O Nucleus    '     Right('1000000',8,'0') ' ' ,
   Right(CVTRONE,8,'0')           Right(RONUCSZA,8,' ')'K' ,
   '(Total' RONUCSZ'K)'
Queue '             16M line -----------------------------'
Queue '      R/O Nucleus    '     Right(CVTRONS,8,'0') ' ' ,
   Right('FFFFFF',8,'0')          Right(RONUCSZB,8,' ')'K',
   '(Spans 16M line)'
Queue '      R/W Nucleus    '     Right(CVTRWNS,8,'0') ' ' ,
   Right(CVTRWNE,8,'0')           Right(RWNUCSZ,8,' ')'K'
If Bitand(CVTOSLV2,'01'x) = '01'x then ,     /* OS/390 R10 and above */
Queue '              SQA    '     Right(GDASQAH,8,'0') ' ' ,
   Right(SQAEND,8,'0')            Right(GDASQASZ,8,' ')'K' ,
   Right(GDA_SQA_ALLOC,8,' ')'K'  Right(GDA_CSA_CONV,7,' ')'K' ,
   Right(GDASQAHWM,7,' ')'K'
Else ,
Queue '              SQA    '     Right(GDASQAH,8,'0') ' ' ,
   Right(SQAEND,8,'0')            Right(GDASQASZ,8,' ')'K' ,
   Right(GDA_SQA_ALLOC,8,' ')'K'  Right(GDA_CSA_CONV,7,' ')'K'
Queue '             PLPA    '     Right(CVTPLPAS,8,'0') ' ' ,
   Right(CVTPLPAE,8,'0')          Right(PLPASZ,8,' ')'K'
Queue '             FLPA    '     Right(CVTFLPAS,8,'0') ' ' ,
   Right(CVTFLPAE,8,'0')          Right(FLPASZ,8,' ')'K'
Queue '             MLPA    '     Right(CVTMLPAS,8,'0') ' ' ,
   Right(CVTMLPAE,8,'0')          Right(MLPASZ,8,' ')'K'
If Bitand(CVTOSLV2,'01'x) = '01'x then ,     /* OS/390 R10 and above */
Queue '              CSA    '     Right(GDACSAH,8,'0') ' ' ,
   Right(CSAEND,8,'0')            Right(GDACSASZ,8,' ')'K' ,
   Right(GDA_CSA_ALLOC,8,' ')'K         ' ,
   Right(GDACSAHWM,7,' ')'K'
Else ,
Queue '              CSA    '     Right(GDACSAH,8,'0') ' ' ,
   Right(CSAEND,8,'0')            Right(GDACSASZ,8,' ')'K' ,
   Right(GDA_CSA_ALLOC,8,' ')'K'
Queue '      Private V=V    '     Right(VVSTRT,8,'0') ' ' ,
   Right(VVEND,8,'0')             Right(LDASIZEA,8,' ')'K'
Queue '      Private V=R    '     Right(VRSTRT,8,'0') ' ' ,
   Right(VREND,8,'0')             Right(GDAVRSZ,8,' ')'K'
Queue '           System    '     Right(LDASTRTS,8,'0') ' ' ,
   Right(SYSEND,8,'0')            Right(LDASIZS,8,' ')'K'
If zARCH = 2 then ,
  Queue '              PSA     00000000   00001FFF        8K'
Else ,
  Queue '              PSA     00000000   00000FFF        4K'
End  /* if VMAP = 'HIGHFIRST'  */
Else do  /* VMAP <> 'HIGHFIRST'  */
If Bitand(CVTOSLV2,'01'x) = '01'x then ,     /* OS/390 R10 and above */
 Queue '     Storage Area     Start      End           Size' ,
       '     Used     Conv      HWM'
Else ,
 Queue '     Storage Area     Start      End           Size' ,
       '     Used     Conv'
Queue '          '
If zARCH = 2 then ,
  Queue '              PSA     00000000   00001FFF        8K'
Else ,
  Queue '              PSA     00000000   00000FFF        4K'
Queue '           System    '     Right(LDASTRTS,8,'0') ' ' ,
   Right(SYSEND,8,'0')            Right(LDASIZS,8,' ')'K'
Queue '      Private V=R    '     Right(VRSTRT,8,'0') ' ' ,
   Right(VREND,8,'0')             Right(GDAVRSZ,8,' ')'K'
Queue '      Private V=V    '     Right(VVSTRT,8,'0') ' ' ,
   Right(VVEND,8,'0')             Right(LDASIZEA,8,' ')'K'
If Bitand(CVTOSLV2,'01'x) = '01'x then ,     /* OS/390 R10 and above */
Queue '              CSA    '     Right(GDACSAH,8,'0') ' ' ,
   Right(CSAEND,8,'0')            Right(GDACSASZ,8,' ')'K' ,
   Right(GDA_CSA_ALLOC,8,' ')'K         ' ,
   Right(GDACSAHWM,7,' ')'K'
Else ,
Queue '              CSA    '     Right(GDACSAH,8,'0') ' ' ,
   Right(CSAEND,8,'0')            Right(GDACSASZ,8,' ')'K' ,
   Right(GDA_CSA_ALLOC,8,' ')'K'
Queue '             MLPA    '     Right(CVTMLPAS,8,'0') ' ' ,
   Right(CVTMLPAE,8,'0')          Right(MLPASZ,8,' ')'K'
Queue '             FLPA    '     Right(CVTFLPAS,8,'0') ' ' ,
   Right(CVTFLPAE,8,'0')          Right(FLPASZ,8,' ')'K'
Queue '             PLPA    '     Right(CVTPLPAS,8,'0') ' ' ,
   Right(CVTPLPAE,8,'0')          Right(PLPASZ,8,' ')'K'
If Bitand(CVTOSLV2,'01'x) = '01'x then ,     /* OS/390 R10 and above */
Queue '              SQA    '     Right(GDASQAH,8,'0') ' ' ,
   Right(SQAEND,8,'0')            Right(GDASQASZ,8,' ')'K' ,
   Right(GDA_SQA_ALLOC,8,' ')'K'  Right(GDA_CSA_CONV,7,' ')'K' ,
   Right(GDASQAHWM,7,' ')'K'
Else ,
Queue '              SQA    '     Right(GDASQAH,8,'0') ' ' ,
   Right(SQAEND,8,'0')            Right(GDASQASZ,8,' ')'K' ,
   Right(GDA_SQA_ALLOC,8,' ')'K'  Right(GDA_CSA_CONV,7,' ')'K'
Queue '      R/W Nucleus    '     Right(CVTRWNS,8,'0') ' ' ,
   Right(CVTRWNE,8,'0')           Right(RWNUCSZ,8,' ')'K'
Queue '      R/O Nucleus    '     Right(CVTRONS,8,'0') ' ' ,
   Right('FFFFFF',8,'0')          Right(RONUCSZB,8,' ')'K',
   '(Spans 16M line)'
Queue '             16M line -----------------------------'
Queue ' Ext. R/O Nucleus    '     Right('1000000',8,'0') ' ' ,
   Right(CVTRONE,8,'0')           Right(RONUCSZA,8,' ')'K' ,
   '(Total' RONUCSZ'K)'
Queue ' Ext. R/W Nucleus    '     Right(CVTERWNS,8,'0') ' ' ,
   Right(CVTERWNE,8,'0')          Right(ERWNUCSZ,8,' ')'K'
If Bitand(CVTOSLV2,'01'x) = '01'x then ,     /* OS/390 R10 and above */
Queue '         Ext. SQA    '     Right(GDAESQAH,8,'0') ' ' ,
   Right(ESQAEND,8,'0')           Right(GDAESQAS,8,' ')'K' ,
   Right(GDA_ESQA_ALLOC,8,' ')'K' Right(GDA_ECSA_CONV,7,' ')'K',
   Right(GDAESQAHWM,7,' ')'K'
Else ,
Queue '         Ext. SQA    '     Right(GDAESQAH,8,'0') ' ' ,
   Right(ESQAEND,8,'0')           Right(GDAESQAS,8,' ')'K' ,
   Right(GDA_ESQA_ALLOC,8,' ')'K' Right(GDA_ECSA_CONV,7,' ')'K'
Queue '        Ext. PLPA    '     Right(CVTEPLPS,8,'0') ' ' ,
   Right(CVTEPLPE,8,'0')          Right(EPLPASZ,8,' ')'K'
Queue '        Ext. FLPA    '     Right(CVTEFLPS,8,'0') ' ' ,
   Right(CVTEFLPE,8,'0')          Right(EFLPASZ,8,' ')'K'
Queue '        Ext. MLPA    '     Right(CVTEMLPS,8,'0') ' ' ,
   Right(CVTEMLPE,8,'0')          Right(EMLPASZ,8,' ')'K'
If Bitand(CVTOSLV2,'01'x) = '01'x then ,     /* OS/390 R10 and above */
Queue '         Ext. CSA    '     Right(GDAECSAH,8,'0') ' ' ,
   Right(ECSAEND,8,'0')           Right(GDAECSAS,8,' ')'K' ,
   Right(GDA_ECSA_ALLOC,8,' ')'K         ' ,
   Right(GDAECSAHWM,7,' ')'K'
Else ,
Queue '         Ext. CSA    '     Right(GDAECSAH,8,'0') ' ' ,
   Right(ECSAEND,8,'0')           Right(GDAECSAS,8,' ')'K' ,
   Right(GDA_ECSA_ALLOC,8,' ')'K'
Queue '     Ext. Private    '     Right(GDAEPVTH,8,'0') ' ' ,
   Right(EPVTEND,8,'0')           Right(GDAEPVTS,8,' ')'M'
End  /* else do (VMAP <> 'HIGHFIRST')  */

If bitand(CVTOSLV3,'02'x) = '02'x then do   /* z/OS 1.5 and above?   */
                            /* Yes, get HVSHARE info from the RCE    */
  RCELVSHRSTRT   = C2d(Storage(D2x(RCE + 544),8))  /* low virt addr  */
                                                   /* for 64-bit shr */
  RCELVSHRSTRT_D = C2x(Storage(D2x(RCE + 544),8))  /* make readable  */
  VSHRSTRT_D     = Substr(RCELVSHRSTRT_D,1,8) ,    /*  address range */
                   Substr(RCELVSHRSTRT_D,9,8)      /*   display      */
  RCELVHPRSTRT   = C2d(Storage(D2x(RCE + 552),8))  /* low virt addr  */
                                                   /* for 64-bit prv */
  RCELVHPRSTRT_D = C2d(Storage(D2x(RCE + 552),8)) -1 /*make readable */
  RCELVHPRSTRT_D = Right(D2x(RCELVHPRSTRT_D),16,'0') /* address      */
  VHPRSTRT_D     = Substr(RCELVHPRSTRT_D,1,8) ,    /*   range        */
                   Substr(RCELVHPRSTRT_D,9,8)      /*   display      */
  TOTAL_VHSHR    = RCELVHPRSTRT - RCELVSHRSTRT     /* total shared   */
  TOTAL_VHSHR    = TOTAL_VHSHR/1024/1024           /* change to MB   */
  TOTAL_VHSHR    = FORMAT_MEMSIZE(TOTAL_VHSHR)     /* format size    */

  RCELVSHRSTRT   = RCELVSHRSTRT/1024/1024          /* change to MB   */
  RCELVSHRSTRT   = FORMAT_MEMSIZE(RCELVSHRSTRT)    /* format size    */

  RCELVHPRSTRT   = RCELVHPRSTRT/1024/1024          /* change to MB   */
  RCELVHPRSTRT   = FORMAT_MEMSIZE(RCELVHPRSTRT)    /* format size    */

  RCELVSHRPAGES  = C2d(Storage(D2x(RCE + 584),8))  /* shr pages      */
  RCELVSHRPAGES  = (RCELVSHRPAGES*4)/1024          /* change to MB   */
  RCELVSHRPAGES  = FORMAT_MEMSIZE(RCELVSHRPAGES)   /* format size    */

  RCELVSHRGBYTES = C2d(Storage(D2x(RCE + 592),8))  /* shr bytes HWM  */
  RCELVSHRGBYTES = RCELVSHRGBYTES/1024/1024        /* change to MB   */
  RCELVSHRGBYTES = FORMAT_MEMSIZE(RCELVSHRGBYTES)  /* format size    */

  Queue '   '
  Queue '  64-Bit Shared Virtual Storage (HVSHARE):'
  Queue '   '
  Queue '    Shared storage total:' TOTAL_VHSHR
  Queue '    Shared storage range:' RCELVSHRSTRT'-'RCELVHPRSTRT ,
        '('VSHRSTRT_D' - 'VHPRSTRT_D')'
  Queue '    Shared storage allocated:' RCELVSHRPAGES
  Queue '    Shared storage allocated HWM:' RCELVSHRGBYTES

End /* If bitand(CVTOSLV3,'02'x) = '02'x  */

If bitand(CVTOSLV5,'08'x) = '08'x then do   /* z/OS 1.10 and above   */
                            /* Yes, get HVCOMMON info from the RCE   */
  RCEHVCommonStrt = C2d(Storage(D2x(RCE + 872),8)) /*low virt addr */
                                                   /*for 64-bit cmn*/
  CommonStrt_D   = C2x(Storage(D2x(RCE + 872),8))  /*make readable */
  CommonStrt_D   = Substr(CommonStrt_D,1,8) ,      /* address range*/
                   Substr(CommonStrt_D,9,8)        /*  display     */

  RCEHVCommonEnd = C2d(Storage(D2x(RCE + 880),8))  /*high virt addr*/
                                                   /*for 64-bit cmn*/
  RCEHVCommonEnd = RCEHVCommonEnd + 1              /* Add 1 to addr*/
  CommonEnd_D    = C2x(Storage(D2x(RCE + 880),8))  /*make readable */
  CommonEnd_D    = Substr(CommonEnd_D,1,8) ,       /* address range*/
                   Substr(CommonEnd_D,9,8)         /*  display     */

  TOTAL_VHCOMN   = RCEHVCommonEnd-RCEHVCommonStrt  /* total common */
  TOTAL_VHCOMN   = TOTAL_VHCOMN/1024/1024          /* change to MB */
  TOTAL_VHCOMN   = FORMAT_MEMSIZE(TOTAL_VHCOMN)    /* format size  */

  RCEHVCommonStrt = RCEHVCommonStrt/1024/1024      /* chg to MB    */
  RCEHVCommonStrt = FORMAT_MEMSIZE(RCEHVCommonStrt) /* format size */

  RCEHVCommonEnd = RCEHVCommonEnd/1024/1024        /* chg to MB    */
  RCEHVCommonEnd = FORMAT_MEMSIZE(RCEHVCommonEnd)  /* format  size */

  RCEHVCommonPAGES = C2d(Storage(D2x(RCE + 888),8)) /* comn pages  */
  RCEHVCommonPAGES = (RCEHVCommonPAGES*4)/1024      /* chg to MB   */
  RCEHVCommonPAGES = FORMAT_MEMSIZE(RCEHVCommonPAGES) /*format size*/

  RCEHVCommonHWMBytes = C2d(Storage(D2x(RCE + 896),8)) /* comn HWM */
  RCEHVCommonHWMBytes = RCEHVCommonHWMBytes/1024/1024  /*chg to MB */
  RCEHVCommonHWMBytes = FORMAT_MEMSIZE(RCEHVCommonHWMBytes) /* fmt */

  Queue '   '
  Queue '  64-Bit Common Virtual Storage (HVCOMMON):'
  Queue '   '
  Queue '    Common storage total:' TOTAL_VHCOMN
  Queue '    Common storage range:' RCEHVCommonStrt'-'RCEHVCommonEnd ,
        '('CommonStrt_D' - 'CommonEnd_D')'
  Queue '    Common storage allocated:' RCEHVCommonPAGES
  Queue '    Common storage allocated HWM:' RCEHVCommonHWMBytes
End /* If bitand(CVTOSLV5,'08'x) = '08'x  */
If Bitand(CVTOSLV5,'10'x) = '10'x &     ,   /* z/OS 1.9 and above &  */
   Bitand(CVTFLAG2,'01'x) = '01'x then do   /*  CVTEDAT on (z10 >)?  */
  LARGEMEM = 1                              /* set LARGEMEM avail flg*/
  RCEReconLFASize  = C2d(Storage(D2x(RCE + 760),8)) /* recon lfarea  */
  RCENonReconLFASize = C2d(Storage(D2x(RCE + 768),8)) /*  LFAREA     */
 /* Comment out or delete the next 2 lines of code if you want the   */
 /* large memory displays even if you specified or defaulted to      */
 /* LFAREA=0M (z/OS 1.9 & above) and have the hardware support.      */
  If RCEReconLFASize = 0 & RCENonReconLFASize = 0 then ,  /* both 0? */
   LARGEMEM = 0
  If Bitand(CVTOSLV6,'80'x) = '80'x then do /* z/OS 2.1 and above    */
    PL = 1                                  /* pageable1m + 2.1 & >  */
    /*****************/
    /* 2G frame code */
    /*****************/
    RCE2GMemoryObjects          = ,
     C2d(Storage(D2x(RCE + 1256),8))    /* Number of 2G objects      */
    RCE2GNonReconLFASize        = ,
     C2d(Storage(D2x(RCE + 1272),8))    /* 2G frame area in 2G units */
    RCE2GNonReconLFAUsed        = ,
     C2d(Storage(D2x(RCE + 1280),8))    /* used 2G frames            */
    RCE2GHWM                    = ,
     C2d(Storage(D2x(RCE + 1288),4))    /* 2G used frames HWM        */
    If RCE2GNonReconLFASize <> 0 then LARGEMEM = 1  /* lfarea used   */
  End
    Else PL = 0                             /* no pageable1m         */
End /* If Bitand(CVTOSLV5,'10'x) */
   Else LARGEMEM = 0                        /* < z/OS 1.9/no hw supt */
If LARGEMEM = 1 then do                      /* z/OS 1.10 & above  */
  RCELargeMemoryObjects = ,
   C2d(Storage(D2x(RCE + 744),8))             /*tot large mem objs */
  RCELargePagesBackedinReal = ,
   C2d(Storage(D2x(RCE + 752),8))             /* tot lrg obj pages */
  RCELFAvailGroups          = ,
   C2d(Storage(D2x(RCE + 796),4))             /* avial lrg frames  */
  RCEReconLFAUsed             = ,
   C2d(Storage(D2x(RCE + 776),8))    /* # recon 1M frames alloc    */
  RCENonReconLFAUsed          = ,
   C2d(Storage(D2x(RCE + 784),8))    /* # nonrecon 1M frames alloc */

  LFASize = RCEReconLFASize + RCENonReconLFASize     /* LFAREA size*/
  LFA_Used    = RCEReconLFAUsed + RCENonReconLFAUsed /* used LFAREA*/
  LFA_Alloc1M = RCELargePagesBackedinReal            /* 1M alloc   */
  LFA_Alloc4K = LFA_Used - LFA_Alloc1M               /* 4K alloc   */

  If PL = 1 then do            /* z/OS 2.1 / pageable1m support    */
    RCELargeUsed4K              = ,
     C2d(Storage(D2x(RCE + 1032),4))      /* 4K used for 1M req    */
    LFA_Alloc4K = RCELargeUsed4K     /* chg var name for old code  */
    RceLargeAllocatedPL         = ,
     C2d(Storage(D2x(RCE + 1244),4))      /* # used pageable1m     */
    RceLargeUsedPLHWM           = ,
     C2d(Storage(D2x(RCE + 1252),4))      /* pageable1m HWM        */
  End

  LFASize     = FORMAT_MEMSIZE(LFASize)          /* format size    */
  LFA_Avail   = FORMAT_MEMSIZE(RCELFAvailGroups) /* format size    */
  LFA_Alloc1M = FORMAT_MEMSIZE(LFA_Alloc1M)      /* format size    */
  LFA_Alloc4K = FORMAT_MEMSIZE(LFA_Alloc4K)      /* format size    */

  If PL = 1 then do            /* z/OS 2.1 + pageable1m support    */
    RceLargeAllocatedPL = FORMAT_MEMSIZE(RceLargeAllocatedPL)
    RceLargeUsedPLHWM   = FORMAT_MEMSIZE(RceLargeUsedPLHWM)
    /*****************/
    /* 2G frame code */
    /*****************/
    LFA2G_Size  = FORMAT_MEMSIZE(RCE2GNonReconLFASize*2048)
    LFA2G_Used  = FORMAT_MEMSIZE(RCE2GNonReconLFAUsed*2048)
    LFA2G_avail = ((RCE2GNonReconLFASize-RCE2GNonReconLFAUsed)*2048)
    LFA2G_avail = FORMAT_MEMSIZE(LFA2G_avail)
    LFA2G_Max   = RCE2GHWM*2048
    LFA2G_Max   = FORMAT_MEMSIZE(LFA2G_Max)
  End

  If Bitand(CVTOSLV5,'04'x) = '04'x then do /* z/OS 1.12 and above */
    RceLargeUsed1MHWM           = ,
     C2d(Storage(D2x(RCE + 804),4)) /*large pg HWM alloc behalf 1M */
    RceLargeUsed4KHWM           = ,
     C2d(Storage(D2x(RCE + 808),4)) /*large pg HWM alloc behalf 4K */
    LFA_Max1M = FORMAT_MEMSIZE(RceLargeUsed1MHWM)  /* format size  */
    LFA_Max4K = FORMAT_MEMSIZE(RceLargeUsed4KHWM)  /* format size  */
  End

  Queue '   '
  Queue '  64-Bit Large Memory Virtual Storage (LFAREA):'
  Queue '   '
  If PL = 1 then do            /* z/OS 2.1 / pageable1m support    */
    Queue '    Large memory area (LFAREA)    :' LFASize ',' LFA2G_Size
    Queue '    Large memory storage available:' LFA_Avail ',' ,
               LFA2G_avail
  End
  Else do
    Queue '    Large memory area (LFAREA)    :' LFASize
    Queue '    Large memory storage available:' LFA_Avail
  End
  Queue '    Large memory storage allocated (1M):' LFA_Alloc1M
  Queue '    Large memory storage allocated (4K):' LFA_Alloc4K
  If Bitand(CVTOSLV5,'04'x) = '04'x then do /* z/OS 1.12 and above */
    Queue '    Large memory storage allocated HWM (1M):' LFA_Max1M
    Queue '    Large memory storage allocated HWM (4K):' LFA_Max4K
  End
  If PL = 1 then do            /* z/OS 2.1 / pageable1m support    */
    Queue '    Large memory storage allocated (PAGEABLE1M):' ,
     RceLargeAllocatedPL
    Queue '    Large memory storage allocated HWM (PAGEABLE1M):' ,
     RceLargeUsedPLHWM
    Queue '    Large memory storage allocated (2G):' LFA2G_Used ,
          '/' RCE2GNonReconLFAUsed 'pages'
    Queue '    Large memory storage allocated HWM (2G):' LFA2G_Max ,
          '/' RCE2GHWM 'pages'
  End
  Queue '    Large memory objects allocated:' RCELargeMemoryObjects
  If PL = 1 then ,             /* z/OS 2.1 / pageable1m support    */
    Queue '    Large memory objects allocated (2G):' RCE2GMemoryObjects
End
End  /* If VMAPOPT <> 'NODISP' */
Return

PAGE:                /* Page Data Sets information sub-routine       */
Queue ' '
Queue 'Page Data Set Usage:'
Queue '  Type     Full     Slots  Dev   Volser  Data Set Name'
ASMPART  = C2d(Storage(D2x(ASMVT + 8),4))  /* Pnt to Pag Act Ref Tbl */
PARTSIZE = C2d(Storage(D2x(ASMPART+4),4))  /* Tot number of entries  */
PARTDSNL = C2d(Storage(D2x(ASMPART+24),4)) /* Point to 1st pg dsn    */
PARTENTS = ASMPART+80                      /* Point to 1st parte     */
Do I = 1 to PARTSIZE
  If I > 1 then do
    PARTENTS = PARTENTS + 96
    PARTDSNL = PARTDSNL + 44
  End
  CHKINUSE = Storage(D2x(PARTENTS+9),1)    /* in use flag            */
  If Bitand(CHKINUSE,'80'x) = '80'x then iterate /* not in use       */
  PGDSN    = Storage(D2x(PARTDSNL),44)     /* page data set name     */
  PGDSN    = Strip(PGDSN,'T')              /* remove trailing blanks */
  PARETYPE = Storage(D2x(PARTENTS+8),1)    /* type flag              */
  Select
    When Bitand(PARETYPE,'80'x) = '80'x then PGTYPE = ' PLPA    '
    When Bitand(PARETYPE,'40'x) = '40'x then PGTYPE = ' COMMON  '
    When Bitand(PARETYPE,'20'x) = '20'x then PGTYPE = ' DUPLEX  '
    When Bitand(PARETYPE,'10'x) = '10'x then PGTYPE = ' LOCAL   '
    Otherwise PGTYPE = '??????'
  End  /* Select */
  If PGTYPE = ' LOCAL   ' then do
    PAREFLG1  = Storage(D2x(PARTENTS+9),1)    /* PARTE flags         */
    If Bitand(PAREFLG1,'10'x) = '10'x then PGTYPE = ' LOCAL NV'
  End
  PAREUCBP = C2d(Storage(D2x(PARTENTS+44),4)) /* point to UCB        */
  PGUCB    = C2x(Storage(D2x(PAREUCBP+4),2))  /* UCB address         */
  PGVOL    = Storage(D2x(PAREUCBP+28),6)      /* UCB volser          */
  PARESZSL = C2d(Storage(D2x(PARTENTS+16),4)) /* total slots         */
  PARESZSL = Right(PARESZSL,9,' ')            /* ensure 9 digits     */
  PARESLTA = C2d(Storage(D2x(PARTENTS+20),4)) /* avail. slots        */
  PGFULL   = ((PARESZSL-PARESLTA) / PARESZSL) * 100 /* percent full  */
  PGFULL   = Format(PGFULL,3,2)               /* force 2 decimals    */
  PGFULL   = Left(PGFULL,3)                   /* keep intiger only   */
  Queue  ' 'PGTYPE' 'PGFULL'% 'PARESZSL'  'PGUCB' ' ,
         PGVOL'  'PGDSN
End  /* do I=1 to partsize */
/*********************************************************************/
/* SCM - Storage Class Memory                                        */
/* ASMVX - SYS1.MODGEN(ILRASMVX) pointed to in SYS1.MODGEN(ILRASMVT) */
/*********************************************************************/
 /*If Bitand(CVTOSLV5,'01'x) = '01'x then do */ /* z/OS 1.13 and > */
If Bitand(CVTOSLV6,'80'x) = '80'x then do    /* z/OS 2.1  and above  */
  SCMSTATUS = 'NOT-USED'                     /* set dflt to not used */
  ASMVX = C2d(Storage(D2x(ASMVT + 1236),4))  /* point to ASM tbl ext */
  SCMBLKSAVAIL = C2d(Storage(D2x(ASMVX + 8),8))   /* SCM blks avail  */
  SCMNVBC      = C2d(Storage(D2x(ASMVX + 16),8))  /* SCM blks used   */
  SCMERRS      = C2d(Storage(D2x(ASMVX + 24),8))  /* bad SCM blks    */
  If (SCMBLKSAVAIL > 0) then do              /* SCM is used          */
    SCMSTATUS = 'IN-USE  '                   /* status is IN-USE     */
    SCMPCTUSED = Trunc(SCMNVBC*100/SCMBLKSAVAIL)  /* percent used    */
    SCMPCTUSED = Format(SCMPCTUSED,3,2)      /* format for display   */
    SCMPCTUSED = Left(SCMPCTUSED,3)          /* format for display   */
    Call FORMAT_COMMAS SCMBLKSAVAIL          /* format with commas   */
    SCMBLKSAVAIL = FORMATTED_WHOLENUM        /* save number          */
    Call FORMAT_COMMAS SCMNVBC               /* format with commas   */
    SCMNVBC      = FORMATTED_WHOLENUM        /* save number          */
    Call FORMAT_COMMAS SCMERRS               /* format with commas   */
    SCMERRS      = FORMATTED_WHOLENUM        /* save number          */
    SCMBLKSAVAIL = Right(SCMBLKSAVAIL,16)    /* format for display   */
    SCMNVBC      = Right(SCMNVBC,16)         /* format for display   */
    SCMERRS      = Right(SCMERRS,16)         /* format for display   */
  End
  Queue ' '
  Queue 'Storage Class Memory:'
  Queue '  STATUS      FULL               SIZE             USED' ,
        '        IN-ERROR'
  If SCMSTATUS = 'NOT-USED' then Queue ' ' SCMSTATUS
  Else do
    Queue ' ' SCMSTATUS '  ' SCMPCTUSED !! '%  '  ,
          SCMBLKSAVAIL SCMNVBC SCMERRS
  End
End
Return

SMF:                 /* SMF Data Set information sub-routine         */
Queue ' '
Queue 'SMF Data Set Usage:'
Queue '  Name                      Volser   Size(Blks)  %Full  Status'
SMCAMISC = Storage(D2x(SMCA + 1),1)          /* misc. indicators     */
If bitand(SMCAMISC,'80'x) <> '80'x then do   /* smf active ??        */
  Queue '  *** SMF recording not being used ***'
  Return
End
SMCAFRDS = C2d(Storage(D2x(SMCA + 244),4))   /* point to first RDS   */
SMCALRDS = C2d(Storage(D2x(SMCA + 248),4))   /* point to last RDS    */
SMCASMCX = C2d(Storage(D2x(SMCA + 376),4))   /* point to SMCX        */
SMCXLSBT = Storage(D2x(SMCASMCX + 88),1)     /* logstream bits       */
If Bitand(SMCXLSBT,'80'x) = '80'x then do    /* logstream recording? */
  If SMCAFRDS = SMCALRDS then do
    Queue '  ***       SMF LOGSTREAM recording is active       ***'
    Queue '  *** LOGSTREAM information not available via REXX  ***'
  Return
  End
  Else do
    Queue '  ***       SMF LOGSTREAM recording is active       ***'
    Queue '  *** LOGSTREAM information not available via REXX  ***'
    Queue '  ***     SMF data sets listed below not in use     ***'
  End
End /* If Bitand(SMCXLSBT,'80'x) */
If SMCAFRDS = SMCALRDS then do
  Queue '  ***    No SMF data sets available     ***'
  Return
End
Do until SMCAFRDS = SMCALRDS    /* end loop when next rds ptr = last */
  RDSNAME  =  Strip(Storage(D2x(SMCAFRDS + 16),44))  /* smf dsn      */
  RDSVOLID = Storage(D2x(SMCAFRDS + 60),6)           /* smf volser   */
  RDSCAPTY = C2d(Storage(D2x(SMCAFRDS + 76),4))      /* size in blks */
  RDSNXTBL = C2d(Storage(D2x(SMCAFRDS + 80),4))      /* next avl blk */
  /* RDSPCT  = (RDSNXTBL / RDSCAPTY) * 100 */ /* not how mvs does it */
  RDSPCT   = Trunc((RDSNXTBL / RDSCAPTY) * 100) /* same as mvs disp. */
  RDSFLG1  = Storage(D2x(SMCAFRDS + 12),1)     /* staus flags        */
  Select
    When Bitand(RDSFLG1,'10'x) = '10'x then RDSSTAT = 'FREE REQUIRED'
    When Bitand(RDSFLG1,'08'x) = '08'x then RDSSTAT = 'DUMP REQUIRED'
    When Bitand(RDSFLG1,'04'x) = '04'x then RDSSTAT = 'ALTERNATE'
    When Bitand(RDSFLG1,'02'x) = '02'x then RDSSTAT = 'CLOSE PENDING'
    When Bitand(RDSFLG1,'01'x) = '01'x then RDSSTAT = 'OPEN REQUIRED'
    When Bitand(RDSFLG1,'00'x) = '00'x then RDSSTAT = 'ACTIVE'
    Otherwise RDSSTAT = '??????'
  End  /* Select */
  If (RDSSTAT = 'ACTIVE' ! RDSSTAT = 'DUMP REQUIRED') , /* display   */
    & RDSPCT = 0 then RDSPCT = 1    /* %full the same way mvs does   */
  SMCAFRDS = C2d(Storage(D2x(SMCAFRDS + 4),4)) /* point to next RDS  */
  If Length(RDSNAME) < 26 then do
    Queue ' ' Left(RDSNAME,25,' ') RDSVOLID  Right(RDSCAPTY,11,' ') ,
              ' 'Format(RDSPCT,5,0) ' ' RDSSTAT
  End
  Else do
    Queue ' ' RDSNAME
    Queue copies(' ',27) RDSVOLID  Right(RDSCAPTY,11,' ') ,
              ' 'Format(RDSPCT,5,0) ' ' RDSSTAT
  End
End
Return

SUB:                 /* Subsystem information sub-routine            */
Arg SUBOPT
SSCVT    = C2d(Storage(D2x(JESCT+24),4))     /* point to SSCVT       */
SSCVT2   = SSCVT           /* save address for second loop           */
If SUBOPT <> 'FINDJES' then do
  Queue ' '
  Queue 'Subsystem Communications Vector Table:'
  Queue '  Name   Hex        SSCTADDR   SSCTSSVT' ,
        '  SSCTSUSE   SSCTSUS2   Status'
End /* if subopt */
Do until SSCVT = 0
  SSCTSNAM = Storage(D2x(SSCVT+8),4)         /* subsystem name       */
  SSCTSSVT = C2d(Storage(D2x(SSCVT+16),4))   /* subsys vect tbl ptr  */
  SSCTSUSE = C2d(Storage(D2x(SSCVT+20),4))   /* SSCTSUSE pointer     */
  SSCTSUS2 = C2d(Storage(D2x(SSCVT+28),4))   /* SSCTSUS2 pointer     */
  If SUBOPT = 'FINDJES' & SSCTSNAM = JESPJESN then do
     JESSSVT  = SSCTSSVT   /* save SSVTSSVT for "version" section    */
                           /* this points to JES3 Subsystem Vector   */
                           /* Table, mapped by IATYSVT               */
     JESSUSE  = SSCTSUSE   /* save SSCTSUSE for "version" section    */
                           /* this points to version for JES2        */
     JESSUS2  = SSCTSUS2   /* save SSCTSUS2 for "version" section    */
                           /* this points to $HCCT for JES2          */
     Leave  /* found JES info for version section, exit loop */
  End /* if subopt */
  SSCTSNAX = C2x(SSCTSNAM)    /* chg to EBCDIC for non-display chars */
  Call XLATE_NONDISP SSCTSNAM /* translate non display chars         */
  SSCTSNAM = RESULT           /* result from XLATE_NONDISP           */
  If SSCTSSVT = 0 then SSCT_STAT = 'Inactive'
    Else SSCT_STAT = 'Active'
  If SUBOPT <> 'FINDJES' then do
    Queue ' ' SSCTSNAM ' ' SSCTSNAX  ,
          ' ' Right(D2x(SSCVT),8,0)    ' ' Right(D2x(SSCTSSVT),8,0) ,
          ' ' Right(D2x(SSCTSUSE),8,0) ' ' Right(D2x(SSCTSUS2),8,0) ,
          ' ' SSCT_STAT ' '
  End /* if SUBOPT */
 /*SSCTSSID = C2d(Storage(D2x(SSCVT+13),1)) */ /* subsys identifier  */
 /*If bitand(SSCTSSID,'02'x) = '02'x then JESPJESN = 'JES2' */
 /*If bitand(SSCTSSID,'03'x) = '03'x then JESPJESN = 'JES3'*/
  SSCVT    = C2d(Storage(D2x(SSCVT+4),4))    /* next sscvt or zero   */
End /* do until sscvt = 0 */
If SUBOPT <> 'FINDJES' then do
  Queue ' '
  Queue 'Supported Subsystem Function Codes:'
  Do until SSCVT2 = 0 /* 2nd loop for function codes                 */
    SSCTSNAM = Storage(D2x(SSCVT2+8),4)        /* subsystem name     */
    SSCTSSVT = C2d(Storage(D2x(SSCVT2+16),4)) /* subsys vect tbl ptr */
    SSCTSNAX = C2x(SSCTSNAM)  /* chg to EBCDIC for non-display chars */
    Call XLATE_NONDISP SSCTSNAM /* translate non display chars       */
    SSCTSNAM = RESULT           /* result from XLATE_NONDISP         */
    Queue ' ' SSCTSNAM '(X''' !! SSCTSNAX !! ''')'
    If SSCTSSVT <> 0 then do
      SSVTFCOD = SSCTSSVT + 4                  /* pt to funct. matrix*/
      SSFUNCTB = Storage(D2X(SSVTFCOD),255)    /* function matrix    */
      TOTFUNC = 0       /* counter for total functions per subsystem */
      Drop FUNC.        /* init stem to null for saved functions     */
      Do SUPFUNC = 1 TO 255
        If Substr(SSFUNCTB,SUPFUNC,1) <> '00'x then do /* supported? */
          TOTFUNC = TOTFUNC + 1 /* tot functions for this subsystem  */
          FUNC.TOTFUNC = SUPFUNC  /* save function in stem           */
        End
      End /* do supfunc */
      /***************************************************************/
      /* The following code is used to list the supported function   */
      /* codes by ranges. For example: 1-10,13,18-30,35,70,143-145   */
      /***************************************************************/
      If TOTFUNC >= 1 then do   /* begin loop to list function codes */
        ALLCODES = ''                   /* init var to nulls         */
        NEWRANGE = 'YES'                /* init newrange flag to YES */
        FIRSTRNG = 'YES'                /* init firstrng flag to YES */
        Do FCODES = 1 to TOTFUNC        /* loop though codes         */
          JUNK = TOTFUNC + 1            /* prevent NOVALUE cond.     */
          FUNC.JUNK = ''                /*  in func.chknext at end   */
          CHKNEXT = FCODES + 1          /* stem var to chk next code */
          If FUNC.FCODES + 1 = FUNC.CHKNEXT then do  /* next matches */
            If NEWRANGE = 'YES' & FIRSTRNG = 'YES' then do /* first  */
              ALLCODES =  ALLCODES !! FUNC.FCODES !! '-'   /* in new */
              NEWRANGE = 'NO'                    /* range - seperate */
              FIRSTRNG = 'NO'                    /* with a dash      */
              Iterate                            /* get next code    */
            End /* if newrange = 'yes' & firstrng = 'yes'            */
            If NEWRANGE = 'YES' & FIRSTRNG = 'NO' then do /* next    */
              ALLCODES =  ALLCODES !! FUNC.FCODES  /* matches, but   */
              NEWRANGE = 'NO'   /* is not the first, don't add dash  */
              Iterate                            /* get next code    */
            End /* if newrange = 'yes' & firstrng = 'no'             */
            Else iterate  /* same range + not first - get next code  */
          End /* func.fcodes + 1 */
          If FCODES = TOTFUNC then , /* next doesn't match and this  */
            ALLCODES =  ALLCODES !! FUNC.FCODES  /* is the last code */
          Else do /* next code doesn't match - seperate with comma   */
            ALLCODES =  ALLCODES !! FUNC.FCODES !! ','
            NEWRANGE = 'YES'         /* re-init newrange flag to YES */
            FIRSTRNG = 'YES'         /* re-init firstrng flag to YES */
          End
        End /* do fcodes = 1 to totfunc */
        /*************************************************************/
        /* The code below splits up the ranges to multiple lines if  */
        /* they won't all fit on a single line due to IPLINFO lrecl. */
        /*************************************************************/
        FUN_MAXL = 68      /* max length b4 need to split out codes  */
        If Length(ALLCODES) <= FUN_MAXL then ,  /* fits on one line  */
          Queue '    Codes:' ALLCODES
        Else do                            /* need to split up       */
          FUNSPLT = Pos(',',ALLCODES,FUN_MAXL-6)   /* split at comma */
          ALLCODES_1 = Substr(ALLCODES,1,FUNSPLT)  /* 1st part       */
          ALLCODES_2 = Strip(Substr(ALLCODES,FUNSPLT+1,FUN_MAXL))
          Queue '    Codes:' ALLCODES_1
          Queue '          ' ALLCODES_2
        End /* else do */
      End /* if totfunc >= 1 */
    End
    Else queue '    *Inactive*'
    SSCVT2   = C2d(Storage(D2x(SSCVT2+4),4))   /* next sscvt or zero */
  End /* do until sscvt2 = 0 */
End /* if subopt <> 'findjes' */
Return

ASID:                /* ASVT Usage sub-routine                       */
Queue ' '
CVTASVT  = C2d(Storage(D2x(CVT+556),4))     /* point to ASVT         */
ASVTMAXU = C2d(Storage(D2x(CVTASVT+516),4)) /* max number of entries */
ASVTMAXI = C2d(Storage(D2x(CVTASVT+500),4)) /* MAXUSERS from ASVT    */
ASVTAAVT = C2d(Storage(D2x(CVTASVT+480),4)) /* free slots in ASVT    */
ASVTSTRT = C2d(Storage(D2x(CVTASVT+492),4)) /* RSVTSTRT from ASVT    */
ASVTAST  = C2d(Storage(D2x(CVTASVT+484),4)) /* free START/SASI       */
ASVTNONR = C2d(Storage(D2x(CVTASVT+496),4)) /* RSVNONR  from ASVT    */
ASVTANR  = C2d(Storage(D2x(CVTASVT+488),4)) /* free non-reusable     */
Queue 'ASID Usage Summary from the ASVT:'
Queue '  Maximum number of ASIDs:' Right(ASVTMAXU,5,' ')
Queue '                          '
Queue '    MAXUSER from IEASYSxx:' Right(ASVTMAXI,5,' ')
Queue '             In use ASIDs:' Right(ASVTMAXI-ASVTAAVT,5,' ')
Queue '          Available ASIDs:' Right(ASVTAAVT,5,' ')
Queue '                          '
Queue '    RSVSTRT from IEASYSxx:' Right(ASVTSTRT,5,' ')
Queue '           RSVSTRT in use:' Right(ASVTSTRT-ASVTAST,5,' ')
Queue '        RSVSTRT available:' Right(ASVTAST,5,' ')
Queue '                          '
Queue '    RSVNONR from IEASYSxx:' Right(ASVTNONR,5,' ')
Queue '           RSVNONR in use:' Right(ASVTNONR-ASVTANR,5,' ')
Queue '        RSVNONR available:' Right(ASVTANR,5,' ')
Return

LPA:                 /* LPA List sub-routine                         */
CVTSMEXT = C2d(Storage(D2x(CVT + 1196),4))   /* point to stg map ext.*/
CVTEPLPS = C2d(Storage(D2x(CVTSMEXT+56),4))  /* start vaddr of ELPA  */
NUMLPA   = C2d(Storage(D2x(CVTEPLPS+4),4))   /* # LPA libs in table  */
LPAOFF   = 8                                 /* first ent in LPA tbl */
Queue '     '
Queue 'LPA Library List  ('NUMLPA' libraries):'
Queue '  POSITION    DSNAME'
Do I = 1 to NUMLPA
  LEN   = C2d(Storage(D2x(CVTEPLPS+LPAOFF),1)) /* length of entry    */
  LPDSN = Storage(D2x(CVTEPLPS+LPAOFF+1),LEN)  /* DSN of LPA library */
  LPAOFF = LPAOFF + 44 + 1                     /* next entry in table*/
  LPAPOS = Right(I,3)                        /* position in LPA list */
  RELLPPOS = Right('(+'I-1')',6)        /* relative position in list */
  Queue LPAPOS  RELLPPOS '  ' LPDSN
End
Return

LNKLST:              /* LNKLST sub-routine                           */
If Bitand(CVTOSLV1,'01'x) <> '01'x then do    /* below OS/390 R2     */
  CVTLLTA  = C2d(Storage(D2x(CVT + 1244),4))  /* point to lnklst tbl */
  NUMLNK   = C2d(Storage(D2x(CVTLLTA+4),4))   /* # LNK libs in table */
  LLTAPFTB = CVTLLTA + 8 + (NUMLNK*45)        /* start of LLTAPFTB   */
  LNKOFF   = 8                                /*first ent in LBK tbl */
  LKAPFOFF = 0                                /*first ent in LLTAPFTB*/
  Queue '     '
  Queue 'LNKLST Library List  ('NUMLNK' Libraries):'
  Queue '  POSITION    APF    DSNAME'
  Do I = 1 to NUMLNK
    LEN = C2d(Storage(D2x(CVTLLTA+LNKOFF),1))     /* length of entry */
    LKDSN = Storage(D2x(CVTLLTA+LNKOFF+1),LEN)    /* DSN of LNK lib  */
    CHKAPF = Storage(D2x(LLTAPFTB+LKAPFOFF),1)    /* APF flag        */
    If  bitand(CHKAPF,'80'x) = '80'x then LKAPF = 'Y'  /* flag on    */
      else LKAPF = ' '                            /* APF flag off    */
    LNKOFF = LNKOFF + 44 + 1                      /*next entry in tbl*/
    LKAPFOFF = LKAPFOFF + 1               /* next entry in LLTAPFTB  */
    LNKPOS = Right(I,3)                           /*position in list */
    RELLKPOS = Right('(+'I-1')',6)      /* relative position in list */
    Queue LNKPOS  RELLKPOS '   ' LKAPF '   ' LKDSN
  End
End
Else do  /* OS/390 1.2 and above - PROGxx capable LNKLST             */
  ASCB     = C2d(Storage(224,4))               /* point to ASCB      */
  ASSB     = C2d(Storage(D2x(ASCB+336),4))     /* point to ASSB      */
  DLCB     = C2d(Storage(D2x(ASSB+236),4))     /* point to CSVDLCB   */
  DLCBFLGS = Storage(d2x(DLCB + 32),1)         /* DLCB flag bits     */
  SETNAME  = Storage(D2x(DLCB + 36),16)        /* LNKLST set name    */
  SETNAME  = Strip(SETNAME,'T')                /* del trailing blanks*/
  CVTLLTA  = C2d(Storage(D2x(DLCB + 16),4))    /* point to lnklst tbl*/
  LLTX     = C2d(Storage(D2x(DLCB + 20),4))    /* point to LLTX      */
  NUMLNK   = C2d(Storage(D2x(CVTLLTA+4),4))    /* # LNK libs in table*/
  LLTAPFTB = CVTLLTA + 8 + (NUMLNK*45)         /* start of LLTAPFTB  */
  LNKOFF   = 8                                 /*first ent in LLT tbl*/
  VOLOFF   = 8                                 /*first ent in LLTX   */
  LKAPFOFF = 0                                /*first ent in LLTAPFTB*/
  If Bitand(DLCBFLGS,'10'x) = '10'x then ,     /* bit for LNKAUTH    */
       LAUTH = 'LNKLST'                        /* LNKAUTH=LNKLST     */
  Else LAUTH = 'APFTAB'                        /* LNKAUTH=APFTAB     */
  Queue '     '
  Queue 'LNKLST Library List - Set:' SETNAME ,
        ' LNKAUTH='LAUTH '('NUMLNK' Libraries):'
  If LAUTH = 'LNKLST' then ,
    Queue '     (All LNKLST data sets marked APF=Y due to' ,
          'LNKAUTH=LNKLST)'
  Queue '  POSITION    APF   VOLUME    DSNAME'
  Do I = 1 to NUMLNK
    LEN = C2d(Storage(D2x(CVTLLTA+LNKOFF),1))     /* length of entry */
    LKDSN = Storage(D2x(CVTLLTA+LNKOFF+1),LEN)    /* DSN of LNK lib  */
    LNKVOL = Storage(D2x(LLTX+VOLOFF),6)          /* VOL of LNK lib  */
    CHKAPF = Storage(D2x(LLTAPFTB+LKAPFOFF),1)    /* APF flag        */
    If  bitand(CHKAPF,'80'x) = '80'x then LKAPF = 'Y'    /* flag on  */
      else LKAPF = ' '                            /* APF flag off    */
    LNKOFF   = LNKOFF + 44 + 1                    /*next entry in LLT*/
    VOLOFF   = VOLOFF + 8                         /*next vol in LLTX */
    LKAPFOFF = LKAPFOFF + 1               /* next entry in LLTAPFTB  */
    LNKPOS   = Right(I,3)                         /*position in list */
    RELLKPOS = Right('(+'I-1')',6)      /* relative position in list */
    Queue LNKPOS  RELLKPOS '   ' LKAPF '  ' LNKVOL '  ' LKDSN
  End
End
Return

APF:                 /* APF List sub-routine                         */
CVTAUTHL = C2d(Storage(D2x(CVT + 484),4))    /* point to auth lib tbl*/
If CVTAUTHL <> C2d('7FFFF001'x) then do      /* dynamic list ?       */
  NUMAPF   = C2d(Storage(D2x(CVTAUTHL),2))   /* # APF libs in table  */
  APFOFF   = 2                               /* first ent in APF tbl */
  Queue '     '
  Queue 'APF Library List  ('NUMAPF' libraries):'
  Queue '  ENTRY   VOLUME    DSNAME'
  Do I = 1 to NUMAPF
    LEN = C2d(Storage(D2x(CVTAUTHL+APFOFF),1)) /* length of entry    */
    VOL = Storage(D2x(CVTAUTHL+APFOFF+1),6)    /* VOLSER of APF LIB  */
    DSN = Storage(D2x(CVTAUTHL+APFOFF+1+6),LEN-6)  /* DSN of apflib  */
    APFOFF = APFOFF + LEN +1
    APFPOS   = Right(I,4)                      /*position in APF list*/
    Queue '  'APFPOS '  ' VOL '  ' DSN
  End
End
Else Do
  ECVT     = C2d(Storage(D2x(CVT + 140),4))    /* point to CVTECVT   */
  ECVTCSVT = C2d(Storage(D2x(ECVT + 228),4))   /* point to CSV table */
  APFA = C2d(Storage(D2x(ECVTCSVT + 12),4))    /* APFA               */
  AFIRST = C2d(Storage(D2x(APFA + 8),4))       /* First entry        */
  ALAST  = C2d(Storage(D2x(APFA + 12),4))      /* Last  entry        */
  LASTONE = 0   /* flag for end of list     */
  NUMAPF = 1    /* tot # of entries in list */
  Do forever
    DSN.NUMAPF = Storage(D2x(AFIRST+24),44)    /* DSN of APF library */
    DSN.NUMAPF = Strip(DSN.NUMAPF,'T')         /* remove blanks      */
    CKSMS = Storage(D2x(AFIRST+4),1)           /* DSN of APF library */
    if  bitand(CKSMS,'80'x)  = '80'x           /*  SMS data set?     */
      then VOL.NUMAPF = '*SMS* '               /* SMS control dsn    */
    else VOL.NUMAPF = Storage(D2x(AFIRST+68),6)    /* VOL of APF lib */
    If Substr(DSN.NUMAPF,1,1) <> X2c('00')     /* check for deleted  */
      then NUMAPF = NUMAPF + 1                 /*   APF entry        */
    AFIRST = C2d(Storage(D2x(AFIRST + 8),4))   /* next  entry        */
    if LASTONE = 1 then leave
    If  AFIRST = ALAST then LASTONE = 1
  End
  Queue '     '
  Queue 'APF Library List  - Dynamic ('NUMAPF - 1' libraries):'
  Queue '  ENTRY   VOLUME    DSNAME'
  Do I = 1 to NUMAPF-1
    APFPOS   = Right(I,4)                      /*position in APF list*/
    Queue '  'APFPOS '  ' VOL.I '  ' DSN.I
  End
End
Return

SVC:                 /* SVC information sub-routine                  */
/*********************************************************************/
/* See SYS1.MODGEN(IHASVC) for descriptions of SVC attributes        */
/*********************************************************************/
CVTABEND  = C2d(Storage(D2x(CVT+200),4))     /* point to CVTABEND    */
SCVT      = CVTABEND        /* this is the SCVT -  mapped by IHASCVT */
SCVTSVCT  = C2d(Storage(D2x(SCVT+132),4))    /* point to SVCTABLE    */
SCVTSVCR  = C2d(Storage(D2x(SCVT+136),4))    /* point to SVC UPD TBL */
Call FIND_NUC 'IGCERROR'     /* Find addr of IGCERROR in NUC MAP     */
IGCERROR_ADDR = RESULT       /* Save address of IGCERROR             */
Call FIND_NUC 'IGCRETRN'     /* Find addr of IGCRETRN in NUC MAP     */
IGCRETRN_ADDR = RESULT       /* Save address of IGCRETRN             */
Call FIND_NUC 'IGXERROR'     /* Find addr of IGXERROR in NUC MAP     */
IGXERROR_ADDR = RESULT       /* Save address of IGXERROR             */
Call VMAP 'NODISP'      /* call virt. stor map routine, "no display" */
/*********************************************************************/
/* The following code is needed to prevent errors in FIND_SVC_LOC    */
/* routine "Select" because the VMAP sub-routine sets the address    */
/* variables to "N/A" when MLPA/E-MLPA/FLPA/E-FLPA do not exist.     */
/*********************************************************************/
If CVTMLPAS = 'N/A' then CVTMLPAS = 0  /* MLPA   strt does not exist */
If CVTMLPAE = 'N/A' then CVTMLPAE = 0  /* MLPA   end  does not exist */
If CVTFLPAS = 'N/A' then CVTFLPAS = 0  /* FLPA   strt does not exist */
If CVTFLPAE = 'N/A' then CVTFLPAE = 0  /* FLPA   end  does not exist */
If CVTEFLPS = 'N/A' then CVTEFLPS = 0  /* E-FLPA strt does not exist */
If CVTEFLPE = 'N/A' then CVTEFLPE = 0  /* E-FLPA end  does not exist */
If CVTEMLPS = 'N/A' then CVTEMLPS = 0  /* E-MLPA strt does not exist */
If CVTEMLPE = 'N/A' then CVTEMLPE = 0  /* E-MLPA end  does not exist */
/*********************************************************************/
/* A little house keeping                                            */
/*********************************************************************/
SVCACT_TOT    = 0   /* total number of active std SVCs               */
SVCUNUSED_TOT = 0   /* total number of unused std SVCs               */
SVCAPF_TOT    = 0   /* total number of std SVCs requiring APF        */
SVCESR_T1_TOT = 0   /* total number of active Type 1 ESR SVCs        */
SVCESR_T2_TOT = 0   /* total number of active Type 2 ESR SVCs        */
SVCESR_T3_TOT = 0   /* total number of active Type 3/4 ESR SVCs      */
SVCESR_T6_TOT = 0   /* total number of active Type 6 ESR SVCs        */
/*********************************************************************/
/* Standard SVC table display loop                                   */
/*********************************************************************/
Queue '     '
Queue 'SVC Table:'
Queue '  Num Hex  EP-Addr  Location  AM TYP APF ESR ASF AR NP UP' ,
      'CNT Old-EPA  LOCKS'
Do SVCLST = 0 to 255
  SVCTENT  = Storage(D2x(SCVTSVCT+(SVCLST*8)),8)  /* SVC Table Entry */
  SVCTENTU = Storage(D2x(SCVTSVCR+(SVCLST*24)),24) /* SVC UP TBL ENT */
  SVCOLDA  = Substr(SVCTENTU,1,4)            /* OLD EP Address       */
  SVCOLDAR = C2x(SVCOLDA)                    /* OLD addr readable    */
  SVCOLDAR = Right(SVCOLDAR,8,'0')           /* ensure leading zeros */
  SVCURCNT = C2d(Substr(SVCTENTU,21,2))      /* SVC update count     */
  SVCAMODE = Substr(SVCTENT,1,1)             /* AMODE indicator      */
  SVCEPA   = Substr(SVCTENT,1,4)             /* Entry point addr     */
  SVCEPAR  = C2x(SVCEPA)                     /* EPA - readable       */
  SVCEPAR  = Right(SVCEPAR,8,'0')            /* ensure leading zeros */
  SVCATTR1 = Substr(SVCTENT,5,1)             /* SVC attributes       */
  SVCATTR3 = Substr(SVCTENT,6,1)             /* SVC attributes       */
  SVCLOCKS = Substr(SVCTENT,7,1)             /* Lock attributes      */
  /**************************/
  /* Save EPAs of ESR SVCs  */
  /**************************/
  If SVCLST = 109 then SVC109AD = SVCEPA
  If SVCLST = 116 then SVC116AD = SVCEPA
  If SVCLST = 122 then SVC122AD = SVCEPA
  If SVCLST = 137 then SVC137AD = SVCEPA
  /**************************/
  /*  Check amode           */
  /**************************/
  If Bitand(SVCAMODE,'80'x) = '80'x then SVC_AMODE = '31'
    Else SVC_AMODE = '24'
  /**************************/
  /*  Check SVC type flag   */
  /**************************/
  Select                                     /* determine SVC type   */
    When Bitand(SVCATTR1,'C0'x) = 'C0'x then SVCTYPE = '3/4'
    When Bitand(SVCATTR1,'80'x) = '80'x then SVCTYPE = ' 2 '
    When Bitand(SVCATTR1,'20'x) = '20'x then SVCTYPE = ' 6 '
    When Bitand(SVCATTR1,'00'x) = '00'x then SVCTYPE = ' 1 '
    Otherwise SVCTYPE = '???'
  End /* select */
  If SVCLST = 109 then SVCTYPE = ' 3 '  /* 109 is type 3 ESR, not 2  */
  /**************************/
  /*  Check other SVC flags */
  /**************************/
  SVCAPF = '   ' ; SVCESR = '   ' ; SVCNP = '  '  /* init as blanks  */
  SVCASF = '   ' ; SVCAR  = '  '  ; SVCUP = '  '  /* init as blanks  */
  If Bitand(SVCATTR1,'08'x) = '08'x then SVCAPF  = 'APF'
  If Bitand(SVCATTR1,'04'x) = '04'x then SVCESR  = 'ESR'
  If Bitand(SVCATTR1,'02'x) = '02'x then SVCNP   = 'NP'
  If Bitand(SVCATTR1,'01'x) = '01'x then SVCASF  = 'ASF'
  If Bitand(SVCATTR3,'80'x) = '80'x then SVCAR   = 'AR'
  If SVCURCNT <> 0 then SVCUP = 'UP'   /* this SVC has been updated  */
  If SVCURCNT = 0 then do              /* svc never updated          */
    SVCURCNT = '   '
    SVCOLDAR = '        '
  End
  Else do /* most, if not all UP nums are sngl digit- center display */
   If SVCURCNT < 10 then SVCURCNT = Right(SVCURCNT,2,' ') !! ' '
     Else SVCURCNT = Right(SVCURCNT,3,' ')
  End /* else do */
  /**************************/
  /*  Check lock flags      */
  /**************************/
  SVCLL    = ' '  ; SVCCMS  = ' ' ; SVCOPT = ' '  /* init as blanks  */
  SVCALLOC = ' '  ; SVCDISP = ' '                 /* init as blanks  */
  If Bitand(SVCLOCKS,'80'x) = '80'x then SVCLL    = 'L'  /* LOCAL    */
  If Bitand(SVCLOCKS,'40'x) = '40'x then SVCCMS   = 'C'  /* CMS      */
  If Bitand(SVCLOCKS,'20'x) = '20'x then SVCOPT   = 'O'  /* OPT      */
  If Bitand(SVCLOCKS,'10'x) = '10'x then SVCALLOC = 'S'  /* SALLOC   */
  If Bitand(SVCLOCKS,'08'x) = '08'x then SVCDISP  = 'D'  /* DISP     */
  /*********************************/
  /*  location, location, location */
  /*********************************/
  SVCLOCA = Bitand(SVCEPA,'7FFFFFFF'x)       /* zero high order bit  */
  SVCLOCA = C2d(SVCLOCA)                     /* need dec. for compare*/
  Call FIND_SVC_LOC SVCLOCA                  /* determine SVC loc    */
  SVCLOC = RESULT                            /* Save Result          */

  If SVCLOCA = IGCERROR_ADDR ! ,             /* this SVC             */
     SVCLOCA = IGCRETRN_ADDR then do         /*          is not used */
    SVC_AMODE = '  '                         /* blank out amode      */
    SVCAPF = '*** Not Used ***'              /* replace other        */
    SVCESR = ''                              /*   fields to line     */
    SVCASF = ''                              /*     up "locks" due   */
    SVCAR  = ''                              /*       to "not used"  */
    SVCNP  = ''                              /*         display      */
    SVCUP  = ''                              /*                      */
    SVCURCNT = ''                            /*                      */
    SVCOLDAR = '          '                  /*                      */
    SVCUNUSED_TOT = SVCUNUSED_TOT + 1        /* add 1 to unused tot  */
  End /* If SVCLOCA = IGCERROR_ADDR */
  Else do /* used SVC */
    SVCACT_TOT = SVCACT_TOT + 1              /* add 1 to tot active  */
    If SVCAPF  = 'APF' then ,
       SVCAPF_TOT = SVCAPF_TOT + 1           /* add 1 to APF total   */
  End /* Else do */

  Queue ' '  Right(SVCLST,3,' ') '('Right(D2x(SVCLST),2,0)')' ,
    SVCEPAR SVCLOC SVC_AMODE SVCTYPE SVCAPF SVCESR SVCASF ,
    SVCAR SVCNP SVCUP SVCURCNT SVCOLDAR ,
    SVCLL !! SVCCMS !! SVCOPT !! SVCALLOC !! SVCDISP
End /* Do SVCLST = 0 to 255 */
/*********************************************************************/
/* ESR SVC tables display loop                                       */
/*********************************************************************/
Do SVCESRL = 1 to 4  /* ESR display loop  */
  If SVCESRL = 1 then do
    SVCEAD = C2d(SVC116AD)                   /* Type 1 ESR tbl       */
    SVCEHD = 'Type 1 (SVC 116'              /* Type/SVC for heading */
  End
  If SVCESRL = 2 then do
    SVCEAD = C2d(SVC122AD)                   /* Type 2 ESR tbl       */
    SVCEHD = 'Type 2 (SVC 122'              /* Type/SVC for heading */
  End
  If SVCESRL = 3 then do
    SVCEAD = C2d(SVC109AD)                   /* Type 3 ESR tbl       */
    SVCEHD = 'Type 3 (SVC 109'              /* Type/SVC for heading */
  End
  If SVCESRL = 4 then do
    SVCEAD = C2d(SVC137AD)                   /* Type 6 ESR tbl       */
    SVCEHD = 'Type 6 (SVC 137'              /* Type/SVC for heading */
  End
  SVCESRMX = C2d(Storage(D2x(SVCEAD+4),4))   /* Max # ESR entries    */
  Queue '     '
  Queue 'SVC Table for ESR' SVCEHD '- Maximum ESR Number Supported' ,
        'is' SVCESRMX'):'
  Queue '  Num Hex  EP-Addr  Location  AM TYP APF ASF AR NP' ,
        'LOCKS'
  SVCEAD = SVCEAD + 8                        /* bump past ESR hdr    */
  Do SVCELST = 0 to SVCESRMX
    SVCETENT  = Storage(D2x(SVCEAD+(SVCELST*8)),8) /* SVC Tbl Entry  */
    SVCEAMODE = Substr(SVCETENT,1,1)         /* AMODE indicator      */
    SVCEEPA   = Substr(SVCETENT,1,4)         /* Entry point addr     */
    SVCEEPAR  = C2x(SVCEEPA)                 /* EPA - readable       */
    SVCEEPAR  = Right(SVCEEPAR,8,'0')        /* ensure leading zeros */
    SVCEATTR1 = Substr(SVCETENT,5,1)         /* SVC attributes       */
    SVCEATTR3 = Substr(SVCETENT,6,1)         /* SVC attributes       */
    SVCELOCKS = Substr(SVCETENT,7,1)         /* Lock attributes      */
  /**************************/
  /*  Check amode           */
  /**************************/
  If Bitand(SVCEAMODE,'80'x) = '80'x then SVCE_AMODE = '31'
    Else SVCE_AMODE = '24'
  /**************************/
  /*  Check SVC type flag   */
  /**************************/
  Select                                     /* determine SVC type   */
    When Bitand(SVCEATTR1,'C0'x) = 'C0'x then SVCETYPE = '3/4'
    When Bitand(SVCEATTR1,'80'x) = '80'x then SVCETYPE = ' 2 '
    When Bitand(SVCEATTR1,'20'x) = '20'x then SVCETYPE = ' 6 '
    When Bitand(SVCEATTR1,'00'x) = '00'x then SVCETYPE = ' 1 '
    Otherwise SVCETYPE = '???'
  End /* select */
  /**************************/
  /*  Check other SVC flags */
  /**************************/
  SVCEAPF = '   ' ; SVCENP = '  '  /* init as blanks  */
  SVCEASF = '   ' ; SVCEAR = '  '  /* init as blanks  */
  SVCEESR = '   '
  If Bitand(SVCEATTR1,'08'x) = '08'x then SVCEAPF  = 'APF'
  If Bitand(SVCEATTR1,'04'x) = '04'x then SVCEESR  = 'ESR'
  If Bitand(SVCEATTR1,'02'x) = '02'x then SVCENP   = 'NP'
  If Bitand(SVCEATTR1,'01'x) = '01'x then SVCEASF  = 'ASF'
  If Bitand(SVCEATTR3,'80'x) = '80'x then SVCEAR   = 'AR'
  /**************************/
  /*  Check lock flags      */
  /**************************/
  SVCELL    = ' '  ; SVCECMS  = ' ' ; SVCEOPT = ' ' /* init as blanks*/
  SVCEALLOC = ' '  ; SVCEDISP = ' '                 /* init as blanks*/
  If Bitand(SVCELOCKS,'80'x) = '80'x then SVCELL    = 'L' /* LOCAL   */
  If Bitand(SVCELOCKS,'40'x) = '40'x then SVCECMS   = 'C' /* CMS     */
  If Bitand(SVCELOCKS,'20'x) = '20'x then SVCEOPT   = 'O' /* OPT     */
  If Bitand(SVCELOCKS,'10'x) = '10'x then SVCEALLOC = 'S' /* SALLOC  */
  If Bitand(SVCELOCKS,'08'x) = '08'x then SVCEDISP  = 'D' /* DISP    */
  /*********************************/
  /*  location, location, location */
  /*********************************/
  SVCELOCA = Bitand(SVCEEPA,'7FFFFFFF'x)     /* zero high order bit  */
  SVCELOCA = C2d(SVCELOCA)                   /* need dec. for compare*/
  Call FIND_SVC_LOC SVCELOCA                 /* determine SVC loc    */
  SVCELOC = RESULT                           /* Save Result          */

  If SVCELOCA = IGXERROR_ADDR then do        /* this SVC is not used */
    SVCE_AMODE = '  '                        /* blank out amode      */
    SVCEAPF = '* Unused *'                   /* replace other fields */
    SVCEASF = ''                             /*  to line up "locks"  */
    SVCEAR  = ''                             /*   due to "unused"    */
    SVCENP  = ''                             /*    display           */
  End /* If SVCELOCA = IGXERROR_ADDR */
  Else do /* used SVC */
    If SVCESRL = 1 then ,
       SVCESR_T1_TOT = SVCESR_T1_TOT + 1     /* add 1 to TYPE 1 tot  */
    If SVCESRL = 2 then ,
       SVCESR_T2_TOT = SVCESR_T2_TOT + 1     /* add 1 to TYPE 2 tot  */
    If SVCESRL = 3 then ,
       SVCESR_T3_TOT = SVCESR_T3_TOT + 1     /* add 1 to TYPE 3/4 tot*/
    If SVCESRL = 4 then ,
       SVCESR_T6_TOT = SVCESR_T6_TOT + 1     /* add 1 to TYPE 6 tot  */
  End /* Else do */

  Queue ' '  Right(SVCELST,3,' ') '('Right(D2x(SVCELST),2,0)')' ,
    SVCEEPAR SVCELOC SVCE_AMODE SVCETYPE SVCEAPF SVCEASF ,
    SVCEAR SVCENP ,
    SVCELL !! SVCECMS !! SVCEOPT !! SVCEALLOC !! SVCEDISP
  End

End /* Do SVCESRL = 1 to 4 */
Queue '    '
Queue '  SVC Usage Summary:'
Queue '    Total number of active standard SVCs (including ESR' ,
      'slots) =' SVCACT_TOT
Queue '    Total number of unused standard SVCs =' SVCUNUSED_TOT
Queue '    Total number of active standard SVCs' ,
      'requiring APF auth =' SVCAPF_TOT
Queue '    Total number of active Type 1   ESR SVCs =' SVCESR_T1_TOT
Queue '    Total number of active Type 2   ESR SVCs =' SVCESR_T2_TOT
Queue '    Total number of active Type 3/4 ESR SVCs =' SVCESR_T3_TOT
Queue '    Total number of active Type 6   ESR SVCs =' SVCESR_T6_TOT
Return

FIND_SVC_LOC:  /* determine virtual storage location of SVC  */
Arg SVC_LOC
Select
  When SVC_LOC >= X2d(VVSTRT)    & SVC_LOC <= X2d(VVEND)     ,
       then SVCLOC = 'PRIVATE  ' /* never, but coded anyway */
  When SVC_LOC >= X2d(GDACSAH)   & SVC_LOC <= X2d(CSAEND)    ,
       then SVCLOC = 'CSA      '
  When SVC_LOC >= X2d(CVTMLPAS)  & SVC_LOC <= X2d(CVTMLPAE)  ,
       then SVCLOC = 'MLPA     '
  When SVC_LOC >= X2d(CVTFLPAS)  & SVC_LOC <= X2d(CVTFLPAE)  ,
       then SVCLOC = 'FLPA     '
  When SVC_LOC >= X2d(CVTPLPAS)  & SVC_LOC <= X2d(CVTPLPAE)  ,
       then SVCLOC = 'PLPA     '
  When SVC_LOC >= X2d(GDASQAH)   & SVC_LOC <= X2d(SQAEND)    ,
       then SVCLOC = 'SQA      '
  When SVC_LOC >= X2d(CVTRWNS)   & SVC_LOC <= X2d(CVTRWNE)   ,
       then SVCLOC = 'R/W Nuc  '
  When SVC_LOC >= X2d(RONUCSZB)  & SVC_LOC <= X2d('FFFFFF')  ,
       then SVCLOC = 'R/O Nuc  '
  When SVC_LOC >= X2d('1000000') & SVC_LOC <= X2d(CVTRONE)   ,
       then SVCLOC = 'E-R/O Nuc'
  When SVC_LOC >= X2d(CVTERWNS)  & SVC_LOC <= X2d(CVTERWNE)  ,
       then SVCLOC = 'E-R/W Nuc'
  When SVC_LOC >= X2d(GDAESQAH)  & SVC_LOC <= X2d(ESQAEND)   ,
       then SVCLOC = 'E-SQA    '
  When SVC_LOC >= X2d(CVTEPLPS)  & SVC_LOC <= X2d(CVTEPLPE)  ,
       then SVCLOC = 'E-PLPA   '
  When SVC_LOC >= X2d(CVTEFLPS)  & SVC_LOC <= X2d(CVTEFLPE)  ,
       then SVCLOC = 'E-FLPA   '
  When SVC_LOC >= X2d(CVTEMLPS)  & SVC_LOC <= X2d(CVTEMLPE)  ,
       then SVCLOC = 'E-MLPA   '
  When SVC_LOC >= X2d(GDAECSAH)  & SVC_LOC <= X2d(ECSAEND)   ,
       then SVCLOC = 'E-CSA    '
  When SVC_LOC >= X2d(GDAEPVTH)  & SVC_LOC <= X2d(EPVTEND)   ,
       then SVCLOC = 'E-PRIVATE' /* never, but coded anyway */
  Otherwise SVCLOC = '????     '
End /* select */
Return SVCLOC

FIND_NUC: /* Find EP address of "ARG" in NUC MAP  */
Arg NUC_NAME
CVTNUCMP  = C2d(Storage(D2x(CVT+1200),4))    /* NUC map address      */
NUCMAPEND = C2d(Storage(D2x(CVTNUCMP+8),4))  /* End of nucmap        */
 /* NUCMAPLEN = C2d(Storage(D2x(CVTNUCMP+13),3)) */ /* tbl length    */
NUC_CURA  = CVTNUCMP+16                      /* Curent tbl entry     */
Do while  NUC_CURA <  NUCMAPEND              /* go though tbl        */
  NUC_EP    = Storage(D2x(NUC_CURA),8)       /* Nuc EP name          */
  If NUC_EP = NUC_NAME then do               /* NUC_NAME found?      */
    NUC_ADDR = C2d(Storage(D2x(NUC_CURA+8),4)) /* yes, save addr     */
    Leave                                    /* leave this loop      */
  End /* If NUC_EP = NUC_NAME */
  Else NUC_CURA = NUC_CURA + 16              /* bump to next entry   */
End /* do while */
Return NUC_ADDR

XLATE_NONDISP:       /* translate non-display characters to a "."    */
Arg XLATEPRM
XLATELEN = Length(XLATEPRM) /* length of parm passed to routine      */
Do I = 1 to XLATELEN                      /* check each byte for     */
  If (Substr(XLATEPRM,I,1) >= '00'x & ,   /* non-display characters  */
    Substr(XLATEPRM,I,1) < '40'x ) ! ,    /* and replace each        */
    Substr(XLATEPRM,I,1) = 'FF'x  then ,  /* character that          */
    XLATEPRM = OVERLAY('.',XLATEPRM,I)    /* is non-displayable      */
End                                       /* with a period (.)       */
Return XLATEPRM

STORAGE_GDA_LDA:     /* GDA/LDA Storage values sub-routine           */
ASCB     = C2d(Storage(224,4))               /* point to cur ASCB    */
ASCBLDA  = C2d(Storage(D2x(ASCB + 48),4))    /* point to LDA         */
CVTGDA   = C2d(Storage(D2x(CVT + 560),4))    /* point to GDA         */
LDASTRTA = Storage(D2x(ASCBLDA + 60),4)      /* point to V=V start   */
LDASTRTA = C2x(LDASTRTA)                     /* display in hex       */
LDASIZEA = C2d(Storage(D2x(ASCBLDA + 64),4)) /* point to V=V size    */
LDASIZEA = LDASIZEA/1024                     /* convert to Kbytes    */
LDASTRTS = Storage(D2x(ASCBLDA + 92),4)      /* pt. to sysarea start */
LDASTRTS = C2x(LDASTRTS)                     /* display in hex       */
LDASIZS  = C2d(Storage(D2x(ASCBLDA + 96),4)) /* pt. to sysarea size  */
LDASIZS  = LDASIZS/1024                      /* convert to Kbytes    */
GDAPVTSZ = C2d(Storage(D2x(CVTGDA + 164),4)) /* point to MAX PVT<16M */
GDAPVTSZ = GDAPVTSZ/1024                     /* convert to Kbytes    */
GDAEPVTS = C2d(Storage(D2x(CVTGDA + 172),4)) /* point to MAX PVT>16M */
GDAEPVTS = GDAEPVTS/1024/1024                /* convert to Mbytes    */
GDACSASZ = C2d(Storage(D2x(CVTGDA + 112),4)) /* point to CSA<16M     */
GDACSASZ = GDACSASZ/1024                     /* convert to Kbytes    */
GDAECSAS = C2d(Storage(D2x(CVTGDA + 128),4)) /* point to CSA>16M     */
GDAECSAS = GDAECSAS/1024                     /* convert to Kbytes    */
GDASQASZ = C2d(Storage(D2x(CVTGDA + 148),4)) /* point to SQA<16M     */
GDASQASZ = GDASQASZ/1024                     /* convert to Kbytes    */
GDAESQAS = C2d(Storage(D2x(CVTGDA + 156),4)) /* point to SQA>16M     */
GDAESQAS = GDAESQAS/1024                     /* convert to Kbytes    */
GDAVRSZ  = C2d(Storage(D2x(CVTGDA + 196),4)) /* point to V=R global  */
GDAVRSZ  = GDAVRSZ/1024                      /* convert to Kbytes    */
GDAVREGS = C2d(Storage(D2x(CVTGDA + 200),4)) /* point to V=R default */
GDAVREGS = GDAVREGS/1024                     /* convert to Kbytes    */
GDA_CSA_ALLOC  = C2d(Storage(D2x(CVTGDA + 432),4)) /* CSA amt alloc  */
GDA_CSA_ALLOC  = Format(GDA_CSA_ALLOC/1024,,0)     /* conv to Kbytes */
GDA_ECSA_ALLOC = C2d(Storage(D2x(CVTGDA + 436),4)) /* ECSA amt alloc */
GDA_ECSA_ALLOC = Format(GDA_ECSA_ALLOC/1024,,0)    /* conv to Kbytes */
GDA_SQA_ALLOC  = C2d(Storage(D2x(CVTGDA + 440),4)) /* SQA amt alloc  */
GDA_SQA_ALLOC  = Format(GDA_SQA_ALLOC/1024,,0)     /* conv to Kbytes */
GDA_ESQA_ALLOC = C2d(Storage(D2x(CVTGDA + 444),4)) /* ESQA amt alloc */
GDA_ESQA_ALLOC = Format(GDA_ESQA_ALLOC/1024,,0)    /* conv to Kbytes */
GDA_CSA_CONV   = C2d(Storage(D2x(CVTGDA + 448),4)) /* CSA => SQA amt */
GDA_CSA_CONV   = Format(GDA_CSA_CONV/1024,,0)      /* conv to Kbytes */
GDA_ECSA_CONV  = C2d(Storage(D2x(CVTGDA + 452),4)) /* ECSA=>ESQA amt */
GDA_ECSA_CONV  = Format(GDA_ECSA_CONV/1024,,0)     /* conv to Kbytes */
/*********************************************************************/
/* High Water Marks for SQA/ESQA/CSA/ECSA added in OS/390 R10        */
/*********************************************************************/
If Bitand(CVTOSLV2,'01'x) = '01'x then do    /* OS/390 R10 and above */
  GDASQAHWM  = C2d(Storage(D2x(CVTGDA + 536),4))   /* SQA HWM        */
  GDASQAHWM  = Format(GDASQAHWM/1024,,0)           /* conv to Kbytes */
  GDAESQAHWM = C2d(Storage(D2x(CVTGDA + 540),4))   /* ESQA HWM       */
  GDAESQAHWM = Format(GDAESQAHWM/1024,,0)          /* conv to Kbytes */
  If Bitand(CVTOSLV5,'08'x) = '08'x then do  /* z/OS 1.10 and above  */
    GDATotalCSAHWM  = C2d(Storage(D2x(CVTGDA+552),4)) /* CSA HWM     */
    GDATotalCSAHWM  = Format(GDATotalCSAHWM/1024,,0)  /* conv to Kb  */
    GDATotalECSAHWM = C2d(Storage(D2x(CVTGDA+556),4)) /* ECSA HWM    */
    GDATotalECSAHWM = Format(GDATotalECSAHWM/1024,,0) /* conv to Kb  */
    GDACSAHWM       = GDATotalCSAHWM   /* set var used for VMAP disp */
    GDAECSAHWM      = GDATotalECSAHWM  /* set var used for VMAP disp */
  End
  Else do  /* use pre z/OS 1.10 values for CSA/ECSA HWM              */
    GDACSAHWM  = C2d(Storage(D2x(CVTGDA + 544),4)) /* CSA HWM        */
    GDACSAHWM  = Format(GDACSAHWM/1024,,0)         /* conv to Kbytes */
    GDAECSAHWM = C2d(Storage(D2x(CVTGDA + 548),4)) /* ECSA HWM       */
    GDAECSAHWM = Format(GDAECSAHWM/1024,,0)        /* conv to Kbytes */
  End
End
Return

EXTRACT_SYSPARMS:    /* Extract IEASYSxx values from the IPA         */
Parse arg IEASPARM
IEASPARM = Strip(IEASPARM,'T')               /* remove trailing blnks*/
If IEASPARM = '<notdef>' then return         /*"blank" parm in IHAIPA*/
/*********************************************************************/
/* This next section of code removes IEASYSxx parameters from the    */
/* IPA output display for parms that are obsolete or undocumented    */
/* but still have to be accounted for when parsing out the parms     */
/* and values from the IPA control block.                            */
/*********************************************************************/
If Bitand(CVTOSLV3,'08'x) = '08'x then ,     /* z/OS 1.3 and above   */
  If Substr(IEASPARM,1,3) = 'IPS'then return /* remove IPS parm      */
If Bitand(CVTOSLV3,'02'x) = '02'x then ,     /* z/OS 1.5 and above   */
  If Pos('ILM',IEASPARM) <> 0  then return   /* remove ILM parms     */
If Bitand(CVTOSLV5,'04'x) = '04'x then do    /* z/OS 1.11 and above  */
  If Pos('IQP',IEASPARM)  <> 0 then return   /* remove IQP parm      */
  If Pos('CPCR',IEASPARM) <> 0 then return   /* remove CPCR parm     */
  If Pos('DDM',IEASPARM)  <> 0 then return   /* remove DDM parm      */
End
If Bitand(CVTOSLV5,'01'x) = '01'x then do    /* z/OS 1.13 and above  */
  If Pos('RTLS',IEASPARM) <> 0 then return   /* remove RTLS parm     */
End
/*********************************************************************/
IPAOFF = ((I-1) * 8)                         /* offset to next entry */
IPASTOR = D2x(ECVTIPA + 2152 + IPAOFF)       /* point to PDE addr    */
IPAPDE  = C2x(Storage((IPASTOR),8))          /* point to PDE         */
If IPAPDE = 0 then return   /* parm not specified and has no default */
TOTPRMS = TOTPRMS + 1    /* tot num of specified or defaulted parms  */
IPAADDR = Substr(IPAPDE,1,8)                 /* PARM address         */
IPALEN  = X2d(Substr(IPAPDE,9,4))            /* PARM length          */
IPAPRM  = Storage((IPAADDR),IPALEN)          /* PARM                 */
IPASRC  = Substr(IPAPDE,13,4)                /* PARM source          */
If X2d(IPASRC) = 65535 then PRMSRC = 'Operator'   /* operator parm   */
Else
  If X2d(IPASRC) = 0     then PRMSRC = 'Default'  /* default  parm   */
Else
  PRMSRC = 'IEASYS' !! X2c(IPASRC)           /* IEASYSxx parm        */
PRMLINE = '    'IEASPARM'='IPAPRM
  /**************************************************/
  /* This check just below is for parms that do not */
  /* have an equal sign in IEASYSxx.                */
  /**************************************************/
If IEASPARM = 'PRESCPU' ! ,
   IEASPARM = 'WARNUND' ! ,
   IEASPARM = 'CVIO'    ! ,
   IEASPARM = 'CLPA' then  PRMLINE = '    'IEASPARM
  Else PRMLINE = '    'IEASPARM'='IPAPRM
PRMLINE.TOTPRMS = IEASPARM PRMLINE PRMSRC
PRMLINE.0 = TOTPRMS
Return

BUILD_IPAPDETB:      /* Build table for lookup for IPA values        */
NUM=1
IPAPDETB.NUM = 'ALLOC   ' ; NUM = NUM + 1
IPAPDETB.NUM = 'APF     ' ; NUM = NUM + 1
IPAPDETB.NUM = 'APG     ' ; NUM = NUM + 1
IPAPDETB.NUM = 'BLDL    ' ; NUM = NUM + 1
IPAPDETB.NUM = 'BLDLF   ' ; NUM = NUM + 1
IPAPDETB.NUM = 'CLOCK   ' ; NUM = NUM + 1
IPAPDETB.NUM = 'CLPA    ' ; NUM = NUM + 1
IPAPDETB.NUM = 'CMB     ' ; NUM = NUM + 1
IPAPDETB.NUM = 'CMD     ' ; NUM = NUM + 1
IPAPDETB.NUM = 'CON     ' ; NUM = NUM + 1
IPAPDETB.NUM = 'CONT    ' ; NUM = NUM + 1
IPAPDETB.NUM = 'COUPLE  ' ; NUM = NUM + 1
IPAPDETB.NUM = 'CPQE    ' ; NUM = NUM + 1
IPAPDETB.NUM = 'CSA     ' ; NUM = NUM + 1
IPAPDETB.NUM = 'CSCBLOC ' ; NUM = NUM + 1
IPAPDETB.NUM = 'CVIO    ' ; NUM = NUM + 1
IPAPDETB.NUM = 'DEVSUP  ' ; NUM = NUM + 1
IPAPDETB.NUM = 'DIAG    ' ; NUM = NUM + 1
IPAPDETB.NUM = 'DUMP    ' ; NUM = NUM + 1
IPAPDETB.NUM = 'DUPLEX  ' ; NUM = NUM + 1
IPAPDETB.NUM = 'EXIT    ' ; NUM = NUM + 1
IPAPDETB.NUM = 'FIX     ' ; NUM = NUM + 1
IPAPDETB.NUM = 'GRS     ' ; NUM = NUM + 1
IPAPDETB.NUM = 'GRSCNF  ' ; NUM = NUM + 1
IPAPDETB.NUM = 'GRSRNL  ' ; NUM = NUM + 1
IPAPDETB.NUM = 'ICS     ' ; NUM = NUM + 1
IPAPDETB.NUM = 'IOS     ' ; NUM = NUM + 1
IPAPDETB.NUM = 'IPS     ' ; NUM = NUM + 1
IPAPDETB.NUM = 'LNK     ' ; NUM = NUM + 1
IPAPDETB.NUM = 'LNKAUTH ' ; NUM = NUM + 1
IPAPDETB.NUM = 'LOGCLS  ' ; NUM = NUM + 1
IPAPDETB.NUM = 'LOGLMT  ' ; NUM = NUM + 1
IPAPDETB.NUM = 'LOGREC  ' ; NUM = NUM + 1
IPAPDETB.NUM = 'LPA     ' ; NUM = NUM + 1
IPAPDETB.NUM = 'MAXCAD  ' ; NUM = NUM + 1
IPAPDETB.NUM = 'MAXUSER ' ; NUM = NUM + 1
IPAPDETB.NUM = 'MLPA    ' ; NUM = NUM + 1
IPAPDETB.NUM = 'MSTRJCL ' ; NUM = NUM + 1
IPAPDETB.NUM = 'NONVIO  ' ; NUM = NUM + 1
IPAPDETB.NUM = 'NSYSLX  ' ; NUM = NUM + 1
IPAPDETB.NUM = 'NUCMAP  ' ; NUM = NUM + 1
If Bitand(CVTOSLV1,'04'x) = '04'x then do    /* OS/390 R3 and above  */
   IPAPDETB.NUM = 'OMVS    ' ; NUM = NUM + 1
End
Else do
   IPAPDETB.NUM = 'RESERVED' ; NUM = NUM + 1
End
IPAPDETB.NUM = 'OPI     ' ; NUM = NUM + 1
IPAPDETB.NUM = 'OPT     ' ; NUM = NUM + 1
IPAPDETB.NUM = 'PAGE-OPR' ; NUM = NUM + 1
IPAPDETB.NUM = 'PAGE    ' ; NUM = NUM + 1
IPAPDETB.NUM = 'PAGNUM  ' ; NUM = NUM + 1
IPAPDETB.NUM = 'PAGTOTL ' ; NUM = NUM + 1
IPAPDETB.NUM = 'PAK     ' ; NUM = NUM + 1
IPAPDETB.NUM = 'PLEXCFG ' ; NUM = NUM + 1
IPAPDETB.NUM = 'PROD    ' ; NUM = NUM + 1
IPAPDETB.NUM = 'PROG    ' ; NUM = NUM + 1
IPAPDETB.NUM = 'PURGE   ' ; NUM = NUM + 1
IPAPDETB.NUM = 'RDE     ' ; NUM = NUM + 1
IPAPDETB.NUM = 'REAL    ' ; NUM = NUM + 1
IPAPDETB.NUM = 'RER     ' ; NUM = NUM + 1
IPAPDETB.NUM = 'RSU     ' ; NUM = NUM + 1
IPAPDETB.NUM = 'RSVNONR ' ; NUM = NUM + 1
IPAPDETB.NUM = 'RSVSTRT ' ; NUM = NUM + 1
IPAPDETB.NUM = 'SCH     ' ; NUM = NUM + 1
IPAPDETB.NUM = 'SMF     ' ; NUM = NUM + 1
IPAPDETB.NUM = 'SMS     ' ; NUM = NUM + 1
IPAPDETB.NUM = 'SQA     ' ; NUM = NUM + 1
IPAPDETB.NUM = 'SSN     ' ; NUM = NUM + 1
IPAPDETB.NUM = 'SVC     ' ; NUM = NUM + 1
IPAPDETB.NUM = 'SWAP    ' ; NUM = NUM + 1
IPAPDETB.NUM = 'SYSNAME ' ; NUM = NUM + 1
IPAPDETB.NUM = 'SYSP    ' ; NUM = NUM + 1
IPAPDETB.NUM = 'VAL     ' ; NUM = NUM + 1
IPAPDETB.NUM = 'VIODSN  ' ; NUM = NUM + 1
IPAPDETB.NUM = 'VRREGN  ' ; NUM = NUM + 1
If Bitand(CVTOSLV2,'80'x) = '80'x then do    /* OS/390 R4 and above  */
   IPAPDETB.NUM = 'RTLS    ' ; NUM = NUM + 1
End
If Bitand(CVTOSLV2,'04'x) = '04'x then do    /* OS/390 R8 and above  */
   IPAPDETB.NUM = 'UNI     ' ; NUM = NUM + 1 /* added by APAR OW44581*/
End
If Bitand(CVTOSLV3,'20'x) = '20'x then do    /* z/OS 1.1 and above   */
   IPAPDETB.NUM = 'ILMLIB  ' ; NUM = NUM + 1
   IPAPDETB.NUM = 'ILMMODE ' ; NUM = NUM + 1
End
If Bitand(CVTOSLV3,'08'x) = '08'x then do    /* z/OS 1.3 and above   */
   IPAPDETB.NUM = 'IKJTSO  ' ; NUM = NUM + 1
   IPAPDETB.NUM = 'LICENSE ' ; NUM = NUM + 1
End
If Bitand(CVTOSLV3,'02'x) = '02'x then do    /* z/OS 1.5 and above   */
   IPAPDETB.NUM = '<notdef>' ; NUM = NUM + 1 /*"blank" def in IHAIPA */
   IPAPDETB.NUM = 'HVSHARE ' ; NUM = NUM + 1
   IPAPDETB.NUM = 'ILM     ' ; NUM = NUM + 1
 /********************************************************************/
 /* If you have a z/OS 1.5 or z/OS 1.6 system without OA09649, you   */
 /* may have to delete the next 3 lines of code.                     */
 /********************************************************************/
   IPAPDETB.NUM = '<notdef>' ; NUM = NUM + 1 /*"blank" def in IHAIPA */
   IPAPDETB.NUM = '<notdef>' ; NUM = NUM + 1 /*"blank" def in IHAIPA */
   IPAPDETB.NUM = 'PRESCPU ' ; NUM = NUM + 1 /* added by OA09649 */
End
If Bitand(CVTOSLV5,'40'x) = '40'x then do    /* z/OS 1.7 and above   */
   NUM = NUM-3
   IPAPDETB.NUM = 'DRMODE  ' ; NUM = NUM + 1
   IPAPDETB.NUM = 'CEE     ' ; NUM = NUM + 1
   IPAPDETB.NUM = 'PRESCPU ' ; NUM = NUM + 1
End
If Bitand(CVTOSLV5,'10'x) = '10'x then do    /* z/OS 1.9 and above   */
   IPAPDETB.NUM = 'LFAREA  ' ; NUM = NUM + 1
End
If Bitand(CVTOSLV5,'08'x) = '08'x then do    /* z/OS 1.10 and above  */
   IPAPDETB.NUM = 'CEA     ' ; NUM = NUM + 1
   IPAPDETB.NUM = 'HVCOMMON' ; NUM = NUM + 1
   IPAPDETB.NUM = 'AXR     ' ; NUM = NUM + 1
End
If Bitand(CVTOSLV5,'08'x) = '08'x then do    /* z/OS 1.10 and above  */
 /********************************************************************/
 /* If you have z/OS 1.10 without OA27495, you may have to delete    */
 /* the next line of code. If you have z/OS 1.9 with OA27495 and     */
 /* wish to see the "ZZ" value, change the check above from:         */
 /*   If Bitand(CVTOSLV5,'08'x) = '08'x then do                      */
 /* to:                                                              */
 /*   If Bitand(CVTOSLV5,'10'x) = '10'x then do                      */
 /********************************************************************/
   IPAPDETB.NUM = 'ZZ      ' ; NUM = NUM + 1
End
If Bitand(CVTOSLV5,'04'x) = '04'x then do    /* z/OS 1.11 and above  */
   NUM = NUM - 1
   IPAPDETB.NUM = 'ZAAPZIIP' ; NUM = NUM + 1
   IPAPDETB.NUM = 'IQP'      ; NUM = NUM + 1
   IPAPDETB.NUM = 'CPCR'     ; NUM = NUM + 1
   IPAPDETB.NUM = 'DDM'      ; NUM = NUM + 1
End
If Bitand(CVTOSLV5,'02'x) = '02'x then do    /* z/OS 1.12 and above  */
   IPAPDETB.NUM = 'AUTOR'    ; NUM = NUM + 1
End
If Bitand(CVTOSLV5,'01'x) = '01'x then do    /* z/OS 1.13 and above  */
   IPAPDETB.NUM = 'CATALOG'  ; NUM = NUM + 1
   IPAPDETB.NUM = 'IXGCNF'   ; NUM = NUM + 1
End
If Bitand(CVTOSLV6,'80'x) = '80'x then do    /* z/OS 2.1  and above  */
   IPAPDETB.NUM = 'PAGESCM'  ; NUM = NUM + 1
   IPAPDETB.NUM = 'WARNUND'  ; NUM = NUM + 1
   IPAPDETB.NUM = 'HZS'      ; NUM = NUM + 1
   IPAPDETB.NUM = 'GTZ'      ; NUM = NUM + 1
   IPAPDETB.NUM = 'HZSPROC'  ; NUM = NUM + 1
End
If Bitand(CVTOSLV6,'40'x) = '40'x then do    /* z/OS 2.2  and above  */
   IPAPDETB.NUM = 'SMFLIM'   ; NUM = NUM + 1
   IPAPDETB.NUM = 'IEFOPZ'   ; NUM = NUM + 1
End
If Bitand(CVTOSLV6,'10'x) = '10'x then do    /* z/OS 2.3  and above  */
   IPAPDETB.NUM = 'RACF'     ; NUM = NUM + 1
   IPAPDETB.NUM = 'FXE'      ; NUM = NUM + 1
   IPAPDETB.NUM = 'IZU'      ; NUM = NUM + 1
   IPAPDETB.NUM = 'SMFTBUFF' ; NUM = NUM + 1  /* APAR OA52828 */
   IPAPDETB.NUM = 'DIAG1'    ; NUM = NUM + 1  /* IBM use only */
   IPAPDETB.NUM = 'OSPROTECT'; NUM = NUM + 1  /* APAR OA54807 */
   IPAPDETB.NUM = 'ICSF'     ; NUM = NUM + 1  /* APAR OA55378 */
   IPAPDETB.NUM = 'ICSFPROC' ; NUM = NUM + 1  /* APAR OA55378 */
End
       /* RUCSA and BOOST on z/OS 2.3 with APARs OA56180 and OA57849 */
If Bitand(CVTOSLV6,'08'x) = '08'x then do    /* z/OS 2.4  and above  */
   IPAPDETB.NUM = 'RUCSA'    ; NUM = NUM + 1
   IPAPDETB.NUM = 'BOOST'    ; NUM = NUM + 1
End
IPAPDETB.0 = NUM-1
Return

SPLIT_IPA_PAGE: /* Split up page data set parms to multiple lines */
TOT_IPALINES = 0
Do SPLIT = 1 to PRMLINE.0
   TOT_IPALINES = TOT_IPALINES+1    /* add one total lines    */
   IPA_PDE = Word(PRMLINE.SPLIT,1)  /* keyword                */
   IPA_PRM = Word(PRMLINE.SPLIT,2)  /* value                  */
   IPA_SRC = Word(PRMLINE.SPLIT,3)  /* IEASYSxx, dlft, or OPR */
   IPA_LEN = Length(IPA_PRM)
  If IPA_PDE = 'NONVIO' ! IPA_PDE = 'PAGE' ! ,
     IPA_PDE = 'PAGE-OPR' ! IPA_PDE = 'SWAP' then do
    MORE  = 'YES' /* init flag for more subparms */
    FIRST = 'YES' /* init flag for first subparm */
    SPLITPOS = 1
    Do until MORE = 'NO'
      SPLITPOS = Pos(',',IPA_PRM)
      If SPLITPOS = 0 then do
        If FIRST = 'YES' then do
          IPALINE.TOT_IPALINES = '    'IPA_PRM !! ','
          IPALINE.TOT_IPALINES = ,
            Overlay(IPA_SRC,IPALINE.TOT_IPALINES,68)
        End
        Else do
          MBLNK = ''
          If IPA_PDE = 'NONVIO' then MBLNK = '  '     /* align   */
          If IPA_PDE = 'PAGE-OPR' then MBLNK = '    ' /* align   */
          IPALINE.TOT_IPALINES = MBLNK'          'IPA_PRM !! ','
          IPALINE.TOT_IPALINES = ,
            Overlay(IPA_SRC,IPALINE.TOT_IPALINES,68)
        End
        MORE = 'NO'  /* no more subparms */
      End /* if SPLITPOS = 0 */
      Else do
        IPAPRM_SPLIT = Substr(IPA_PRM,1,SPLITPOS)
        If FIRST = 'YES' then IPALINE.TOT_IPALINES = '    'IPAPRM_SPLIT
          Else do
            MBLNK = ''
            If IPA_PDE = 'NONVIO' then MBLNK = '  '     /* align   */
            If IPA_PDE = 'PAGE-OPR' then MBLNK = '    ' /* align   */
            IPALINE.TOT_IPALINES = MBLNK'          'IPAPRM_SPLIT
          End
        IPA_PRM  = Substr(IPA_PRM,SPLITPOS+1,IPA_LEN-SPLITPOS)
        IPA_LEN =  Length(IPA_PRM)
        TOT_IPALINES = TOT_IPALINES+1  /* add one total lines */
        FIRST = 'NO'
      End
    End  /* do until more=no */
  End
  Else do
    IPALINE.TOT_IPALINES = '    'IPA_PRM !! ','
    IPALINE.TOT_IPALINES = Overlay(IPA_SRC,IPALINE.TOT_IPALINES,68)
  End
End
Return

SORT_IPA: Procedure expose PRMLINE.
/* bubble sort the IPA list */
SORT_DONE = 0
SORT_RECS = PRMLINE.0
Do while SORT_DONE = 0
  SORT_DONE = 1
  Do I = 1 to SORT_RECS - 1
    J = I + 1
    If PRMLINE.I > PRMLINE.J then do
      SORT_DONE = 0
      TEMP_SORT = PRMLINE.J
      PRMLINE.J = PRMLINE.I
      PRMLINE.I = TEMP_SORT
    End /* if */
  End /* do i=1 to sort_recs */
  SORT_RECS = SORT_RECS - 1
End /* do while */
Return

GET_CPCSI:
SI_OFF=0
IRALCCT = C2d(Storage(D2x(RMCT+620),4))         /* point to IRALCCT  */
                                                /*  (undocumented)   */
If Bitand(CVTOSLV5,'08'x) = '08'x then , /* z/OS 1.10 and above      */
  SI_OFF = 128      /* additional offset to CPC SI info in IRALCCT   */
 /****************************************************************/
 /* If you have z/OS 1.12 or z/OS 1.13 with z13 support          */
 /* maintenance applied you will have to uncomment either the    */
 /* first 2 lines or the 2nd 2 lines to fix the CPCSI display.   */
 /* The 2nd set should work for z/OS 1.12 or z/OS 1.13 systems   */
 /* that do have the maintenance and also for those systems that */
 /* do not have the maintenance.                                 */
 /****************************************************************/
/*If Bitand(CVTOSLV5,'02'x) = '02'x then , */   /* z/OS 1.12 and >   */
/*  SI_OFF = 384 */   /* additional offset to CPC SI info in IRALCCT */
/*If C2x(Storage(D2x(IRALCCT+10),1)) <> '40' then , *//* z13 support */
/*  SI_OFF = 384 */   /* additional offset to CPC SI info in IRALCCT */
If Bitand(CVTOSLV6,'80'x) = '80'x then , /* z/OS 2.1  and above      */
  SI_OFF = 384      /* additional offset to CPC SI info in IRALCCT   */
 /****************************************************************/
 /* The check below was added for a reported problem on          */
 /* z/OS 2.3 at RSU1812 or RSU1903.  I'm not sure what APAR(s)   */
 /* broke this or if the same APAR could apply to earlier z/OS   */
 /* versions.                                                    */
 /*                                                              */
 /* If the CPU node display doesn't look right, delete the code  */
 /* that changes the offset to 392 or comment it out.            */
 /****************************************************************/
If Bitand(CVTOSLV6,'10'x) = '10'x then       /* z/OS 2.3  and above  */
  /* (MODEL='3906' ! MODEL='3907') ! */      /* z/OS 2.3 + z14       */
  /* (MODEL='2964' ! MODEL='2965') then */   /* z/OS 2.3 + z13       */
  SI_OFF = 392      /* additional offset to CPC SI info in IRALCCT   */
CPCSI_TYPE  = Storage(D2x(IRALCCT+332+SI_OFF),4)    /* Type          */
CPCSI_MODEL = Storage(D2x(IRALCCT+336+SI_OFF),4)    /* Model         */
CPCSI_MODEL = Strip(CPCSI_MODEL)                    /* Remove blanks */
CPCSI_MAN   = Storage(D2x(IRALCCT+384+SI_OFF),16)   /* Manufacturer  */
CPCSI_MAN   = Strip(CPCSI_MAN)                      /* Remove blanks */
CPCSI_PLANT = Storage(D2x(IRALCCT+400+SI_OFF),4)    /* Plant         */
CPCSI_PLANT = Strip(CPCSI_PLANT)                    /* Remove blanks */
CPCSI_CPUID = Storage(D2x(IRALCCT+352+SI_OFF),16)   /* CPUID         */
CPCSI_MODELID = Storage(D2x(IRALCCT+592+SI_OFF),4)  /* Model ID      */
CPCSI_MODELID = Strip(CPCSI_MODELID)                /* Remove blanks */
 /*   CPCSI_MODELID may not be valid on emulated    */
 /*   z/OS systems like FLEX, HERC and z/PDT        */
Return

FORMAT_MEMSIZE:
/****************************************************************/
/* The following code is used to display the storage size in    */
/* the largest possible unit.  For example, 1023G and 1025G are */
/* displayed as 1023G and 1025G, but 1024G is displayed as 1T.  */
/* The size passed to the routine must be in MB.                */
/****************************************************************/
Arg SIZE_IN_MB
Select
   When SIZE_IN_MB < 1024 then do
     MUNITS = 'M'
   End
   When SIZE_IN_MB >= 1024 & SIZE_IN_MB < 1048576 then do
     If SIZE_IN_MB/1024 == TRUNC(SIZE_IN_MB/1024) then do
       SIZE_IN_MB = SIZE_IN_MB/1024
       MUNITS = 'G'
     End
     Else MUNITS = 'M'
   End
   When SIZE_IN_MB >= 1048576 & SIZE_IN_MB < 1073741824 then do
     If SIZE_IN_MB/1048576 == TRUNC(SIZE_IN_MB/1048576) then do
       SIZE_IN_MB = SIZE_IN_MB/1048576
       MUNITS = 'T'
     End
     Else do
       If SIZE_IN_MB/1024 == TRUNC(SIZE_IN_MB/1024) then do
         SIZE_IN_MB = SIZE_IN_MB/1024
         MUNITS = 'G'
       End
       Else MUNITS = 'M'
     End
   End
   When SIZE_IN_MB >= 1073741824 & ,
        SIZE_IN_MB <= 17591112302592 then do
     If SIZE_IN_MB/1073741824 == TRUNC(SIZE_IN_MB/1073741824) ,
        then do
       SIZE_IN_MB = SIZE_IN_MB/1073741824
       MUNITS = 'P'
     End
     Else do
       SIZE_IN_MB = SIZE_IN_MB/1048576
       MUNITS = 'T'
     End
   End
   When SIZE_IN_MB = 17592186040320 then do
       SIZE_IN_MB = 'NOLIMIT'   /* 16384P */
       MUNITS = ''
   End
   When SIZE_IN_MB > 17592186040320 then do
       SIZE_IN_MB = '*NOLIMT'   /* >16384P  (16EB) ?? */
       MUNITS = ''
   End
   Otherwise do
     Queue ' '
     Queue 'Error in FORMAT_MEMSIZE code. Contact Mark Zelden.'
     Queue 'SIZE_IN_MB=' SIZE_IN_MB
     Queue ' '
     SIZE_IN_MB = '*ERROR*'
     MUNITS = ''
   End
End /* select */
STOR_SIZE =  SIZE_IN_MB !! MUNITS
Return STOR_SIZE

BROWSE_ISPF:         /* Browse output if ISPF is active              */
Address ISPEXEC "CONTROL ERRORS RETURN"
Address TSO
prefix = sysvar('SYSPREF')        /* tso profile prefix              */
uid    = sysvar('SYSUID')         /* tso userid                      */
If prefix = '' then prefix = uid  /* use uid if null prefix          */
If prefix <> '' & prefix <> uid then /* different prefix than uid    */
   prefix = prefix !! '.' !! uid  /* use  prefix.uid                 */
ddnm1 = 'DDO'!!random(1,99999)    /* choose random ddname            */
ddnm2 = 'DDP'!!random(1,99999)    /* choose random ddname            */
junk = MSG('OFF')
"ALLOC FILE("!!ddnm1!!") UNIT(SYSALLDA) NEW TRACKS SPACE(2,1) DELETE",
      " REUSE LRECL(80) RECFM(F B) BLKSIZE(3120)"
"ALLOC FILE("!!ddnm2!!") UNIT(SYSALLDA) NEW TRACKS SPACE(1,1) DELETE",
      " REUSE LRECL(80) RECFM(F B) BLKSIZE(3120) DIR(1)"
junk = MSG('ON')
"Newstack"
/*************************/
/* IPLINFOP Panel source */
/*************************/
If Substr(ZENVIR,6,1) >= 4 then
  If EDITOP = 'YES' then ,
    Queue ")PANEL KEYLIST(ISRSPEC,ISR)"
  Else ,
    Queue ")PANEL KEYLIST(ISRSPBC,ISR)"
Queue ")ATTR"
Queue "  _ TYPE(INPUT)   INTENS(HIGH) COLOR(TURQ) CAPS(OFF)" ,
      "FORMAT(&MIXED)"
If EDITOP = 'YES' then ,
  Queue "  ! AREA(DYNAMIC) EXTEND(ON)   SCROLL(ON) USERMOD('20')"
Else ,
  Queue "  ! AREA(DYNAMIC) EXTEND(ON)   SCROLL(ON)"
Queue "  + TYPE(TEXT)    INTENS(LOW)  COLOR(BLUE)"
Queue "  @ TYPE(TEXT)    INTENS(LOW)  COLOR(TURQ)"
Queue "  % TYPE(TEXT)    INTENS(HIGH) COLOR(GREEN)"
Queue "  ! TYPE(OUTPUT)  INTENS(HIGH) COLOR(TURQ) PAD(-)"
Queue " 01 TYPE(DATAOUT) INTENS(LOW)"
Queue " 02 TYPE(DATAOUT) INTENS(HIGH)"
If EDITOP = 'YES' then do
  Queue " 03 TYPE(DATAOUT) SKIP(ON) /* FOR TEXT ENTER CMD. FIELD */"
  Queue " 04 TYPE(DATAIN)  INTENS(LOW)  CAPS(OFF) FORMAT(&MIXED)"
  Queue " 05 TYPE(DATAIN)  INTENS(HIGH) CAPS(OFF) FORMAT(&MIXED)"
  Queue " 06 TYPE(DATAIN)  INTENS(LOW)  CAPS(IN)  FORMAT(&MIXED)"
  Queue " 07 TYPE(DATAIN)  INTENS(HIGH) CAPS(IN)  FORMAT(&MIXED)"
  Queue " 08 TYPE(DATAIN)  INTENS(LOW)  FORMAT(DBCS) OUTLINE(L)"
  Queue " 09 TYPE(DATAIN)  INTENS(LOW)  FORMAT(EBCDIC) OUTLINE(L)"
  Queue " 0A TYPE(DATAIN)  INTENS(LOW)  FORMAT(&MIXED) OUTLINE(L)"
  Queue " 0D TYPE(DATAIN)  INTENS(LOW)  CAPS(IN)  FORMAT(&MIXED)" !! ,
        " COLOR(BLUE)"
  Queue " 20 TYPE(DATAIN)  INTENS(LOW) CAPS(IN) FORMAT(&MIXED)"
End
Else do
  Queue " 0B TYPE(DATAOUT) INTENS(HIGH) FORMAT(DBCS)"
  Queue " 0C TYPE(DATAOUT) INTENS(HIGH) FORMAT(EBCDIC)"
  Queue " 0D TYPE(DATAOUT) INTENS(HIGH) FORMAT(&MIXED)"
  Queue " 10 TYPE(DATAOUT) INTENS(LOW)  FORMAT(DBCS)"
  Queue " 11 TYPE(DATAOUT) INTENS(LOW)  FORMAT(EBCDIC)"
  Queue " 12 TYPE(DATAOUT) INTENS(LOW)  FORMAT(&MIXED)"
End
If EDITOP = 'YES' then do
  Queue ")BODY WIDTH(&ZWIDTH) EXPAND(//)"
  Queue "@EDIT @&ZTITLE  / /  %Columns!ZCL  !ZCR  +"
End
Else do
  Queue ")BODY EXPAND(//)"
  Queue "%BROWSE  @&ZTITLE  / /  %Line!ZLINES  %Col!ZCOLUMS+"
End
Queue "%Command ===>_ZCMD / /           %Scroll ===>_Z   +"
Queue "!ZDATA ---------------/ /-------------------------!"
Queue "!                     / /                         !"
Queue "! --------------------/-/-------------------------!"
Queue ")INIT"
Queue "  .HELP = IPLINFOH"
If EDITOP = 'YES' then ,
  Queue "  .ZVARS = 'ZSCED'"
Else ,
  Queue "  .ZVARS = 'ZSCBR'"
Queue "  &ZTITLE = 'Mark''s MVS Utilities - IPLINFO'"
Queue "  &MIXED = MIX"
Queue "  IF (&ZPDMIX = N)"
Queue "   &MIXED = EBCDIC"
If EDITOP = 'YES' then do
  Queue "  VGET (ZSCED) PROFILE"
  Queue "  IF (&ZSCED = ' ')"
  Queue "   &ZSCED = 'CSR'"
End
Else do
  Queue "  VGET (ZSCBR) PROFILE"
  Queue "  IF (&ZSCBR = ' ')"
  Queue "   &ZSCBR = 'CSR'"
End
Queue ")REINIT"
Queue "  .HELP = IPLINFOH"
If EDITOP = 'YES' then ,
  Queue "  REFRESH(ZCMD,ZSCED,ZDATA,ZCL,ZCR)"
Else ,
  Queue "  REFRESH(ZCMD,ZSCBR,ZDATA,ZLINES,ZCOLUMS)"
Queue ")PROC"
Queue "  &ZCURSOR = .CURSOR"
Queue "  &ZCSROFF = .CSRPOS"
Queue "  &ZLVLINE = LVLINE(ZDATA)"
If EDITOP = 'YES' then ,
  Queue "  VPUT (ZSCED) PROFILE"
Else ,
  Queue "  VPUT (ZSCBR) PROFILE"
Queue ")END"
/*                                    */
Address ISPEXEC "LMINIT DATAID(PAN) DDNAME("ddnm2")"
Address ISPEXEC "LMOPEN DATAID("pan") OPTION(OUTPUT)"
Do queued()
   Parse pull panline
   Address ISPEXEC "LMPUT DATAID("pan") MODE(INVAR)" ,
           "DATALOC(PANLINE) DATALEN(80)"
End
Address ISPEXEC "LMMADD DATAID("pan") MEMBER(IPLINFOP)"
/* Address ISPEXEC "LMFREE DATAID("pan")" */
"Delstack"
"Newstack"
/*************************/
/* IPLINFOH Panel source */
/*************************/
If Substr(ZENVIR,6,1) >= 4 then
  Queue ")PANEL KEYLIST(ISRSPBC,ISR)"
Queue ")ATTR DEFAULT(!+_)"
Queue "  _ TYPE(INPUT)   INTENS(HIGH) COLOR(TURQ) CAPS(OFF)" ,
      "FORMAT(&MIXED)"
Queue "  + TYPE(TEXT)    INTENS(LOW)  COLOR(BLUE)"
Queue "  @ TYPE(TEXT)    INTENS(LOW)  COLOR(TURQ)"
Queue "  ! TYPE(TEXT)    INTENS(HIGH) COLOR(GREEN)"
Queue "  # AREA(SCRL)    EXTEND(ON)"
Queue ")BODY EXPAND(//)"
Queue "!HELP    @&ZTITLE  / / "
Queue "!Command ===>_ZCMD / / "
Queue "#IPLHSCR                                          "  !! ,
      "                            #"
Queue ")AREA IPLHSCR"
Queue "@EXECUTION SYNTAX:!TSO %IPLINFO <option>                       "
Queue "+VALID OPTIONS ARE 'ALL', 'IPL', 'VERsion'," !!,
      " 'STOrage', 'CPU', 'IPA', 'SYMbols',"
Queue "+ 'VMAp', 'PAGe', 'SMF', " !!,
      "'SUB', 'ASId', 'LPA', 'LNKlst', 'APF' and 'SVC'"
Queue "@**+OPTIONS may be abbreviated by using 3 or more characters   "
Queue "+Examples:                                                     "
Queue "! TSO %IPLINFO        +(Display all Information)               "
Queue "! TSO %IPLINFO IPL    +(Display IPL Information)               "
Queue "! TSO %IPLINFO VER    +(Display Version Information)           "
Queue "! TSO %IPLINFO STOR   +(Display Storage Information)           "
Queue "! TSO %IPLINFO CPU    +(Display CPU Information)               "
Queue "! TSO %IPLINFO IPA    +(Display Initialization Information)    "
Queue "! TSO %IPLINFO SYM    +(Display Static System Symbols)         "
Queue "! TSO %IPLINFO VMAP   +(Display a Virtual Storage Map)         "
Queue "! TSO %IPLINFO PAGE   +(Display Page Data Set Usage",
                              "Information)"
Queue "! TSO %IPLINFO SMF    +(Display SMF Data Set Usage Information)"
Queue "! TSO %IPLINFO SUB    +(Display Subsystem Information)         "
Queue "! TSO %IPLINFO ASID   +(Display ASID Usage Information)        "
Queue "! TSO %IPLINFO LPA    +(Display LPA List Information)          "
Queue "! TSO %IPLINFO LNK    +(Display LNKLST Information)            "
Queue "! TSO %IPLINFO APF    +(Display APF List Information)          "
Queue "! TSO %IPLINFO SVC    +(Display SVC Information)               "
Queue "@&ADLINE"
Queue ")INIT"
Queue "  .HELP = ISR10000"
Queue "  &ZTITLE = 'Mark''s MVS Utilities - IPLINFO'"
Queue "  &L1 = 'Mark''s MVS Utilities -'"
Queue "  &L2 = 'http://www.mzelden.com/mvsutil.html'"
Queue "  &ADLINE  = '&L1 &L2'"
Queue "  &MIXED = MIX"
Queue "  IF (&ZPDMIX = N)"
Queue "   &MIXED = EBCDIC"
Queue ")END"
/*                                    */
Do queued()
   Parse pull panline
   Address ISPEXEC "LMPUT DATAID("pan") MODE(INVAR)" ,
           "DATALOC(PANLINE) DATALEN(80)"
End
Address ISPEXEC "LMMADD DATAID("pan") MEMBER(IPLINFOH)"
Address ISPEXEC "LMFREE DATAID("pan")"
"Delstack"
"EXECIO" Queued() "DISKW" ddnm1 "(FINIS"
zerrsm  = 'IPLINFO' LASTUPD
zerrlm  = 'IPLINFO -' OPTION 'option.' ,
          'Last updated on' LASTUPD !!'. Written by' ,
          'Mark Zelden. Mark''s MVS Utilities -' ,
          'http://www.mzelden.com/mvsutil.html'
zerralrm = 'NO'        /* msg - no alarm */
zerrhm   = 'IPLINFOH'  /* help panel */
address ISPEXEC "LIBDEF ISPPLIB LIBRARY ID("!!ddnm2!!") STACK"
address ISPEXEC "SETMSG MSG(ISRZ002)"
address ISPEXEC "LMINIT DATAID(TEMP) DDNAME("!!ddnm1!!")"
If EDITOP = 'YES' then ,
  address ISPEXEC "EDIT DATAID("!!temp") PANEL(IPLINFOP)"
Else ,
  address ISPEXEC "BROWSE DATAID("!!temp") PANEL(IPLINFOP)"
address ISPEXEC "LMFREE DATAID("!!temp")"
address ISPEXEC "LIBDEF ISPPLIB"
junk = MSG('OFF')
"FREE FI("!!ddnm1!!")"
"FREE FI("!!ddnm2!!")"
Return

REXXTOD:
/* REXX */
/*                                       */
/* AUTHOR: Mark Zelden                   */
/*                                       */
/***********************************************************/
/* Convert TOD string which is units since January 1, 1990 */
/* Result is in format of YYYY.DDD HH:MM:SS.ttt            */
/*                                                         */
/* Examples:                                               */
/*   REXXTOD B92E37543F000000  -->  2003.086 05:06:06.435  */
/*   REXXTOD C653258535522000  -->  2010.205 13:23:45.154  */
/*   REXXTOD C8B8D8A516A77000  -->  2011.328 16:09:07.768  */
/***********************************************************/
Arg TODIN
 /* Numeric Digits 16 */    /* commented out, IPLINFO already higher */
TODIN  = Left(TODIN,13,0)   /* rtn can only handle 1000s of a second */
TODIN  = X2d(TODIN)         /* convert to decimal for arithmetic     */
TODIN  = TODIN %  1000
  TTT  = TODIN // 1000      /* 1000s of a second  - ".ttt"           */
TODIN  = TODIN %  1000
  SS   = TODIN // 60;       /* Seconds - "SS"                        */
TODIN  = TODIN %  60
  MM   = TODIN // 60;       /* Minutes - "MM"                        */
TODIN  = TODIN %  60
  HH   = TODIN // 24;       /* Hours   - "HH"                        */
TODIN  = TODIN %  24

TODIN = TODIN + 1           /* add 1 to remainder, needed for next   */
                            /* section of code taken from "RDATE"    */

/* Determine YYYY and DDD */
if TODIN>365 then TODIN=TODIN+1
YEARS_X4=(TODIN-1)%1461
DDD=TODIN-YEARS_X4*1461
if TODIN > 73415 then DDD = DDD +1
EXTRA_YEARS=(DDD*3-3)%1096
DDD=DDD-(EXTRA_YEARS*1096+2)%3
YYYY=YEARS_X4*4+EXTRA_YEARS+1900

/* Format prior to result */
DDD     = Right(DDD,3,'0')
HH      = Right(HH,2,'0')
MM      = Right(MM,2,'0')
SS      = Right(SS,2,'0')
TTT     = Right(TTT,3,'0')

TOD_VAL = YYYY'.'DDD  HH':'MM':'SS'.'TTT
 /* Say TOD_VAL; Exit 0 */
Return TOD_VAL


FORMAT_COMMAS:
/* REXX  - Format whole number with commas */
/*                                         */
/* AUTHOR: Mark Zelden                     */
/*                                         */
Arg WHOLENUM

WHOLENUM  = Strip(WHOLENUM)
COMMAVAR3 = ''
Parse var WHOLENUM COMMAVAR1
COMMAVAR1 = Reverse(COMMAVAR1)
Do while COMMAVAR1 <> ''
  Parse var COMMAVAR1 COMMAVAR2 4 COMMAVAR1
  If COMMAVAR3 = '' then COMMAVAR3 = COMMAVAR2
  Else COMMAVAR3 = COMMAVAR3','COMMAVAR2
End
FORMATTED_WHOLENUM = Reverse(COMMAVAR3)
Return FORMATTED_WHOLENUM


/* rexx */
RDATE:
/*                                       */
/* AUTHOR: Mark Zelden                   */
/*                                       */
/************************************************/
/* Convert MM DD YYYY , YYYY DDD, or NNNNN to   */
/* standard date output that includes the day   */
/* of the week and the number of days (NNNNN)   */
/* from January 1, 1900. This is not the same   */
/* as the Century date! Valid input dates range */
/* from 01/01/1900 through 12/31/2172.          */
/*                                              */
/* A parm of "TODAY" can also be passed to      */
/* the date conversion routine.                 */
/* MM DD YYYY can also be specifed as           */
/* MM/DD/YYYY or MM-DD-YYYY.                    */
/*                                              */
/* The output format is always as follows:      */
/*      MM/DD/YYYY.JJJ NNNNN WEEKDAY            */
/*                                              */
/* The above value will be put in the special   */
/* REXX variable "RESULT"                       */
/* example: CALL RDATE TODAY                    */
/* example: CALL RDATE 1996 300                 */
/* example: CALL RDATE 10 26 1996               */
/* example: CALL RDATE 10/26/1996               */
/* example: CALL RDATE 10-26-1996               */
/* example: CALL RDATE 35363                    */
/* result:  10/26/1996.300 35363 Saturday       */
/************************************************/
arg P1 P2 P3

If Pos('/',P1) <> 0 ! Pos('-',P1) <> 0 then do
  PX =  Translate(P1,'  ','/-')
  Parse var PX P1 P2 P3
End

JULTBL = '000031059090120151181212243273304334'
DAY.0 = 'Sunday'
DAY.1 = 'Monday'
DAY.2 = 'Tuesday'
DAY.3 = 'Wednesday'
DAY.4 = 'Thursday'
DAY.5 = 'Friday'
DAY.6 = 'Saturday'

Select
  When P1 = 'TODAY' then do
    P1 = Substr(date('s'),5,2)
    P2 = Substr(date('s'),7,2)
    P3 = Substr(date('s'),1,4)
    call CONVERT_MDY
    call THE_END
  end
  When P2 = '' & P3 = '' then do
    call CONVERT_NNNNN
    call THE_END
  end
  When P3 = '' then do
    call CONVERT_JDATE
    call DOUBLE_CHECK
    call THE_END
  end
  otherwise do
    call CONVERT_MDY
    call DOUBLE_CHECK
    call THE_END
  end
end /* end select */
/* say RDATE_VAL; exit 0 */
return RDATE_VAL
/**********************************************/
/*  E N D    O F   M A I N L I N E   C O D E  */
/**********************************************/

CONVERT_MDY:
if P1<1 ! P1>12 then do
  say 'Invalid month passed to date routine'
  exit 12
end
if P2<1 ! P2>31 then do
  say 'Invalid day passed to date routine'
  exit 12
end
if (P1=4 ! P1=6 ! P1=9 ! P1=11) & P2>30 then do
  say 'Invalid day passed to date routine'
  exit 12
end
if P3<1900 ! P3>2172 then do
  say 'Invalid year passed to date routine. Must be be 1900-2172'
  exit 12
end
BASE   = Substr(JULTBL,((P1-1)*3)+1,3)
if (P3//4=0 & P3<>1900 & P3<>2100) then LEAP= 1
  else LEAP = 0
if P1 > 2 then BASE = BASE+LEAP
JJJ = BASE + P2

MM   = P1
DD   = P2
YYYY = P3
return

CONVERT_NNNNN:
if P1<1 ! P1>99712 then do
  say 'Invalid date passed to date routine. NNNNN must be 1-99712'
  exit 12
end
/* Determine YYYY and JJJ */
if P1>365 then P1=P1+1
YEARS_X4=(P1-1)%1461
JJJ=P1-YEARS_X4*1461
if P1 > 73415 then JJJ = JJJ +1
EXTRA_YEARS=(JJJ*3-3)%1096
JJJ=JJJ-(EXTRA_YEARS*1096+2)%3
YYYY=YEARS_X4*4+EXTRA_YEARS+1900
P1 = YYYY ; P2 = JJJ ;  call CONVERT_JDATE

CONVERT_JDATE:
MATCH = 'N'
if P1<1900 ! P1>2172 then do
  say 'Invalid year passed to date routine. Must be be 1900-2172'
  exit 12
end
if P2<1 ! P2>366 then do
  say 'Invalid Julian date passed to date routine'
  exit 12
end
if (P1//4=0 & P1<>1900 & P1<>2100) then LEAP= 1
  else LEAP = 0
ADJ1 = 0
ADJ2 = 0
Do MM = 1 to 11
   VAL1 = Substr(JULTBL,((MM-1)*3)+1,3)
   VAL2 = Substr(JULTBL,((MM-1)*3)+4,3)
   if MM >=2 then ADJ2 = LEAP
   if MM >=3 then ADJ1 = LEAP
   if P2 > VAL1+ADJ1 & P2 <= VAL2+ADJ2 then do
        DD = P2-VAL1-ADJ1
        MATCH = 'Y'
        leave
   end
end
if MATCH <> 'Y' then do
    MM = 12
    DD = P2-334-LEAP
end

YYYY = P1
JJJ  = P2
return

DOUBLE_CHECK:
if MM = 2 then do
   if DD > 28 & LEAP = 0 then do
     say 'Invalid day passed to date routine'
     exit 12
   end
   if DD > 29 & LEAP = 1 then do
     say 'Invalid day passed to date routine'
     exit 12
   end
end
if LEAP = 0 & JJJ > 365 then do
  say 'Invalid Julian date passed to date routine'
  exit 12
end
return

THE_END:
YR_1900 = YYYY-1900
NNNNN = (YR_1900*365) +(YR_1900+3)%4 + JJJ
if YYYY > 1900 then NNNNN = NNNNN-1
if YYYY > 2100 then NNNNN = NNNNN-1
INDEX   = NNNNN//7  /* index to DAY stem */
WEEKDAY =  DAY.INDEX

DD      = Right(DD,2,'0')
MM      = Right(MM,2,'0')
YYYY    = Strip(YYYY)
NNNNN   = Right(NNNNN,5,'0')
JJJ     = Right(JJJ,3,'0')

RDATE_VAL = MM!!'/'!!DD!!'/'!!YYYY!!'.'!!JJJ!!' '!!NNNNN!!' '!!WEEKDAY
return

SIG_ALL:
SIGTYPE = Condition('C')                   /* condition name         */
If SIGTYPE   = 'SYNTAX' then ,             /* SYNTAX error ?         */
  SIGINFO    = Errortext(RC)               /* rexx error message     */
Else SIGINFO = Condition('D')              /* condition description  */
SIGLINE      = Strip(Sourceline(SIGL))     /* error source code      */
Say 'SIGNAL -' SIGTYPE 'ERROR:' SIGINFO ,  /* display the error info */
    'on source line number' SIGL':'        /*   and line number      */
Say '"'SIGLINE'"'                          /* error source code      */
"Delstack"                                 /* delete data stack      */
Exit 16                                    /* exit RC=16             */

./ ADD NAME=JCLXREF
/* REXX    GENSAR     A special-purpose tool for generating control
                      statements for SARBCH.

                Written by Frank Clarke, HAS, Inc.
*/
signal on syntax
tv = ""
hmsg = ""
arg parms "((" opts

optl = Length(opts)                    /* how long ?                 */
if optl > 0 then,                      /* exists ?                   */
if Right(opts,1) = ")" then,           /* last char is close-paren ? */
   opts = Left(opts,optl-1)            /* clip trailing paren        */

parse var opts "TRACE" tv .
if tv ^= "" then interpret "TRACE" tv

if parms = "" then call HELP
if Word(parms,1) = "?" then call HELP

job    = KEYWD(job)
report = KEYWD(report)
gen    = KEYWD(gen)
seq    = KEYWD(seq)

if parms ^= "" then do
   hmsg = "Unrecognized parms:" parms
   call HELP
   end

if job  = "" & report  = "" then do
   hmsg = "Either JOB or REPORT must be specified."
   call HELP
   end

if job ^= "" & report ^= "" then do
   hmsg = "JOB and REPORT are mutually exclusive."
   call HELP
   end

if gen  = "" then do
   hmsg = "GEN is required."
   call HELP
   end

jobid = Strip(job||report)

"NEWSTACK"
queue "/LOAD  ID="jobid
queue "       GEN="gen
if seq ^= "" then,
queue "       SEQ="seq
queue "       DDNAME=WRITE"
"EXECIO * DISKW $OUT (FINIS"
"DELSTACK"

exit

/*-------------------------------------------------------------------*/
HELP:                                  /*@                           */
address TSO "CLEAR"
if hmsg ^= "" then do
   say hmsg
   say ""
   end
say "                                                                 "
say "  GENSAR        is a special-purpose tool for generating control "
say "                statements for SARBCH.                           "
say "                                                                 "
say "  Syntax:   GENSAR    < parms >     <  <((>  options >           "
say "                                                                 "
say "            <parms> may be any combination of:                   "
say "                    JOB jobname                                  "
say "                    REPORT reportname                            "
say "                    GEN generation-number                        "
say "                    SEQ sequence-number                          "
say "            except that a) either JOB or REPORT must be specified"
say "                (but not both), and b) GEN is required.  It is   "
say "                wise (but not neccessary) to specify SEQ.        "
say "                                                                 "
exit                                   /*@ HELP                      */

/*-------------------------------------------------------------------*/
KEYWD: Procedure expose,               /*@                           */
       kw parms
arg kw .
if Wordpos(kw,parms) = 0 then,
   kw_val = ""
else,
if Wordpos(kw,parms) = 1 then,
   kwa = kw" "
else kwa = " "kw" "
parse var parms . value(kwa)  kw_val .
if kw_val <> "" then parms = Delword(parms,Wordpos(value(kw),parms),2)
return kw_val                          /*@ KEYWD                     */

/*-------------------------------------------------------------------*/
SWITCH:                                /*@                           */
arg kw .
sw_val  = Wordpos(value(kw),parms) > 0
if sw_val  then parms = Delword(parms,Wordpos(value(kw),parms),1)
return sw_val                          /*@ SWITCH                    */

/*-------------------------------------------------------------------*/
SYNTAX:                                /*@                           */
   errormsg = "REXX error" rc "in line" sigl":" errortext(rc)
   say errormsg
   say sourceline(sigl)
   trace "?r"
   nop
exit                                   /*@ SYNTAX                    */

./ ADD NAME=JOBNAME
/* Rexx */
/*https://www.ibmmainframeforum.com/clist-rexx/topic2206.html*/
/* --- Get Address of ASCB ----------------------- */
ASCB_Addr = C2D(Storage(224,4)) /* Get address of ASCB */

/* --- First check ASCBJBNI for Jobname ------------------- */
Interpret "JobAddr = Storage("D2X(ASCB_ADDR+172)",4)"

If C2D(JobAddr) = 0 Then
/* --- Not in initiator, so get jobname from ASCBJBNS -- */
Interpret "JobAddr = Storage("D2X(ASCB_ADDR+176)",4)"

Interpret "Job = Storage("C2X(JobAddr)",8)"
say "Jobname: " Job
exit

Or

/* REXX Get taskname from TCB */
cvt = storage(10,4) /* FLCCVT-PSA data area */
tcbp = storage(d2x(c2d(cvt)),4) /* CVTTCBP */
tcb = storage(d2x(c2d(tcbp)+4),4)
tiot = storage(d2x(c2d(tcb)+12),4) /* TCBTIO */
say storage(d2x(c2d(tiot)),580) /* TIOCNJOB */

./ ADD NAME=LISTDSI
/***************************** REXX ********************************/
/* This exec reallocates a data set with more space. It receives */
/* as arguments the names of a base data set and a new data set. */
/* It uses the SYSDSN function to ensure the base data set exists, */
/* uses the LISTDSI function to set variables with attributes of */
/* the base data set, doubles the primary space variable and then */
/* uses the variables as input to the ALLOCATE command to */
/* reallocate a new data set. */
/*******************************************************************/
 PARSE ARG baseds newds /* Receive the data set names */
 /* with quotes, if any. */
 IF SYSDSN(baseds) = 'OK' THEN
 DO /* If the base data set exists, */
 x = LISTDSI(baseds) /* use the LISTDSI function. */
 IF x = 0 THEN /* If the function code is 0, */
 CALL alc /* call an internal subroutine.*/
 ELSE
 DO /* Else, display the system */
 SAY sysmsglvl1 /* messages and codes for LISTDS*/
 SAY sysmsglvl2
 SAY 'Function code from LISTDSI is' x
 SAY 'Sysreason code from LISTDSI is' sysreason
 END
 END
 ELSE
 SAY 'Data set' baseds 'not found.'
 EXIT
 alc:
 newprimary = 2 * sysprimary /* Compute new primary space. */
 "ALLOC DA("newds") NEW SPACE("newprimary sysseconds") LIKE("baseds")"
 /* Allocate the new data set. */
 IF RC = 0 THEN /* If return code from allocate is 0 */
 SAY 'Data set' newds 'was allocated.'
 ELSE
 SAY 'Data set' newds 'was not allocated. Return code was' RC

./ ADD NAME=MODEL
/* rexx */
/*IBM Fault Analyzer for zOS User's Guide and Reference Version 14 */
ADDRESS TSO
"ALTLIB ACT APPLICATION(CLIST) DA('GIM.SGIMCLS0')"
                                   IDI.SIDIEXEC
  ALTLIB-.-ACTIVATE  -QUIET-.-USER(EXEC)
         !            blank !     (CLIST)
         !                  !     (*)
         !                  !-APPLICATION(EXEC)
         !                  !   !        (CLIST)
         !                  !   '--.-DATASET(dslist)-.-UNCOND
         !                  !      !-DSNAME(dslist)  '-COND
         !                  !      !-FILE(ddname)
         !                  !      !-DDNAME(ddname)
         !                  !      '-LIBRARY(ddname)
         !                  '-SYSTEM(EXEC)
         !                          (CLIST)
         !                          (*)
addRESS ISPEXEC
"LIBDEF ISPMLIB DATASET ID('            ')"
                            IDI.SIDImlib
"LIBDEF ISPPLIB DATASET ID('            ')"
                            IDI.SIDImlib
"LIBDEF ISPSLIB DATASET ID('            ')"
                            IDI.SIDImlib
"LIBDEF ISPTLIB DATASET ID('            ')"
                            IDI.SIDImlib
"SELECT cmdEL(GIM‡PRIM))"
ISPEXEC LIBDEF ISPPLIB /* free plib */
ISPEXEC LIBDEF ISPMLIB /* free mlib */
ISPEXEC LIBDEF ISPSLIB /* free slib */
ISPEXEC LIBDEF ISPTLIB /* free tlib */
ADDRESS TSO
"ALTLIB DEA APPLICATION(CLIST)" /* deactivate clist library */
"END"

./ ADD NAME=PDS2SEQ
/* REXX PDS2SEQ */
/* UNLOAD PDS MEMBERS TO SEQUENTIAL */
/* WITH ./ ADD NAME= COMMANDS FOR MEMBERS */
ARG PDS outp


If PDS = "" then do
   Say "Please type in the name of the input PDS without quotes"
   Pull PDS
   If PDS = "" then exit
   end

If outp= "" then do
   Say "Please type in the name of the output without quotes"
   Say "sequential dataset that will hold data"
   Pull outp
   If outp = "" then exit
   end

outp = "'" !! outp !! "'"
IF SYSDSN(outp) = "OK" then
             "DELETE" outp "PURGE"

SAY "Creating " outp
"ALLOC DDN(outdd) MOD REUSE SPACE(300,150) TRACKS",
      "LRECL(80) BLKSIZE(800) RECFM(F B)",
      "DSN("outp")"

Say "Press ENTER to continue";pull

IF SYSDSN("'"pds"'") <> "OK" THEN DO
   SAY  "PDS NOT USABLE"
   SAY SYSDSN("'"pds"'")
   EXIT 8
   END

ADDRESS ISPEXEC "CONTROL ERRORS RETURN"

CALL INIT
DO 9999 /* limit for testing. change to FOREVER in real life */
  /* EACH EXECUTION OF THIS CMD GIVES ONE MORE MEMBER NAME */
  /* NAME OF MEMBER IS IN VARIABLE member                  */
  ADDRESS ISPEXEC "LMMLIST DATAID("DATAID1") OPTION(LIST)",
                  "MEMBER(member) STATS(YES)"
  /*Non-zero RC means no more members*/
  IF RC = 0 THEN CALL DISPLAY_MEMBER
  ELSE LEAVE /* break out of loop */
END

ADDRESS ISPEXEC "LMMLIST  DATAID("DATAID1") OPTION(FREE)"
ADDRESS ISPEXEC "LMCLOSE DATAID("DATAID1")"
ADDRESS ISPEXEC "LMFREE  DATAID("DATAID1")"

/* at end, write ENDUP, JCL delimiter */
SAY "Program successfully executed - Check your output dataset"
SAY i "members processed"
QUEUE "./ ENDUP"
queue "!!"
queue "//"
queue "//* END \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"
"EXECIO " queued() " DISKW outdd (FINIS)"
"FREE DDN(outdd)"

EXIT 0     /* logical end of program */

INIT:
i=0
/* write JCL at beginning of step */
PDS = translate(PDS," ","'") /* drop apost */
PDS = space(PDS,0) /* drop spaces */
QUEUE "//* Generated by rexx PDS2SEQ     "
QUEUE "//* CHANGE userid to your userid "
QUEUE "//* change PDS if desired"
QUEUE "//* put jobcard at top, submit"
QUEUE "//*DELETE  EXEC PGM=IEFBR14"
QUEUE "//*DD1     DD DSN="PDS","
QUEUE "//*        DISP=(MOD,DELETE),UNIT=SYSDA,SPACE=(TRK,0)"
QUEUE "//*"
QUEUE "//LOAD    EXEC PGM=IEBUPDTE,PARM='NEW'"
QUEUE "//SYSPRINT DD SYSOUT=*"
QUEUE "//SYSUT2  DD DSN="PDS","
QUEUE "//        DISP=(NEW,CATLG,DELETE),"
QUEUE "//        DCB=(DSORG=PO,LRECL=80,BLKSIZE=8000,RECFM=FB),"
QUEUE "//        UNIT=SYSDA,"
QUEUE "//        SPACE=(TRK,(10,05,20),RLSE)"
QUEUE "//*"
QUEUE "//SYSIN  DD DATA,DLM='!!'"

"EXECIO " queued() " DISKW outdd (FINIS)"

 /* LIB MGT ACCESSES THE DATASET */
ADDRESS ISPEXEC "LMINIT DATAID(DATAID1) DATASET('"PDS"') ENQ(SHR)"
/* LIKE AN OPEN WITH REGULAR FILES */
ADDRESS ISPEXEC "LMOPEN DATAID("DATAID1") OPTION(INPUT)"
RETURN

DISPLAY_MEMBER:
i=i+1
/*SAY "MEMBER NAME " member
SAY "RECORDS     " ZLCNORC */

in_pds = PDS"("member")"
in_pds = SPACE(in_pds,0)

/* at beginning of each member, write blank line & ADD command */
DOT_SLASH_ADD.1 = ""
"EXECIO 1 DISKW outdd (STEM DOT_SLASH_ADD.)"
DOT_SLASH_ADD.1 = "./ ADD NAME="member
"EXECIO 1 DISKW outdd (STEM DOT_SLASH_ADD.)"
"ALLOC DDN(indd) SHR REUSE DSN('"in_pds"')"
"EXECIO * DISKR indd (STEM indd. FINIS)"
"EXECIO " indd.0 " DISKW outdd (STEM indd.)"
if rc     <> 0 then Do
   say "**********************************************"
   say "   Error writing seq file: " rc
   say "   Abnormal end   "
   say "**********************************************"
   Exit 8
end
/*
"REPRO INDATASET("in_pds")",
      "OUTFILE(outdd)" */
TRACE OFF
RETURN
ERROR: /* CALL ON ERROR SENDS HERE. DISPLAYS ISPF ERR INFO */
SAY "PROGRAM LIBLIST DID NOT WORK"
SAY ZERRMSG
SAY ZERRSM
SAY ZERRLM

./ ADD NAME=PROFVARS
/* REXX    PROFVARS   Display all the Profile Variables for a
                      given application pool.
   !**-***-***-***-***-***-***-***-***-***-***-***-***-***-***-***-**!
   !                                                                 !
   !          WARNING: EMBEDDED COMPONENTS.                          !
   !                      See text following TOOLKIT_INIT            !
   !                                                                 !
   !**-***-***-***-***-***-***-***-***-***-***-***-***-***-***-***-**!

           Written by Chris Lewis 20021220

     Impact Analysis
.    SYSPROC   TRAPOUT

     Modification History
     20030206 ctl Upgrade Rexxskel from v19971030 to 20020513; Add
                  DEIMBED.  Add ability to open an alternate profile.
     20030206 fxc use LA to acquire ISPPROF dataset name;
     20030207 fxc eliminate unnecessary VGET


*/ arg argline
address TSO                            /* REXXSKEL ver.20020513      */
arg parms "((" opts

signal on syntax
signal on novalue

call TOOLKIT_INIT                      /* conventional start-up     -*/
rc = Trace("O"); rc = Trace(tv)
info   = parms                         /* to enable parsing          */

call A_INIT                            /*                           -*/
                                    if sw.error_found then nop ; else ,
call B_TABLE_OPS                       /*                           -*/

if ^sw.nested then call DUMP_QUEUE     /*                           -*/
exit                                   /*@                           */
/*
.  ----------------------------------------------------------------- */
A_INIT:                                /*@                           */
   if branch then call BRANCH
   address ISPEXEC

  "CONTROL ERRORS RETURN"              /* handle our own errors      */

   parse value KEYWD("APPL")         with ,
               appl   .

   call AI_ISPPROF                     /* get profile names         -*/

return                                 /*@ A_INIT                    */
/*
   Determine profile-dataset-name.  Find all ..PROF members in that
   dataset.
.  ----------------------------------------------------------------- */
AI_ISPPROF:                            /*@                           */
   if branch then call BRANCH
   address TSO

   "NEWSTACK"
   "LA ISPPROF (( STACK LIST"
   parse pull . ":" profdsn .
   "DELSTACK"

   "NEWSTACK"
   "MEMBERS" "'"profdsn"'" "((STACK LINE"
   parse pull mbrlist
   "DELSTACK"
   rmbr = Reverse(mbrlist)
   mbr = ""
   do Words(mbrlist)                   /* each word                  */
      parse value rmbr mbr  with  mbr rmbr
      if Left(mbr,4) <> "FORP" then,   /* PROF reversed              */
         mbr = ""                      /* don't keep it              */
   end                                 /* mbrlist                    */
   mbrlist = Reverse(rmbr mbr)         /* restore                    */

return                                 /*@ AI_ISPPROF                */
/*
   Load the PROFILE member names onto the primary selector panel and
   present it for profile selection.
.  ----------------------------------------------------------------- */
B_TABLE_OPS:                           /*@                           */
   if branch then call BRANCH
   address ISPEXEC

   call BA_PROLOG                      /*                           -*/
   call BB_LOAD_TABLE                  /*                           -*/
   call BD_DISPLAY_TABLE               /*                           -*/
   call BZ_EPILOG                      /*                           -*/

return                                 /*@ B_TABLE_OPS               */
/*
.  ----------------------------------------------------------------- */
BA_PROLOG:                             /*@                           */
   if branch then call BRANCH
   address ISPEXEC

   $tn$    = "AP"Right(time("S"),5,0)
   "TBCREATE" $tn$ "NOWRITE REPLACE NAMES(PROFNM)"

return                                 /*@ BA_PROLOG                 */
/*
.  ----------------------------------------------------------------- */
BB_LOAD_TABLE:                         /*@                           */
   if branch then call BRANCH
   address ISPEXEC


return                                 /*@ BB_LOAD_TABLE             */
/*
   Show the primary selection table and allow the user to select one
   or more profiles for display.
.  ----------------------------------------------------------------- */
BD_DISPLAY_TABLE:                      /*@                           */
   if branch then call BRANCH
   address ISPEXEC

   "TBTOP" $tn$
   do forever
      "TBDISPL" $tn$ "PANEL(SELPROF)"
       if rc > 4 then leave

      if zcmd ^= "" then do
         "CONTROL DISPLAY SAVE"
         "CONTROL DISPLAY RESTORE"
         iterate
         end

      do ztdsels
         "CONTROL DISPLAY SAVE"

         call BDA_DETAILS              /*                            */

         "CONTROL DISPLAY RESTORE"

         if ztdsels > 1 then "tbdispl" $tn$

      end                              /* ztdsels                    */

      sel = ""

   end                                 /* forever                    */

return                                 /*@ BD_DISPLAY_TABLE          */
/*
   Process the selection made from the primary selection table
   (profile name).  Show the details of this profile.
.  ----------------------------------------------------------------- */
BDA_DETAILS: Procedure expose,         /*@ hide everythin except...  */
   (tk_globalvars)
   if branch then call BRANCH
   address ISPEXEC

   call BDAA_PROLOG                    /*                           -*/
   call BDAD_DISPLAY                   /*                           -*/
   call BDAZ_EPILOG                    /*                           -*/

return                                 /*@ BDA_DETAILS               */
/*
.  ----------------------------------------------------------------- */
BDAA_PROLOG:                           /*@                           */
   if branch then call BRANCH
   address ISPEXEC

   pnlname = "PROFVARS"
   proftbl = appl!!"PROF"              /* name of prof table         */
   tblname = "AP"!!right(time("S"),6,0)

  "TBSTATS" proftbl "STATUS2(S2)"

   if s2 > 1 then return               /* table is already open      */

  "LIBDEF ISPTLIB DATASET ID('"profdsn"')"
  "TBOPEN" proftbl "NOWRITE"
   if rc <> 0 then do
      sw.error_found = 1
      zerrsm = "Table Error"
      zerrlm = "Unable to open" proftbl".  Is this a valid Profile?"
     "SETMSG MSG(ISRZ002)"
      end                              /* rc <> 0                    */
  "LIBDEF ISPTLIB"                     /* open table                 */
                                    if sw.error_found then return
  "TBTOP"  proftbl
  "TBSKIP" proftbl "NUMBER(1) SAVENAME(SAVES)" /* variable are stored*/
                                       /* in an extension variable   */
   parse var saves "(" saves ")" .     /* grab all variable names    */

  "TBCREATE" tblname "NOWRITE REPLACE KEYS(X4NAME) NAMES(LEN VARVAL)"


return                                 /*@ BDAA_PROLOG               */
/*
.  ----------------------------------------------------------------- */
BDAD_DISPLAY:                          /*@                           */
   if branch then call BRANCH
   address ISPEXEC


return                                 /*@ BDAD_DISPLAY              */
/*
.  ----------------------------------------------------------------- */
BDAZ_EPILOG:                           /*@                           */
   if branch then call BRANCH
   address ISPEXEC


return                                 /*@ BDAZ_EPILOG               */
/*
.  ----------------------------------------------------------------- */
BZ_EPILOG:                             /*@                           */
   if branch then call BRANCH
   address ISPEXEC


return                                 /*@ BZ_EPILOG                 */
/*
.  ----------------------------------------------------------------- */
B_GO:                                  /*@                           */
   if branch then call BRANCH
   address ISPEXEC

   call BA_LOAD_TABLE                  /*                           -*/
   call BB_DISPLAY_TABLE               /*                           -*/

return                                 /*@ B_GO                      */
/*
   Load the profile variables from the xxxxPROF table onto the temp
   table.
.  ----------------------------------------------------------------- */
BA_LOAD_TABLE:                         /*@                           */
   if branch then call BRANCH
   address ISPEXEC

   do while saves <> ""
     parse var saves x4name saves
     varval = value(x4name)
     len    = length(varval)
    "TBADD" tblname
   end                                 /* while                      */

return                                 /*@ BA_LOAD_TABLE             */
/*
   Show to user.
.  ----------------------------------------------------------------- */
BB_DISPLAY_TABLE:                      /*@                           */
   if branch then call BRANCH
   address ISPEXEC

   call DEIMBED                        /* expand the panel          -*/

   dd = ""
   do Words(ddnlist)                   /* each LIBDEF DD             */
      parse value ddnlist dd  with  dd ddnlist
      $ddn   = $ddn.dd                 /* PLIB322 <- PLIB            */
      "LIBDEF  ISP"dd "LIBRARY  ID("$ddn") STACK"
   end
   ddnlist = ddnlist dd

  "TBSORT" tblname "FIELDS(NAME,C,A)"  /* sort and set crp to top    */

   do forever
     "TBDISPL" tblname "PANEL("pnlname")"
      if rc <> 0 then leave
   end                                 /* forever                    */

   dd = ""
   do Words(ddnlist)                   /* each LIBDEF DD             */
      parse value ddnlist dd  with  dd ddnlist
      $ddn   = $ddn.dd                 /* PLIB322 <- PLIB            */
      "LIBDEF  ISP"dd
      address TSO "FREE  FI("$ddn")"
   end
   ddnlist = ddnlist dd

return                                 /*@ BB_DISPLAY_TABLE          */
/*
   Close the tables
.  ----------------------------------------------------------------- */
Z_FINIS:                               /*@                           */
   if branch then call BRANCH
   address ISPEXEC

  "TBEND" tblname

   if sw.OPENED then
     "TBEND" proftbl

return                                 /*@ Z_FINIS                   */

/*
.  ----------------------------------------------------------------- */
LOCAL_PREINIT:                         /*@ customize opts            */
   address TSO


return                                 /*@ LOCAL_PREINIT             */
/*
   Parse out the embedded components at the back of the source code.
.  ----------------------------------------------------------------- */
DEIMBED: Procedure expose,             /*@                           */
   (tk_globalvars)  ddnlist  $ddn.  daid.

   address TSO

   fb80po.0  = "NEW UNIT(VIO) SPACE(5 5) TRACKS DIR(40)",
                   "RECFM(F B) LRECL(80) BLKSIZE(0)"
   parse value ""   with  ddnlist $ddn.  daid.

   lastln   = sourceline()
   currln   = lastln
   if Left(sourceline(currln),2) <> "*/" then return

   currln = currln - 1                 /* previous line              */
   "NEWSTACK"
   address ISPEXEC
   do while sourceline(currln) <> "/*"
      text = sourceline(currln)        /* save with a short name !   */
      if Left(text,3) = ")))" then do  /* package the queue          */
         parse var text ")))" ddn mbr .   /* PLIB PANL001  maybe     */
         if Pos(ddn,ddnlist) = 0 then do  /* doesn't exist           */
            ddnlist = ddnlist ddn      /* keep track                 */
            $ddn = ddn !! Random(999)
            $ddn.ddn = $ddn
            address TSO "ALLOC FI("$ddn")" fb80po.0
            "LMINIT DATAID(DAID) DDNAME("$ddn")"
            daid.ddn = daid
            end
         daid = daid.ddn
         "LMOPEN DATAID("daid") OPTION(OUTPUT)"
         do queued()
            parse pull line
            "LMPUT DATAID("daid") MODE(INVAR) DATALOC(LINE) DATALEN(80)"
         end
         "LMMADD DATAID("daid") MEMBER("mbr")"
         "LMCLOSE DATAID("daid")"
         end                           /* package the queue          */
      else push text                   /* onto the top of the stack  */
      currln = currln - 1              /* previous line              */
   end                                 /* while                      */
   address TSO "DELSTACK"

return                                 /*@ DEIMBED                   */
/*   subroutines below LOCAL_PREINIT are not selected by SHOWFLOW    */
/*
.  ----------------------------------------------------------------- */
HELP:                                  /*@                           */
address TSO;"CLEAR"
say ""
if helpmsg <> "" then do ; say helpmsg; say ""; end
ex_nam = Left(exec_name,8)             /* predictable size           */
say "  "ex_nam"      Display all the Profile Variables for a                "
say "                given application pool.                                "
say "                                                                       "
say "  Syntax:   "ex_nam"  APPL <applid>                                    "
say "                                                                       "
say "            APPL      Keyword to allow another Profile (xxxxPROF)      "
say "                      to be displayed.  The default is the active      "
say "                      pool (stored in ZAPPLID)                         "
say "                                                                       "
"NEWSTACK"; pull ; "CLEAR" ; "DELSTACK"
say "   Debugging tools provided include:                                   "
say "                                                                       "
say "        MONITOR:  displays key information throughout processing.      "
say "                                                                       "
say "        NOUPDT:   by-pass all update logic.                            "
say "                                                                       "
say "        BRANCH:   show all paragraph entries.                          "
say "                                                                       "
say "        TRACE tv: will use value following TRACE to place the          "
say "                  execution in REXX TRACE Mode.                        "
say "                                                                       "
say "                                                                       "
say "   Debugging tools can be accessed in the following manner:            "
say "                                                                       "
say "        TSO "ex_nam"  parameters     ((  debug-options                 "
say "                                                                       "
say "   For example:                                                        "
say "                                                                       "
say "        TSO "ex_nam"  (( MONITOR TRACE ?R                              "
address ISPEXEC "CONTROL DISPLAY REFRESH"
exit                                   /*@ HELP                      */
/*
.  ----------------------------------------------------------------- */
BRANCH: Procedure expose,              /*@                           */
        sigl exec_name
   rc = trace("O")                     /* we do not want to see this */
   arg brparm .

   origin = sigl                       /* where was I called from ?  */
   do currln = origin to 1 by -1       /* inch backward to label     */
      if Right(Word(Sourceline(currln),1),1) = ":" then do
         parse value sourceline(currln) with pgfname ":" .  /* Label */
         leave ; end                   /*                name        */
   end                                 /* currln                     */

   select
      when brparm = "NAME" then return(pgfname) /* Return full name  */
      when brparm = "ID"      then do           /* wants the prefix  */
         parse var pgfname pgfpref "_" .        /* get the prefix    */
         return(pgfpref)
         end                           /* brparm = "ID"              */
      otherwise
         say left(sigl,6) left(pgfname,40) exec_name "Time:" time("L")
   end                                 /* select                     */

return                                 /*@ BRANCH                    */
/*
.  ----------------------------------------------------------------- */
DUMP_QUEUE:                            /*@ Take whatever is in stack */
   rc = trace("O")                     /*  and write to the screen   */
   address TSO

   "QSTACK"                            /* how many stacks?           */
   stk2dump    = rc - tk_init_stacks   /* remaining stacks           */
   if stk2dump = 0 & queued() = 0 then return
   say "Total Stacks" rc ,             /* rc = #of stacks            */
    "   Begin Stacks" tk_init_stacks , /* Stacks present at start    */
    "   Excess Stacks to dump" stk2dump

   do dd = rc to tk_init_stacks by -1  /* empty each one.            */
      say "Processing Stack #" dd "   Total Lines:" queued()
      do queued();pull line;say line;end /* pump to the screen       */
      "DELSTACK"                       /* remove stack               */
   end                                 /* dd = 1 to rc               */

return                                 /*@ DUMP_QUEUE                */
/* Handle CLIST-form keywords             added 20020513
.  ----------------------------------------------------------------- */
CLKWD: Procedure expose info           /*@ hide all except info      */
   arg kw
   kw = kw"("                          /* form is 'KEY(DATA)'        */
   kw_pos = Pos(kw,info)               /* find where it is, maybe    */
   if kw_pos = 0 then return ""        /* send back a null, not found*/
   rtpt   = Pos(") ",info" ",kw_pos)   /* locate end-paren           */
   slug   = Substr(info,kw_pos,rtpt-kw_pos+1)     /* isolate         */
   info   = Delstr(info,kw_pos,rtpt-kw_pos+1)     /* excise          */
   parse var slug (kw)     slug        /* drop kw                    */
   slug   = Reverse(Substr(Reverse(Strip(slug)),2))
return slug                            /*@CLKWD                      */
/* Handle multi-word keys 20020513
.  ----------------------------------------------------------------- */
KEYWD: Procedure expose info           /*@ hide all vars, except info*/
   arg kw
   kw_pos = wordpos(kw,info)           /* find where it is, maybe    */
   if kw_pos = 0 then return ""        /* send back a null, not found*/
   kw_val = word(info,kw_pos+Words(kw))/* get the next word          */
   info   = Delword(info,kw_pos,2)     /* remove both                */
return kw_val                          /*@ KEYWD                     */
/*
.  ----------------------------------------------------------------- */
KEYPHRS: Procedure expose,             /*@                           */
         info helpmsg exec_name        /*  except these three        */
   arg kp
   wp    = wordpos(kp,info)            /* where is it?               */
   if wp = 0 then return ""            /* not found                  */
   front = subword(info,1,wp-1)        /* everything before kp       */
   back  = subword(info,wp+1)          /* everything after kp        */
   parse var back dlm back             /* 1st token must be 2 bytes  */
   if length(dlm) <> 2 then            /* Must be two bytes          */
      helpmsg = helpmsg,
               "Invalid length for delimiter("dlm") with KEYPHRS("kp")"
   if wordpos(dlm,back) = 0 then       /* search for ending delimiter*/
      helpmsg = helpmsg,
               "No matching second delimiter("dlm") with KEYPHRS("kp")"
   if helpmsg <> "" then call HELP     /* Something is wrong         */
   parse var back kpval (dlm) back     /* get everything b/w delim   */
   info =  front back                  /* restore remainder          */
return Strip(kpval)                    /*@ KEYPHRS                   */
/*
.  ----------------------------------------------------------------- */
NOVALUE:                               /*@                           */
   say exec_name "raised NOVALUE at line" sigl
   say " "
   say "The referenced variable is" condition("D")
   say " "
   zsigl = sigl
   signal SHOW_SOURCE                  /*@ NOVALUE                   */
/*
.  ----------------------------------------------------------------- */
SHOW_SOURCE:                           /*@                           */
   call DUMP_QUEUE                     /* Spill contents of stacks  -*/
   if sourceline() <> "0" then         /* to screen                  */
      say sourceline(zsigl)
   rc =  trace("?R")
   nop
   exit                                /*@ SHOW_SOURCE               */
/*
.  ----------------------------------------------------------------- */
SS: Procedure                          /*@ Show Source               */
   arg  ssbeg  ssend  .
   if ssend = "" then ssend = 10
   if ^datatype(ssbeg,"W") ! ^datatype(ssend,"W") then return
   ssend = ssbeg + ssend
   do ssii = ssbeg to ssend ; say Strip(sourceline(ssii),'T') ; end
return                                 /*@ SS                        */
/*
.  ----------------------------------------------------------------- */
SWITCH: Procedure expose info          /*@                           */
   arg kw
   sw_val = Wordpos(kw,info) > 0       /* exists = 1; not found = 0  */
   if sw_val then                      /* exists                     */
      info = Delword(info,Wordpos(kw,info),1) /* remove it           */
return sw_val                          /*@ SWITCH                    */
/*
.  ----------------------------------------------------------------- */
SYNTAX:                                /*@                           */
   errormsg = exec_name "encountered REXX error" rc "in line" sigl":",
                        errortext(rc)
   say errormsg
   zsigl = sigl
   signal SHOW_SOURCE                  /*@ SYNTAX                    */
/*
   Can call TRAPOUT.
.  ----------------------------------------------------------------- */
TOOLKIT_INIT:                          /*@                           */
   address TSO
   info = Strip(opts,"T",")")          /* clip trailing paren        */

   parse source  sys_id  how_invokt  exec_name  DD_nm  DS_nm,
                     as_invokt  cmd_env  addr_spc  usr_tokn

   parse value "" with  tv  helpmsg  .
   parse value 0   "ISR00000  YES"     "Error-Press PF1"    with,
               sw.  zerrhm    zerralrm  zerrsm

   if SWITCH("TRAPOUT") then do
      "TRAPOUT" exec_name parms "(( TRACE R" info
      exit
      end                              /* trapout                    */

   if Word(parms,1) = "?" then call HELP /* I won't be back          */

   "QSTACK" ; tk_init_stacks = rc      /* How many stacks?           */

   parse value SWITCH("BRANCH") SWITCH("MONITOR") SWITCH("NOUPDT") with,
               branch           monitor           noupdt    .

   parse value mvsvar("SYSNAME") sysvar("SYSNODE") with,
               #tk_cpu           node          .

   sw.nested    = sysvar("SYSNEST") = "YES"
   sw.batch     = sysvar("SYSENV")  = "BACK"
   sw.inispf    = sysvar("SYSISPF") = "ACTIVE"

   parse value KEYWD("TRACE")  "O"    with   tv  .
   tk_globalvars = "exec_name  tv  helpmsg  sw.  zerrhm  zerralrm ",
                   "zerrsm  zerrlm  tk_init_stacks  branch  monitor ",
                   "noupdt"

   call LOCAL_PREINIT                  /* for more opts             -*/

return                                 /*@ TOOLKIT_INIT              */
/*
)))PLIB PROFVARS
)ATTR DEFAULT(%+_)
  % TYPE(TEXT) INTENS(HIGH) SKIP(ON)
  + TYPE(TEXT) INTENS(LOW) SKIP(ON)
  , TYPE(TEXT) INTENS(HIGH) SKIP(ON) HILITE(BLINK)
  _ TYPE(INPUT)  INTENS(HIGH) CAPS(ON) JUST(LEFT) PAD('_')
  $ TYPE(INPUT)  INTENS(HIGH) CAPS(ON) JUST(LEFT)
  # TYPE(INPUT)  INTENS(LOW)  CAPS(ON) JUST(LEFT)
  @ TYPE(OUTPUT) INTENS(LOW)  CAPS(ON) JUST(LEFT)
  } TYPE(OUTPUT) INTENS(LOW)  CAPS(ON) JUST(RIGHT)
  ! TYPE(OUTPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT)
)BODY EXPAND(!!)
+!-!% Variable List of!PROFTBL +!-!
%COMMAND ===>$ZCMD                                            %SCROLL ===>$AMT +
+
+
%V  Name     Length Value
++  ======== ====== ===========================================================
)MODEL ROWS(ALL)
_z+@X4NAME  }LEN  +@VARVAL
)INIT
)PROC
)END
*/

./ ADD NAME=PULLSAR
/* REXX    PULLSAR    Get SAR reports into a TSO dataset
   !**-***-***-***-***-***-***-***-***-***-***-***-***-***-***-***-**!
   !                                                                 !
   !          WARNING: EMBEDDED COMPONENTS.                          !
   !                      See text following TOOLKIT_INIT            !
   !                                                                 !
   !**-***-***-***-***-***-***-***-***-***-***-***-***-***-***-***-**!

           Written by Frank Clarke 20011114

     Impact Analysis
.    SYSEXEC   TRAPOUT
.    (alias)   STORANAL

     Modification History
     20070905 fxc removed redundant SYSTSIN/SYSTSPRT;

*/ arg argline
address TSO                            /* REXXSKEL ver.20010802      */
arg parms "((" opts

signal on syntax
signal on novalue

call TOOLKIT_INIT                      /* conventional start-up     -*/
rc     = trace(tv)
info   = parms                         /* to enable parsing          */

address ISPEXEC "CONTROL ERRORS RETURN" /* I'll handle my own        */
call A_INIT                            /*                           -*/
call B_READ_SAR                        /*                           -*/

if ^sw.nested then call DUMP_QUEUE     /*                           -*/
exit                                   /*@ PULLSAR                   */
/*
.  ----------------------------------------------------------------- */
A_INIT:                                /*@                           */
   if branch then call BRANCH
   address TSO

   call A0_SETUP_LOG                   /*                           -*/
   parse value "?" with  ,
               skl.   progress  ,
               .
   parse value "0 0" with  ,
               s#      ,
               .
   sardsn = "ACN1.PR.D502.S01"
   skl.PULLSAR    = "SARBCH"
   skl.STORANAL   = "SARVIO"

   parse var info pgmname .

return                                 /*@ A_INIT                    */
/*
.  ----------------------------------------------------------------- */
A0_SETUP_LOG:                          /*@                           */
   if branch then call BRANCH
   address TSO

   parse value "0" with,
               log#    log.
   parse value Date("S")  Time("S")  Time("N")  with,
               yyyymmdd   sssss      hhmmss  .
   parse var yyyymmdd  4 yrdigit 5 mm 7 dd          /* 9 12 14 maybe */
   if Pos(yrdigit,"13579") > 0 then mm = mm + 12       /* mm=24      */
   logtag = Substr("ABCDEFGHIJKLMNOPQRSTUVWX",mm,1)    /* logtag=X   */
   subid  = logtag""dd""Right(sssss,5,0)               /* X1423722 ? */
   vb4k.0    = "NEW CATALOG UNIT(SYSDA) SPACE(1 5) TRACKS",
               "RECFM(V B) LRECL(4096) BLKSIZE(0)"
   vb4k.1    = "SHR"                   /* if it already exists...    */
   logdsn = "@@LOG."exec_name"."subid".LIST"

   origds   =  FIND_ORIGIN()
   call ZL_LOGMSG("Log started by" Userid()  yyyymmdd  hhmmss)
   call ZL_LOGMSG("Arg:" argline)
   call ZL_LOGMSG("Running from" origds)
   parse var origds  "'" sysexec "("

return                                 /*@ A0_SETUP_LOG              */
/*
.  ----------------------------------------------------------------- */
B_READ_SAR:                            /*@                           */
   if branch then call BRANCH
   address TSO

   call BA_PROLOG                      /*                           -*/
   call BR_RETRIEVE                    /*                           -*/
   call BZ_EPILOG                      /*                           -*/

return                                 /*@ B_READ_SAR                */
/*
   DEIMBED, set up LIBDEFs
.  ----------------------------------------------------------------- */
BA_PROLOG:                             /*@                           */
   if branch then call BRANCH
   address ISPEXEC

   call DEIMBED                        /*                           -*/
   dd = ""
   do Words(ddnlist)                   /* each LIBDEF DD             */
      parse value ddnlist dd  with  dd ddnlist
      $ddn   = $ddn.dd                 /* PLIB322 <- PLIB            */
      "LIBDEF  ISP"dd "LIBRARY  ID("$ddn") STACK"
   end
   ddnlist = ddnlist dd

return                                 /*@ BA_PROLOG                 */
/*
   Invoke SARBCH to produce the SAR.SAPRINT dataset.  This is done via
   a background job because SARBCH is authorized and cannot be run in
   the foreground.
.  ----------------------------------------------------------------- */
BR_RETRIEVE:                           /*@                           */
   if branch then call BRANCH
   address ISPEXEC

   call BRA_NEXT_JOB                   /*                            */
   "FTOPEN TEMP"
   "FTINCL JOBCARDS"
   if Words(info) > 1 then,
      call BRS_STACK_JOBS              /*                           -*/
   else,
      call BRB_SHOW_SARPARM            /*                           -*/

   if progress = "" then do            /* nothing queued             */
      "FTCLOSE"                        /* nothing usable             */
      zerrsm = "Entry refused"
      zerrlm = "Panel PROLSAR requires you to enter a report name",
               "and press ENTER. ",
               "You may have pressed PF3 in error."
      "SETMSG MSG(ISRZ002)"
      call ZL_LOGMSG("("BRANCH("ID")")",
            zerrlm)
      end                              /* no report selected         */
   else call BRR_RUN_SAR               /* acquire report from SAR   -*/

return                                 /*@ BR_RETRIEVE               */
/*
.  ----------------------------------------------------------------- */
BRA_NEXT_JOB:                          /*@                           */
   if branch then call BRANCH
   address ISPEXEC

   alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZA"
   "VGET JOB1 PROFILE"
   if job1 = "" then do                /* doesn't exist?             */
      address TSO "JOBCARDS" argline   /* setup jobcards             */
      "VGET JOB1 PROFILE"
      end
   parse var job1 jobn .               /* //DOPUCDF                  */
   jobchar = Right(jobn,1)             /* F                          */
   pt = Pos(jobchar,alphabet) + 1      /* 7                          */
   jobchar = Substr(alphabet,pt,1)     /* G                          */
   job1    = Overlay(jobchar,job1,,
                     Length(jobn))     /* //DOPUCDG                  */
   "VPUT JOB1 PROFILE"

return                                 /*@ BRA_NEXT_JOB              */
/*
.  ----------------------------------------------------------------- */
BRB_SHOW_SARPARM:                      /*@                           */
   if branch then call BRANCH
   address ISPEXEC

   do forever
      report   = pgmname
      writedsn = pgmname
      "DISPLAY PANEL(SARPARM)"         /* get report genin seqin     */

      if WordPos("?",report genin seqin writedsn) > 0 then do
         "SELECT PGM(SARSPF) PARM("sardsn") NEWAPPL(SAR)"
         iterate                       /* redisplay panel            */
         end
      if rc > 4 then leave             /* user hit PF3 ?             */

      if report = "" then leave        /* no more reports            */
      call ZL_LOGMSG("("BRANCH("ID")")",
               "Report="report "   Genin="genin "   Seqin="seqin)

      parse value "" with sysdsorg
      ldrc   = Listdsi(writedsn "directory norecall")
      if Pos("PO",sysdsorg) > 0 !,
         Pos( "(", writedsn) > 0 then do
         zerrsm = "Must be sequential"
         zerrlm = "Output dataset must be sequential.  DSORG=PO",
                  "is not yet supported."
         "SETMSG  MSG(ISRZ002)"
         iterate
         end

      if Left(writedsn,1) = "'" then,  /* originally quoted          */
         jcldsn = Strip(writedsn,,"'") /* unquoted                   */
      else,                            /* originally unquoted        */
         jcldsn = Userid()"."writedsn  /* fully qualified            */

      s#  = Right(s#+1,2,0)            /* 01 02 03 04 ...            */
      "FTINCL" skl.exec_name           /* JCL for SARBCH             */

      queue "/DBASE NAME="sardsn
      queue "/LOAD ID="Strip(report)
      if genin <> "-0" &,
         genin <> "" then,
         queue "GEN="Strip(genin)
      if seqin <> "+0" &,
         seqin <> "" then,
         queue "SEQ="Strip(seqin)
      queue "DDNAME=WRITE"
      call BRC_INSERT_CMD              /*                           -*/
      if progress = "" then,
         progress = "Prepared:" report
      else,
         progress = progress report

      if exec_name = "STORANAL" then leave
   end                                 /* forever                    */

   if exec_name = "STORANAL" then,
      "FTINCL SARANAL"

return                                 /*@ BRB_SHOW_SARPARM          */
/*
   Write the isolated queue to ISPSLIB and run SAR to acquire the
   report.
.  ----------------------------------------------------------------- */
BRC_INSERT_CMD:                        /*@                           */
   if branch then call BRANCH
   address ISPEXEC

   daid = daid.SLIB                    /* provided by DEIMBED        */
   mbr  = "SARCMDS"
   "LMOPEN DATAID("daid") OPTION(OUTPUT)"

   do queued()
      parse pull line
      "LMPUT DATAID("daid") MODE(INVAR) DATALOC(LINE) DATALEN(80)"
   end

   "LMMREP DATAID("daid") MEMBER("mbr")"
   "LMCLOSE DATAID("daid")"
   "FTINCL SARCMDS"                    /* control info for SARBCH    */

return                                 /*@ BRC_INSERT_CMD            */
/*
   The JCL jobstream is complete.  Submit to the background reader.
.  ----------------------------------------------------------------- */
BRR_RUN_SAR:                           /*@                           */
   if branch then call BRANCH
   address ISPEXEC

   "FTCLOSE"
   "VGET (ZTEMPF ZTEMPN)"
   if sw.0modify then do
      "LMINIT DATAID(DDNID) DDNAME("ztempn")"
      zerrsm = "CAUTION!!!!!"
      zerrlm = "This JCL -WILL- be automatically submitted when",
               "EDIT completes.  If you DO NOT want the JOB to run",
               "you must erase this JCL, saving an empty",
               "dataset."
      "SETMSG  MSG(ISRZ002)"
      "EDIT DATAID("ddnid")"
      end
                                    if noupdt then return
   rc = Outtrap("JS.")                 /* catch SUBMITTED message    */
   address TSO "SUBMIT '"ZTEMPF"'"
   rc = Outtrap("OFF")

   do ccx = 1 to js.0                  /* each line                  */
      if WordPos("SUBMITTED",js.ccx) > 0 then leave
   end                                 /* ccx                        */

   if ccx > js.0 then,
      do ccx = 1 to js.0; say js.ccx
      call ZL_LOGMSG("("BRANCH("ID")")",
               js.ccx)
      end
   else do                             /* SUBMITTED                  */
      if Left(Strip(js.ccx),3) = "IKJ" then ,
         js.ccx = Subword(js.ccx,2)    /* snip msgid                 */
      zerrsm = js.ccx ; zerrlm = zerrsm
      parse var js.ccx "(JOB" jn ")"   /* job number                 */
      jn = jn + 0                      /* strip zeroes               */
      "SETMSG  MSG(ISRZ002)"
      end

return                                 /*@ BRR_RUN_SAR               */
/*
.  ----------------------------------------------------------------- */
BRS_STACK_JOBS:                        /*@                           */
   if branch then call BRANCH
   address ISPEXEC

   report = ""
   do Words(info)
      parse value info  report with report  info
      s#  = Right(s#+1,2,0)            /* 01 02 03 04 ...            */
      "FTINCL" skl.exec_name           /* JCL for SARBCH             */

      queue "/DBASE NAME="sardsn
      queue "/LOAD ID="Strip(report)
      queue "DDNAME=WRITE"
      call BRC_INSERT_CMD              /*                           -*/
      if progress = "" then,
         progress = "Prepared:" report
      else,
         progress = progress report
      "FTINCL  SARANAL"
   end                                 /* words(info)                */

return                                 /*@ BRS_STACK_JOBS            */
/*
   Remove LIBDEFs
.  ----------------------------------------------------------------- */
BZ_EPILOG:                             /*@                           */
   if branch then call BRANCH
   address ISPEXEC

   dd = ""
   do Words(ddnlist)                   /* each LIBDEF DD             */
      parse value ddnlist dd  with  dd ddnlist
      $ddn   = $ddn.dd                 /* PLIB322 <- PLIB            */
      "LIBDEF  ISP"dd
      address TSO "FREE  FI("$ddn")"
   end
   ddnlist = ddnlist dd

return                                 /*@ BZ_EPILOG                 */
/*
.  ----------------------------------------------------------------- */
LOCAL_PREINIT:                         /*@ customize opts            */
   address TSO

   sw.0modify    = SWITCH("EDIT")
   if SWITCH("DIAGNOSE") then tsoparm = "((trace r"
                         else tsoparm = ""

return                                 /*@ LOCAL_PREINIT             */
/*   subroutines below LOCAL_PREINIT are not selected by SHOWFLOW    */
/*
   Parse out the embedded components at the back of the source code.
.  ----------------------------------------------------------------- */
DEIMBED: Procedure expose,             /*@                           */
   (tk_globalvars)  ddnlist  $ddn.  daid.

   address TSO

   fb80po.0  = "NEW UNIT(VIO) SPACE(5 5) TRACKS DIR(40)",
                   "RECFM(F B) LRECL(80) BLKSIZE(0)"
   parse value ""   with  ddnlist $ddn.  daid.

   lastln   = sourceline()
   currln   = lastln                   /*                            */
   if Left(sourceline(currln),2) <> "*/" then return

   currln = currln - 1                 /* previous line              */
   "NEWSTACK"
   address ISPEXEC
   do while sourceline(currln) <> "/*"
      text = sourceline(currln)        /* save with a short name !   */
      if Left(text,3) = ")))" then do  /* package the queue          */
         parse var text ")))" ddn mbr .   /* PLIB PANL001  maybe     */
         if Pos(ddn,ddnlist) = 0 then do  /* doesn't exist           */
            ddnlist = ddnlist ddn      /* keep track                 */
            $ddn = ddn !! Random(999)
            $ddn.ddn = $ddn
            address TSO "ALLOC FI("$ddn")" fb80po.0
            "LMINIT DATAID(DAID) DDNAME("$ddn")"
            daid.ddn = daid
            end
         daid = daid.ddn
         "LMOPEN DATAID("daid") OPTION(OUTPUT)"
         do queued()
            parse pull line
            "LMPUT DATAID("daid") MODE(INVAR) DATALOC(LINE) DATALEN(80)"
         end
         "LMMADD DATAID("daid") MEMBER("mbr")"
         "LMCLOSE DATAID("daid")"
         end                           /* package the queue          */
      else push text                   /* onto the top of the stack  */
      currln = currln - 1              /* previous line              */
   end                                 /* while                      */
   address TSO "DELSTACK"

return                                 /*@ DEIMBED                   */
/*
     Find where code was run from.  It assumes cataloged data sets.

     Original by Doug Nadel
     With SWA code lifted from Gilbert Saint-flour's SWAREQ exec
.  ----------------------------------------------------------------- */
FIND_ORIGIN: Procedure                 /*@                           */
answer="* UNKNOWN *"                   /* assume disaster            */
Parse Source . . name dd ds .          /* get known info             */
Call listdsi(dd "FILE")                /* get 1st ddname from file   */
Numeric digits 10                      /* allow up to 7FFFFFFF       */
If name = "?" Then                     /* if sequential exec         */
  answer="'"ds"'"                      /* use info from parse source */
Else                                   /* now test for members       */
  If sysdsn("'"sysdsname"("name")'")="OK" Then /* if in 1st ds       */
     answer="'"sysdsname"("name")'"    /* go no further              */
  Else                                 /* hooboy! Lets have some fun!*/
    Do                                 /* scan tiot for the ddname   */
      tiotptr=24+ptr(12+ptr(ptr(ptr(16)))) /* get ddname array       */
      tioelngh=c2d(stg(tiotptr,1))     /* nength of 1st entry        */
      Do Until tioelngh=0 ! tioeddnm = dd /* scan until dd found     */
        tioeddnm=strip(stg(tiotptr+4,8)) /* get ddname from tiot     */
        If tioeddnm <> dd Then         /* if not a match             */
          tiotptr=tiotptr+tioelngh     /* advance to next entry      */
        tioelngh=c2d(stg(tiotptr,1))   /* length of next entry       */
      End
      If dd=tioeddnm Then,             /* if we found it, loop through
                                          the data sets doing an swareq
                                          for each one to get the
                                          dsname                     */
        Do Until tioelngh=0 ! stg(4+tiotptr,1)<> " "
          tioejfcb=stg(tiotptr+12,3)
          jfcb=swareq(tioejfcb)        /* convert SVA to 31-bit addr */
          dsn=strip(stg(jfcb,44))      /* dsname JFCBDSNM            */
          vol=storage(d2x(jfcb+118),6) /* volser JFCBVOLS (not used) */
          If sysdsn("'"dsn"("name")'")='OK' Then,  /* found it?      */
            Leave                      /* we is some happy campers!  */
          tiotptr=tiotptr+tioelngh     /* get next entry             */
          tioelngh=c2d(stg(tiotptr,1)) /* get entry length           */
        End
      answer="'"dsn"("name")'"         /* assume we found it         */
    End
Return answer                          /*@ FIND_ORIGIN               */
/*
.  ----------------------------------------------------------------- */
ptr:  Return c2d(storage(d2x(Arg(1)),4))          /*@                */
/*
.  ----------------------------------------------------------------- */
stg:  Return storage(d2x(Arg(1)),Arg(2))          /*@                */
/*
.  ----------------------------------------------------------------- */
SWAREQ:  Procedure                     /*@                           */
If right(c2x(Arg(1)),1) ^= 'F' Then    /* SWA=BELOW ?                */
  Return c2d(Arg(1))+16                /* yes, return sva+16         */
sva = c2d(Arg(1))                      /* convert to decimal         */
tcb = c2d(storage(21c,4))              /* TCB PSATOLD                */
tcb = ptr(540)                         /* TCB PSATOLD                */
jscb = ptr(tcb+180)                    /* JSCB TCBJSCB               */
qmpl = ptr(jscb+244)                   /* QMPL JSCBQMPI              */
qmat = ptr(qmpl+24)                    /* QMAT QMADD                 */
Do While sva>65536
  qmat = ptr(qmat+12)                  /* next QMAT QMAT+12          */
  sva=sva-65536                        /* 010006F -> 000006F         */
End
return ptr(qmat+sva+1)+16              /*@ SWAREQ                    */
/*
.  ----------------------------------------------------------------- */
ZB_SAVELOG:                            /*@                           */
   if branch then call BRANCH
   address TSO

   if Symbol("LOG#") = "LIT" then return          /* not yet set     */

   "ALLOC FI($LOG) DA("logdsn") REU" vb4k.0
   "EXECIO" log# "DISKW $LOG (STEM LOG. FINIS"
   "FREE  FI($LOG)"

return                                 /*@ ZB_SAVELOG                */
/*
.  ----------------------------------------------------------------- */
ZL_LOGMSG: Procedure expose,           /*@                           */
   (tk_globalvars)  log. log#
   rc = Trace("O")
   address TSO

   parse arg msgtext
   parse value  log#+1  msgtext     with,
                zz      log.zz    1  log#   .

   if monitor then say,
      msgtext

return                                 /*@ ZL_LOGMSG                 */
/*
.  ----------------------------------------------------------------- */
HELP:                                  /*@                           */
address TSO;"CLEAR" ; say
if helpmsg <> "" then do ; say helpmsg; say ""; end
ex_nam = Left(exec_name,8)             /* predictable size           */

say "  "ex_nam"      retrieves reports or sysout from SAR to a TSO dataset.    "
say "                                                                          "
if ex_nam = "PULLSAR" then,
say "  Syntax:   "ex_nam"  <no parms>                                          "
if ex_nam = "STORANAL" then,
say "  Syntax:   "ex_nam"  <jobname>                                           "
say "                ((    <EDIT>                                              "
say "                      <DIAGNOSE>                                          "
say "                                                                          "
say "            "ex_nam"  runs as an ISPF dialog and obtains all its run-time "
say "                      information via a panel.  The panel requires you to "
say "                      specify the report/sysout name, the GEN, and the    "
say "                      SEQuence number, all of which should be specified in"
say "                      order to avoid unpredictable results.               "
say "                                                                          "
if ex_nam = "PULLSAR" then do
say "                      In addition, you must also specify a dataset to hold"
say "                      the delivered output.  The dataset will be built, if"
say "                      it does not exist, as PS/VBA/137.                   "
   end
"NEWSTACK"; pull ; "CLEAR" ; "DELSTACK                                      "
say "                                                                          "
say "   Debugging tools provided include:                                      "
say "                                                                          "
say "        MONITOR:  displays key information throughout processing.         "
say "                                                                          "
say "        BRANCH:   show all paragraph entries.                             "
say "                                                                          "
say "        TRACE tv: will use value following TRACE to place the             "
say "                  execution in REXX TRACE Mode.                           "
say "                                                                          "
say "                                                                          "
say "   Debugging tools can be accessed in the following manner:               "
say "                                                                          "
say "        TSO "ex_nam"  parameters     ((  debug-options                    "
say "                                                                          "
say "   For example:                                                           "
say "                                                                          "
say "        TSO "ex_nam"  (( MONITOR TRACE ?R                                 "

address ISPEXEC "CONTROL DISPLAY REFRESH"
exit                                   /*@ HELP                      */
/*
.  ----------------------------------------------------------------- */
BRANCH: Procedure expose,              /*@                           */
        sigl exec_name
   rc = trace("O")                     /* we do not want to see this */
   arg brparm .

   origin = sigl                       /* where was I called from ?  */
   do currln = origin to 1 by -1       /* inch backward to label     */
      if Right(Word(Sourceline(currln),1),1) = ":" then do
         parse value sourceline(currln) with pgfname ":" .  /* Label */
         leave ; end                   /*                name        */
   end                                 /* currln                     */

   select
      when brparm = "NAME" then return(pgfname) /* Return full name  */
      when brparm = "ID"      then do           /* wants the prefix  */
         parse var pgfname pgfpref "_" .        /* get the prefix    */
         return(pgfpref)
         end                           /* brparm = "ID"              */
      otherwise
         say left(sigl,6) left(pgfname,40) exec_name "Time:" time("L")
   end                                 /* select                     */

return                                 /*@ BRANCH                    */
/*
.  ----------------------------------------------------------------- */
DUMP_QUEUE:                            /*@ Take whatever is in stack */
   rc = trace("O")                     /*  and write to the screen   */
   address TSO

   "QSTACK"                            /* how many stacks?           */
   stk2dump    = rc - tk_init_stacks   /* remaining stacks           */
   if stk2dump = 0 & queued() = 0 then return
   say "Total Stacks" rc ,             /* rc = #of stacks            */
    "   Begin Stacks" tk_init_stacks , /* Stacks present at start    */
    "   Excess Stacks to dump" stk2dump

   do dd = rc to tk_init_stacks by -1  /* empty each one.            */
      say "Processing Stack #" dd "   Total Lines:" queued()
      do queued();pull line;say line;end /* pump to the screen       */
      "DELSTACK"                       /* remove stack               */
   end                                 /* dd = 1 to rc               */

return                                 /*@ DUMP_QUEUE                */
/*
.  ----------------------------------------------------------------- */
KEYWD: Procedure expose info           /*@ hide all vars, except info*/
   arg kw
   kw_pos = wordpos(kw,info)           /* find where it is, maybe    */
   if kw_pos = 0 then return ""        /* send back a null, not found*/
   kw_val = word(info,kw_pos+1)        /* get the next word          */
   info   = Delword(info,kw_pos,2)     /* remove both                */
return kw_val                          /*@ KEYWD                     */
/*
.  ----------------------------------------------------------------- */
KEYPHRS: Procedure expose,             /*@                           */
         info helpmsg exec_name        /*  except these three        */
   arg kp
   wp    = wordpos(kp,info)            /* where is it?               */
   if wp = 0 then return ""            /* not found                  */
   front = subword(info,1,wp-1)        /* everything before kp       */
   back  = subword(info,wp+1)          /* everything after kp        */
   parse var back dlm back             /* 1st token must be 2 bytes  */
   if length(dlm) <> 2 then            /* Must be two bytes          */
      helpmsg = helpmsg "Invalid length for delimiter("dlm") with KEYPHRS("kp")"
   if wordpos(dlm,back) = 0 then       /* search for ending delimiter*/
      helpmsg = helpmsg "No matching second delimiter("dlm") with KEYPHRS("kp")"
   if helpmsg <> "" then call HELP     /* Something is wrong         */
   parse var back kpval (dlm) back     /* get everything b/w delim   */
   info =  front back                  /* restore remainder          */
return Strip(kpval)                    /*@ KEYPHRS                   */
/*
.  ----------------------------------------------------------------- */
NOVALUE:                               /*@                           */
   say exec_name "raised NOVALUE at line" sigl
   say " "
   say "The referenced variable is" condition("D")
   say " "
   zsigl = sigl
   signal SHOW_SOURCE                  /*@ NOVALUE                   */
/*
.  ----------------------------------------------------------------- */
SHOW_SOURCE:                           /*@                           */
   call DUMP_QUEUE                     /* Spill contents of stacks  -*/
   if sourceline() <> "0" then         /* to screen                  */
      say sourceline(zsigl)
   rc =  trace("?R")
   nop
   exit                                /*@ SHOW_SOURCE               */
/*
.  ----------------------------------------------------------------- */
SS: Procedure                          /*@ Show Source               */
   arg  ssbeg  ssend  .
   if ssend = "" then ssend = 10
   if ^datatype(ssbeg,"W") ! ^datatype(ssend,"W") then return
   ssend = ssbeg + ssend
   do ssii = ssbeg to ssend ; say Strip(sourceline(ssii),'T') ; end
return                                 /*@ SS                        */
/*
.  ----------------------------------------------------------------- */
SWITCH: Procedure expose info          /*@                           */
   arg kw
   sw_val = Wordpos(kw,info) > 0       /* exists = 1; not found = 0  */
   if sw_val then                      /* exists                     */
      info = Delword(info,Wordpos(kw,info),1) /* remove it           */
return sw_val                          /*@ SWITCH                    */
/*
.  ----------------------------------------------------------------- */
SYNTAX:                                /*@                           */
   errormsg = exec_name "encountered REXX error" rc "in line" sigl":",
                        errortext(rc)
   say errormsg
   zsigl = sigl
   signal SHOW_SOURCE                  /*@ SYNTAX                    */
/*
   Can call TRAPOUT.
.  ----------------------------------------------------------------- */
TOOLKIT_INIT:                          /*@                           */
   address TSO
   info = Strip(opts,"T",")")          /* clip trailing paren        */

   parse source  sys_id  how_invokt  exec_name  DD_nm  DS_nm,
                     as_invokt  cmd_env  addr_spc  usr_tokn

   parse value "" with  tv  helpmsg  .
   parse value 0   "ISR00000  YES"     "Error-Press PF1"    with,
               sw.  zerrhm    zerralrm  zerrsm

   if SWITCH("TRAPOUT") then do
      "TRAPOUT" exec_name parms "(( TRACE R" info
      exit
      end                              /* trapout                    */

   if Word(parms,1) = "?" then call HELP /* I won't be back          */

   "QSTACK" ; tk_init_stacks = rc      /* How many stacks?           */

   parse value SWITCH("BRANCH") SWITCH("MONITOR") SWITCH("NOUPDT") with,
               branch           monitor           noupdt    .

   parse value mvsvar("SYSNAME") sysvar("SYSNODE") with,
               #tk_cpu           node          .

   sw.nested    = sysvar("SYSNEST") = "YES"
   sw.batch     = sysvar("SYSENV")  = "BACK"
   sw.inispf    = sysvar("SYSISPF") = "ACTIVE"

   parse value KEYWD("TRACE")  "O"    with   tv  .
   tk_globalvars = "exec_name  tv  helpmsg  sw.  zerrhm  zerralrm ",
                   "zerrsm  zerrlm  tk_init_stacks  branch  monitor ",
                   "noupdt"

   call LOCAL_PREINIT                  /* for more opts             -*/

return                                 /*@ TOOLKIT_INIT              */
/*
)))PLIB SARPARM
)ATTR
  % TYPE(TEXT)   INTENS(HIGH) SKIP(ON)
  + TYPE(TEXT)   INTENS(LOW)  SKIP(ON)
  @ TYPE(TEXT)   INTENS(HIGH) COLOR(YELLOW)
  _ TYPE(INPUT)  INTENS(LOW)  CAPS(ON)
  $ TYPE(INPUT)  INTENS(HIGH) CAPS(ON)
  ! TYPE(OUTPUT) INTENS(LOW)  CAPS(OFF) COLOR(PINK)
)BODY EXPAND(!!)
@!-!% PROL SAR Report Selection Panel @!-!
%COMMAND ===>_ZCMD

+
@        Verify or Respecify:
+
+         Report     ===>$report      +
+
+            GEN     ===>$genin+
+
+            SEQ     ===>$seqin+
+
       OUTPUT To     ===>$writedsn
+
+          Enter a report name, GEN, and/or SEQ to@acquire a report.
                                GEN and SEQ are optional.
+
+          Enter a "?" in any field to@go to SAR.
+
           Leave "Report" blank and press ENTER when finished.
 !PROGRESS

)INIT
   &REPORT = &PGMNAME
   &GENIN = '-0'
   &SEQIN = '+0'
   .HELP  = SARPARMH
)REINIT
   REFRESH(*)
)PROC
   IF (&REPORT   EQ '?')
      .RESP = END
   IF (&GENIN    EQ '?')
      .RESP = END
   IF (&SEQIN    EQ '?')
      .RESP = END
   IF (&WRITEDSN EQ '?')
      .RESP = END

   VER (&REPORT,NB)
   VER (&WRITEDSN,NB)
)END
   VER (&GENIN,ENUM)
   VER (&SEQIN,ENUM)
)))PLIB SARPARMH
)ATTR
  % TYPE(TEXT)   INTENS(HIGH)  SKIP(ON)
  + TYPE(TEXT)   INTENS(LOW)   SKIP(ON)
  _ TYPE(INPUT)  INTENS(HIGH)
  ! TYPE(OUTPUT) INTENS(HIGH)  SKIP(ON)
  @ TYPE(OUTPUT) INTENS(LOW)   SKIP(ON)
)BODY EXPAND(!!)
%TUTORIAL !-! PROL SAR Report Selection Panel !-! TUTORIAL
%Next Selection ===>_ZCMD

+
    Enter the report name as known by SAR.  If GEN and SEQ are left as-is, the
    most recent version of the SYSOUT will be retrieved; otherwise enter the
    appropriate generation and sequence for the desired SYSOUT.

    When finished selecting reports/SYSOUTs, leave "Report" blank and press
    ENTER.  If you specified "EDIT", the JCL for acquiring the SYSOUTs will be
    presented to you for last-minute changes.  The JCL is automatically
    submitted for you.
)PROC
)END
)))SLIB JOBCARDS
&JOB1
&JOB2
&JOB3
&JOB4
)))SLIB SARBCH
//* -------------------------------------------------------  */
//GET&S#.    EXEC PGM=SARBCH                RETRIEVE FROM SAR
//SYSUDUMP  DD SYSOUT=*
//SYSPRINT  DD SYSOUT=W
//WRITE     DD DSN=&JCLDSN,
//             DISP=(MOD,CATLG),UNIT=SYSDA,
//             SPACE=(TRK,(10,20)),
//             DCB=(RECFM=VBA,LRECL=137,BLKSIZE=27998)
//SYSIN     DD * (member SARCMDS is inserted here)
)))SLIB SARVIO
//* -------------------------------------------------------  */
//GET&S#.    EXEC PGM=SARBCH                RETRIEVE FROM SAR
//SYSUDUMP  DD SYSOUT=*
//SYSPRINT  DD SYSOUT=W
//WRITE     DD DISP=(NEW,PASS),UNIT=VIO,
//             SPACE=(TRK,(10,20)),
//             DCB=(RECFM=VBA,LRECL=137,BLKSIZE=27998)
//SYSIN     DD * (member SARCMDS is inserted here)
)))SLIB SARANAL
//* -------------------------------------------------------  */
//SARAN&S# EXEC PGM=IKJEFT01,DYNAMNBR=300
//SYSTSPRT  DD SYSOUT=*
//SYSTSIN   DD *
  ISPSTART CMD(SARANAL &TSOPARM)
//SYSEXEC   DD DISP=SHR,DSN=&SYSEXEC
//SARLIST   DD DISP=(OLD,PASS),DSN=*.GET&S#..WRITE
//ISPLOG    DD DISP=NEW,UNIT=VIO,
//             SPACE=(TRK,(1,1)),
//             DCB=(LRECL=121,RECFM=FB,BLKSIZE=0)
//ISPPROF   DD DISP=NEW,UNIT=VIO,SPACE=(CYL,(1,1,15)),
//             DCB=(LRECL=80,RECFM=FB,BLKSIZE=0)
//ISPPLIB   DD DISP=SHR,DSN=ISP.SISPPENU
//ISPMLIB   DD DISP=SHR,DSN=ISP.SISPMENU
//ISPSLIB   DD DISP=SHR,DSN=ISP.SISPSENU
//ISPTLIB   DD DISP=SHR,DSN=ISP.SISPTENU
*/

./ ADD NAME=QTAB
  /* --------------------  rexx procedure  -------------------- */
  /*List of Open ISPF Tables*/
  ver = '1.8'
  /*Name:      QTAB                                            !
  !                                                            !
  ! Function:  Display Open ISPF Tables                        !
  !                                                            !
  ! Syntax:    %QTAB table-name                                !
  !                                                            !
  !            table-name (optional)                           !
  !            - limit the display to that table               !
  !                                                            !
  ! Usage Notes: Used to display open ispf tables              !
  !                                                            !
  ! Author:    Lionel B. Dyck                                  !
  !                                                            !
  ! History:  (most recent on top)                             !
  !            12/07/20 - Fix header alignment                 !
  !                     - If table date/time null set 'N/A'    !
  !            12/04/20 - Fix unknown zcmd processing          !
  !            11/12/20 - Add Find/RFind for selected Table    !
  !            03/07/20 - Enable RFIND                         !
  !            01/29/20 - Expand table name by 1               !
  !            01/08/20 - Add table-name option                !
  !                     - Find now more like locate with *     !
  !            01/06/20 - Add find command                     !
  !            10/21/19 - Add option to Select a table to      !
  !                       view specifics (not pretty but works)!
  !            04/13/18 - Update to fit in 80 bytes            !
  !            02/28/18 - Change tbend to tbclose              !
  !            11/02/16 - Add tutorial panel (short/sweet)     !
  !                     - Change table name color              !
  !            11/01/16 - Creation                             !
  !                                                            !
  * ---------------------------------------------------------- */

  arg table_name

  /* ------------------------------------ *
  ! Define Address and query open tables !
  * ------------------------------------ */
  Address ISPExec
  'Control Errors Return'
  'qtabopen list(tabs)'
  null = ''

  /* --------------> Enable Repeat Find <------------------- *
  ! This approach does not require recursion or creating an !
  ! ISPF table for the applications commands. This approach !
  ! updates the active site command table in memory.        !
  !                                                         !
  ! This does:                                              !
  ! 1. Define the commmand table entry                      !
  ! 2. vget the variable with the prefix for the site ISPF  !
  !    command table.                                       !
  ! 3. define a varable with the command table name         !
  ! 4. Move to the top of the command table                 !
  ! 5. Establish the table search                           !
  ! 6. if the entry is found then add it                    !
  ! 7. prime the variable to null                           !
  * ------------------------------------------------------- */
  zctverb = 'RFIND'
  zctact = "&USRRFIND"
  zctdesc = "User controlled Repeat Find (RFIND)"
  zcttrunc = 0
  'vget (zsctpref)'
  ctab = zsctpref'cmds'
  'tbtop' ctab
  'tbscan' ctab 'arglist(zctdesc) condlist(EQ) Next'
  if rc > 0 then 'tbadd' ctab
  usrrfind = null
  'vput (usrrfind)'

  /* ----------------------------------- *
  ! Build ISPF Table for List of Tables !
  * ----------------------------------- */
  qtab = 'QTAB'random(9999)
  'TBCreate' qtab 'Names(tab cdate ctime udate utime user rowcreat' ,
    'rowcurr rowupd tableupd status1 status2 keysn namesn' ,
    'status3 library virtsize keys names) nowrite'

  /* ------------------------------------ *
  ! Now add the open tables to our table !
  * ------------------------------------ */
  interpret 'count = tabs0'
  do i = 1 to count
    interpret 'tab =  tabs'i
    if table_name /= null
    then if tab /= table_name then iterate
    parse value '' with cdate ctime udate utime user rowcreat ,
      rowcurr rowupd tableupd status1 status2 ,
      status3 library virtsize keys names
    /* ------------------------------------- *
    ! Get number of keys and names in table !
    * ------------------------------------- */
    'tbquery' tab 'keynum(keysn) namenum(namesn)' ,
      'keys(keys) names(names)'
    /* -------------------- *
    ! Get Table Statistics !
    * -------------------- */
    'tbstats' tab 'cdate(cdate) ctime(ctime) udate(udate) utime(utime)' ,
      'user(user) rowcreat(rowcreat) rowcurr(rowcurr)' ,
      'rowupd(rowupd) tableupd(tableupd)' ,
      'status1(status1) status2(status2) status3(status3)' ,
      'library(library) virtsize(virtsize)'
    if strip(library)     = '' then library = 'ISPTLIB'
    /* -------------------------------- *
    ! Clean up the numbers by adding 0 !
    * -------------------------------- */
    if pos('/',cdate) = 0 then cdate = 'N/A'
    if pos(':',ctime) = 0 then ctime = 'N/A'
    if datatype(keysn)    = 'NUM' then keysn = keysn + 0
    if datatype(namesn)   = 'NUM' then namesn = namesn + 0
    if datatype(rowcreat) = 'NUM' then rowcreat = rowcreat + 0
    if datatype(rowcurr)  = 'NUM' then rowcurr = rowcurr + 0
    if datatype(rowupd)   = 'NUM' then rowupd = rowupd + 0
    if datatype(tableupd) = 'NUM' then tableupd = tableupd + 0
    if datatype(virtsize) = 'NUM' then virtsize = virtsize + 0
    /* ------------------------------ *
    ! Now translate the table status !
    * ------------------------------ */
    Select
      When status1 = 1 then
      status1 = 'Table exists in the table input library chain'
      When status1 = 2 then
      status1 = 'Table does not exist in the table input library chain'
      When status1 = 3 then
      status1 = 'Table input library is not allocated'
      Otherwise nop
    end
    Select
      When status2 = 1 then
      status2 = 'Table is not open in this logical screen'
      When status2 = 2 then
      status2 = 'Table is open in NOWRITE mode in this logical screen'
      When status2 = 3 then
      status2 = 'Table is open in WRITE mode in this logical screen'
      When status2 = 4 then
      status2 = 'Table is open in SHARED NOWRITE mode in this logical' ,
        'screen'
      When status2 = 5 then
      status2 = 'Table is open in SHARED WRITE mode in this logical' ,
        'screen'
      Otherwise nop
    end
    Select
      When status3 = 1 then
      status3 = 'Table is available for WRITE mode'
      When status3 = 2 then
      status3 = 'Table is not available for WRITE mode'
      Otherwise nop
    end
    /* --------------------------------------- *
    ! Finally add the table info to our table !
    * --------------------------------------- */
    'tbadd' qtab
  end

  /* ---------------------------------- *
  ! Reposition to the top of the table !
  ! and sort it.                       !
  * ---------------------------------- */
  'TBTop' qtab
  'TBSort' qtab 'Fields(tab)'

  /* ---------------------- *
  ! Load the ISPF Panel(s) !
  * ---------------------- */
  load_info = loadispf()

  /* ------------------------------- *
  ! Now display the table of tables !
  * ------------------------------- */
  top = 0
  do forever
    /* -------------------------------------------- *
    ! Define USRRFIND for Passthru to enable RFIND !
    * -------------------------------------------- */
    usrrfind = 'PASSTHRU'
    'vput (usrrfind)'
    sel = null
    if top > 0 then do
      'tbtop' qtab
      'tbskip' qtab 'number('top')'
    end
    'TBDispl' qtab 'Panel(qtab)'
    trc = rc
    /* ----------------------- *
    ! Reset USRRFIND to blank !
    * ----------------------- */
    usrrfind = ''
    'vput (usrrfind)'
    if trc > 0 then leave

    top = ztdtop
    if zcmd /= null then do
      zcmd = translate(zcmd)
      if word(zcmd,1) = 'RFIND' then do
        'tbtop' qtab
        'tbskip' qtab 'number('top')'
        zcmd = 'F' ftab
      end
      if word(zcmd,1) = 'F' then do
        ftab = word(zcmd,2)
        if pos('*',ftab) > 0 then do
          ftab = strip(translate(ftab,' ','*'))
        end
        wrap = 0
        do forever
          'tbskip' qtab
          'tbget' qtab
          if rc > 0 then do
            if wrap = 1 then leave
            'tbtop' qtab
            wrap = 1
          end
          if pos(ftab,tab) > 0 then do
            'tbquery' qtab 'position(top)'
            if wrap = 1 then do
              zedsmsg = 'Wrapped.'
              zedlmsg = 'Found the requested table.'
            end
            else do
              zedsmsg = 'Found.'
              zedlmsg = 'Found the requested table.'
            end
            'setmsg msg(isrz001)'
            leave
          end
        end
      end
    end
    else if sel /= null then call do_table
  end

  /* ---------------------- *
  ! Done so tbclose and Exit !
  * ---------------------- */
  'tbclose' qtab
  do until length(load_info) = 0
    parse value load_info with dd libd load_info
    "libdef" libd
    address tso "free f("dd")"
  end
  exit

Do_Table:
  vtab = 'VTAB'random(9999)
  'TBSTATS' tab 'STATUS2(OPEN)'
  'TBQUERY' tab 'KEYS(K) NAMES(N) ROWNUM(R)'
  if rc > 0 then do
    zedsmsg = 'Error.'
    zedlmsg = 'Unable to query the table.'
    'setmsg msg(isrz001)'
    return
  end
  if k = null then
  if n = null then do
    zedsmsg = 'Warning.'
    zedlmsg = 'Unable to query the table.'
    'setmsg msg(isrz001)'
    return
  end
  'tbcreate' vtab 'Names(vrow vname vdesc) nowrite'
  parse var k '(' k ')'
  parse var n '(' n ')'
  'TBTOP' tab
  do it = 1 to r
    'TBSKIP' tab
    'TBGET' tab 'ROWID(P)'
    vrow = right(p,6)
    if words(k) > 0 then do j=1 to words(k)
      vname = word(k,j)
      vdesc = value(vname)
      'tbadd' vtab
    end
    if words(n) > 0 then do j=1 to words(n)
      vname = word(n,j)
      vdesc = value(vname)
      'tbadd' vtab
    end
  end
  'tbtop' vtab
  do forever
    usrrfind = 'PASSTHRU'
    'vput (usrrfind)'
    'tbdispl' vtab 'Panel(vtab)'
    tbrc = rc
    usrrfind = ''
    'vput (usrrfind)'
    if tbrc > 0 then leave
    if zcmd = 'RFIND' then do
      'tbtop' vtab
      'tbskip' vtab 'number('top')'
      zcmd = 'F' ftab
    end
    if abbrev('FIND',word(zcmd,1),1) = 1 then do
      wrap = 0
      ftab = subword(zcmd,2)
      do forever
        'tbskip' vtab
        'tbget' vtab
        if rc > 0 then do
          if wrap = 1 then leave
          'tbtop' vtab
          wrap = 1
        end
        if pos(ftab,translate(vname vdesc)) > 0 then do
          'tbquery' vtab 'position(top)'
          if wrap = 1 then do
            zedsmsg = 'Wrapped.'
            zedlmsg = 'Found the requested table.'
          end
          else do
            zedsmsg = 'Found.'
            zedlmsg = 'Found the requested table.'
          end
          'setmsg msg(isrz001)'
          leave
        end
      end
    end
  end
  'tbend' vtab
  return

  /* --------------------  rexx procedure  -------------------- *
  * Name:      LoadISPF                                        *
  *                                                            *
  * Function:  Load ISPF elements that are inline in the       *
  *            REXX source code.                               *
  *                                                            *
  * Syntax:    load_info = loadispf()                          *
  *                                                            *
  *            The inline ISPF resources are limited to        *
  *            ISPF Messages, Panels, and Skeletons,           *
  *                 CLISTs and EXECs are also supported.       *
  *                                                            *
  *            The inline resources must start in column 1     *
  *            and use the following syntax:                   *
  *                                                            *
  *            >START    used to indicate the start of the     *
  *                      inline data                           *
  *                                                            *
  *            >END    - used to indicate the end of the       *
  *                      inline data                           *
  *                                                            *
  *            Each resource begins with a type record:        *
  *            >type name                                      *
  *               where type is CLIST, EXEC, MSG, PANEL, SKEL  *
  *                     name is the name of the element        *
  *                                                            *
  * Sample usage:                                              *
  *          -* rexx *-                                        *
  *          load_info = loadispf()                            *
  *          ... magic code happens here (your code) ...       *
  *          Address ISPEXEC                                   *
  *          do until length(load_info) = 0                    *
  *             parse value load_info with dd libd load_info   *
  *             if left(libd,6) = "ALTLIB" then do             *
  *                if libd = "ALTLIBC" then lib = "CLIST"      *
  *                                    else lib = "EXEC"       *
  *                Address TSO,                                *
  *                  "Altlib Deact Application("lib")"         *
  *                end                                         *
  *             else "libdef" libd                             *
  *             address tso "free f("dd")"                     *
  *             end                                            *
  *          exit                                              *
  *          >Start inline elements                            *
  *          >Panel panel1                                     *
  *          ...                                               *
  *          >Msg msg1                                         *
  *          ...                                               *
  *          >End of inline elements                           *
  *                                                            *
  * Returns:   the list of ddnames allocated for use along     *
  *            with the libdef's performed or altlib           *
  *                                                            *
  *            format is ddname libdef ddname libdef ...       *
  *                   libdef may be altlibc or altlibe         *
  *                   for altlib clist or altlib exec          *
  *                                                            *
  * Notes:     Entire routine must be included with REXX       *
  *            exec - inline with the code.                    *
  *                                                            *
  * Comments:  The entire rexx program is processed from the   *
  *            last record to the first to find the >START     *
  *            record at which point all records from that     *
  *            point on are processed until the >END           *
  *            statement or the end of the program is found.   *
  *                                                            *
  *            It is *strongly* suggested that the inline      *
  *            elements be at the very end of your code so     *
  *            that the search for them is faster.             *
  *                                                            *
  *            Inline ISPTLIB or ISPLLIB were not supported    *
  *            because the values for these would have to be   *
  *            in hex.                                         *
  *                                                            *
  * Author:    Lionel B. Dyck                                  *
  *                                                            *
  * History:                                                   *
  *            05/10/16 - correction for clist and exec        *
  *            04/19/16 - bug correction                       *
  *            06/04/04 - Enhancements for speed               *
  *            08/05/02 - Creation                             *
  *                                                            *
  * ---------------------------------------------------------- *
  * Disclaimer: There is no warranty, either explicit or       *
  * implied with this code. Use it at your own risk as there   *
  * is no recourse from either the author or his employeer.    *
  * ---------------------------------------------------------- */
LoadISPF: Procedure

  parse value "" with null kmsg kpanel kskel first returns ,
    kclist kexec
  /* ------------------------------------------------------- *
  * Find the InLine ISPF Elements and load them into a stem *
  * variable.                                               *
  *                                                         *
  * Elements keyword syntax:                                *
  * >START - start of inline data                           *
  * >CLIST name                                             *
  * >EXEC name                                              *
  * >MSG name                                               *
  * >PANEL name                                             *
  * >SKEL name                                              *
  * >END   - end of all inline data (optional if last)      *
  * ------------------------------------------------------- */
  last_line = sourceline()
  do i = last_line to 1 by -1
    line = sourceline(i)
    if translate(left(line,6)) = ">START " then leave
  end
  rec = 0
  /* --------------------------------------------------- *
  * Flag types of ISPF resources by testing each record *
  * then add each record to the data. stem variable.    *
  * --------------------------------------------------- */
  do j = i+1 to last_line
    line = sourceline(j)
    if translate(left(line,5)) = ">END "   then leave
    if translate(left(line,7)) = ">CLIST " then kclist = 1
    if translate(left(line,6)) = ">EXEC "  then kexec  = 1
    if translate(left(line,5)) = ">MSG "   then kmsg   = 1
    if translate(left(line,7)) = ">PANEL " then kpanel = 1
    if translate(left(line,6)) = ">SKEL "  then kskel  = 1
    rec  = rec + 1
    data.rec = line
  end

  /* ----------------------------------------------------- *
  * Now create the Library and Load the Member(s)         *
  * ----------------------------------------------------- */
  Address ISPExec
  /* ----------------------------- *
  * Assign dynamic random ddnames *
  * ----------------------------- */
  clistdd = "lc"random(999)
  execdd  = "le"random(999)
  msgdd   = "lm"random(999)
  paneldd = "lp"random(999)
  skeldd  = "ls"random(999)

  /* ---------------------------------------- *
  *  LmInit and LmOpen each resource library *
  * ---------------------------------------- */
  if kclist <> null then do
    call alloc_dd clistdd
    "Lminit dataid(clist) ddname("clistdd")"
    "LmOpen dataid("clist") Option(Output)"
    returns = strip(returns clistdd 'ALTLIBC')
  end
  if kexec <> null then do
    call alloc_dd execdd
    "Lminit dataid(exec) ddname("execdd")"
    "LmOpen dataid("exec") Option(Output)"
    returns = strip(returns execdd 'ALTLIBE')
  end
  if kmsg <> null then do
    call alloc_dd msgdd
    "Lminit dataid(msg) ddname("msgdd")"
    "LmOpen dataid("msg") Option(Output)"
    returns = strip(returns msgdd 'ISPMLIB')
  end
  if kpanel <> null then do
    call alloc_dd paneldd
    "Lminit dataid(panel) ddname("paneldd")"
    "LmOpen dataid("panel") Option(Output)"
    returns = strip(returns paneldd 'ISPPLIB')
  end
  if kskel <> null then do
    call alloc_dd skeldd
    "Lminit dataid(skel) ddname("skeldd")"
    "LmOpen dataid("skel") Option(Output)"
    returns = strip(returns skeldd 'ISPSLIB')
  end

  /* ----------------------------------------------- *
  * Process all records in the data. stem variable. *
  * ----------------------------------------------- */
  do i = 1 to rec
    record = data.i
    recordu = translate(record)
    if left(recordu,5) = ">END " then leave
    if left(recordu,7) = ">CLIST " then do
      if first = 1 then call add_it
      type = "Clist"
      first = 1
      parse value record with x name
      iterate
    end
    if left(recordu,6) = ">EXEC " then do
      if first = 1 then call add_it
      type = "Exec"
      first = 1
      parse value record with x name
      iterate
    end
    if left(recordu,5) = ">MSG " then do
      if first = 1 then call add_it
      type = "Msg"
      first = 1
      parse value record with x name
      iterate
    end
    if left(recordu,7) = ">PANEL " then do
      if first = 1 then call add_it
      type = "Panel"
      first = 1
      parse value record with x name
      iterate
    end
    if left(recordu,6) = ">SKEL " then do
      if first = 1 then call add_it
      type = "Skel"
      first = 1
      parse value record with x name
      iterate
    end
    /* --------------------------------------------*
    * Put the record into the appropriate library *
    * based on the record type.                   *
    * ------------------------------------------- */
    Select
      When type = "Clist" then
      "LmPut dataid("clist") MODE(INVAR)" ,
        "DataLoc(record) DataLen(255)"
      When type = "Exec" then
      "LmPut dataid("exec") MODE(INVAR)" ,
        "DataLoc(record) DataLen(255)"
      When type = "Msg" then
      "LmPut dataid("msg") MODE(INVAR)" ,
        "DataLoc(record) DataLen(80)"
      When type = "Panel" then
      "LmPut dataid("panel") MODE(INVAR)" ,
        "DataLoc(record) DataLen(80)"
      When type = "Skel" then
      "LmPut dataid("skel") MODE(INVAR)" ,
        "DataLoc(record) DataLen(80)"
      Otherwise nop
    end
  end
  if type <> null then call add_it
  /* ---------------------------------------------------- *
  * Processing completed - now lmfree the allocation and *
  * Libdef the library.                                  *
  * ---------------------------------------------------- */
  if kclist <> null then do
    Address TSO,
      "Altlib Act Application(Clist) File("clistdd")"
    "LmFree dataid("clist")"
  end
  if kexec <> null then do
    Address TSO,
      "Altlib Act Application(Exec) File("execdd")"
    "LmFree dataid("exec")"
  end
  if kmsg <> null then do
    "LmFree dataid("msg")"
    "Libdef ISPMlib Library ID("msgdd") Stack"
  end
  if kpanel <> null then do
    "Libdef ISPPlib Library ID("paneldd") Stack"
    "LmFree dataid("panel")"
  end
  if kskel <> null then do
    "Libdef ISPSlib Library ID("skeldd") Stack"
    "LmFree dataid("skel")"
  end
  return returns

  /* --------------------------- *
  * Add the Member using LmmAdd *
  * based upon type of resource *
  * --------------------------- */
Add_It:
  if type = "Clist" then
  "LmmAdd dataid("clist") Member("name")"
  if type = "Exec" then
  "LmmAdd dataid("exec") Member("name")"
  if type = "Msg" then
  "LmmAdd dataid("msg") Member("name")"
  if type = "Panel" then
  "LmmAdd dataid("panel") Member("name")"
  if type = "Skel" then
  "LmmAdd dataid("skel") Member("name")"
  type = null
  return

  /* ------------------------------ *
  * ALlocate the temp ispf library *
  * ------------------------------ */
Alloc_DD:
  arg dd
  Address TSO
  if pos(left(dd,2),"lc le") > 0 then
  "Alloc f("dd") unit(sysda) spa(5,5) dir(1)",
    "recfm(v b) lrecl(255) blksize(32760)"
  else
  "Alloc f("dd") unit(sysda) spa(5,5) dir(1)",
    "recfm(f b) lrecl(80) blksize(23440)"
  return

  /* ------------------------------------------------ *
  ! Here is the ISPF Panel that will be dynamnically !
  ! loaded for use.                                  !
  * ------------------------------------------------ */
/*
>START
>Panel vtab
)Attr
ß type( input) intens(high) caps(on ) just(left ) hilite(uscore)
£ type(output) intens(low ) caps(off) just(left) color(turq)
‡ type(output) intens(low ) caps(off) just(left)
^ type(output) intens(low ) caps(off) just(right)
$ type(  text) intens(high) caps(off) hilite(reverse)
)Body Expand(//)
%-/-/-$List of Table values: ‡tab     %-/-/-
%Command ===>_zcmd                                 / /%Scroll ===>_amt +
+
+Row    Variable  Description
)Model
‡z     ‡z   e    ‡z
)Init
&amt = CSR
.zvars = '(vrow vname vdesc)'
)Proc
)end
>PANEL QTAB
)Attr Default(%+_)
ß type( input) intens(high) caps(on ) just(left ) hilite(uscore)
£ type(output) intens(low ) caps(off) just(left) color(turq)
‡ type(output) intens(low ) caps(off) just(left)
^ type(output) intens(low ) caps(off) just(right)
$ type(  text) intens(high) caps(off) hilite(reverse)
)Body  Expand(//)
%-/-/-$List of Open ISPF Tables£ver%-/-/-
%Command ===>_zcmd                                 / /%Scroll ===>_amt +
%
%S Table         Keys    Names     Cdate     Ctime       UDate       UTime
%Userid       Rows        C-Rows   Rows-Upd  TableUpd
%Library   Storage
%Status (1-2-3)
-----------------------------------------------------------------------------
)Model
ßz£z       +^z       +^z      +  +‡z        ‡z          ‡z          ‡z
‡z          ^z       +^z      + ^z         +  ^z     +
‡z          ^z       +
‡z
‡z
‡z
-----------------------------------------------------------------------------
)Init
.help = QTABH
.zvars =  '(sel tab keysn namesn cdate ctime udate utime user +
rowcurr rowcreat +
rowupd tableupd library virtsize status1 status2 status3) '
&amt = CSR
)Reinit
)Proc
)End
>PANEL QTABH
)attr default(%+_)
$ type(  text) intens(high) caps(off) hilite(reverse)
)Body Expand(ÁÁ)
%-Á-Á-$List Active ISPF Tables%-Á-Á-
ommand ===>_ZCMD                                                             +
%
+  All active ISPF Tables are displayed in a multi-row table with the
+  following information:
+
+       Table Name
+       Keys count
+       Names count
+       Create Date and Time
+       Update Date and Time
+       Last Userid to Update
+       Row count current, at table create and updated
+       Number of times the Table has been updated
+       Library (DDName)
+       Table Status info (3)
+
+ Select a table to display details, including individual row/variables.
+
)INIT
.cursor = &zcmd
)PROC
)END
>END
*/

./ ADD NAME=READWRIT
/* REXX */
/* COPYING THE DATA FROM ONE FILE TO ANOTHER */
SAY "ENTER THE HIGHLEVEL QUALIFIER"
PULL HLQ
INFILE = HLQ||".SAMPLE.REXX"
OUTFILE = HLQ||".SAMPLE.OUTPUT"
ADDRESS TSO
"ALLOC F(INDD) DA('"||INFILE||"') SHR"
IF SYSDSN("'"OUTFILE"'") = 'OK' THEN
    DO
      "ALLOC F("OUTDD") DA('"OUTFILE"') SHR REUSE"
    END
ELSE
    DO
      "ALLOC F("OUTDD") DA("||"'"||OUTFILE||"'",
      ||") NEW SPACE (100,200) TRACK LRECL(80) RECFM(F) ",
      ||" BLKSIZE(0)"
    END
"EXECIO * DISKR INDD(FINIS STEM INREC."
"EXECIO * DISKW OUTDD(FINIS STEM INREC."
"FREE F(INDD)"
"FREE F(OUTDD)"
EXIT 0

./ ADD NAME=SETRRCVT
/*REXX*/
/*********************************************************************/
/* Rexx to pull out all useful SETROPTS info from storage.           */
/* No SPECIAL or AUDITOR needed!                                     */
/*                                                                   */
/* Author:  Jim Taylor                                               */
/*            https://github.com/jaytay79/zos                        */
/*                                                                   */
/* Sources: Mark Zelden's IPLINFO Rexx:                              */
/*            http://www.mzelden.com/mvsfiles/iplinfo.txt            */
/*          Mark Wilson's "RACF for Systems Programmers" course:     */
/*            http://www.rsm.co.uk                                   */
/*          z/OS Security Server RACF Data Areas manual:             */
/*            http://publibz.boulder.ibm.com/epubs/pdf/ich2c400.pdf  */
/*          Bruce Wells' XSETRPWD                                    */
/*            ftp://public.dhe.ibm.com/s390/zos/racf/irrxutil/       */
/*********************************************************************/
numeric digits 20
/* Get info from storage, most of this section is a straight lift    */
/* from IPLINFO!                                                     */
CVT      = C2d(Storage(10,4))                /* point to CVT         */
CVTVERID = Storage(D2x(CVT - 24),16)         /* "user" software vers.*/
PRODNAME = Storage(D2x(CVT - 40),7)          /* point to mvs version */
CVTRAC   = C2d(Storage(D2x(CVT + 992),4))    /* point to RACF CVT    */
RCVT     = CVTRAC                            /* use RCVT name        */
RCVx     = C2D(STORAGE(D2X(CVT+X2D('3E0')),4)) /* ugly mess for bits */
RCVTID   = Storage(D2x(RCVT),4)              /* point to RCVTID      */
If RCVTID = 'RCVT' then SECNAM = 'RACF'      /* RCVT is RACF         */
RACFVRM  = Storage(D2x(RCVT + 616),4)        /* RACF Ver/Rel/Mod     */
RACFVER  = Substr(RACFVRM,1,1)               /* RACF Version         */
RACFREL  = Substr(RACFVRM,2,2)               /* RACF Release         */
If Bitand(CVTOSLV2,'01'x) <> '01'x then ,    /* below OS/390 R10     */
  RACFREL  = Format(RACFREL)                 /* Remove leading 0     */
RACFMOD  = Substr(RACFVRM,4,1)  !            /* RACF MOD level       */
RACFLEV  = RACFVER !! '.' !! RACFREL !! '.' !! RACFMOD
RCVTDSN = Strip(Storage(D2x(RCVT + 56),44))  /* RACF prim dsn        */

  Say   'The security software is' Word(PRODNAME,1) ,
        'Security Server (RACF).' ,
        'The FMID is HRF' !! RACFVRM !! '.'
  say ' '
  RCVTDSDT  = C2d(Storage(D2x(RCVT + 224),4))  /* point to RACFDSDT  */
  DSDTNUM   = C2d(Storage(D2x(RCVTDSDT+4),4))  /* num RACF dsns      */
  DSDTPRIM  = Storage(D2x(RCVTDSDT+177),44)    /* point to prim ds   */
  DSDTPRIM  = Strip(DSDTPRIM,'T')              /* del trail blanks   */
  DSDTBACK  = Storage(D2x(RCVTDSDT+353),44)    /* point to back ds   */
  DSDTBACK  = Strip(DSDTBACK,'T')              /* del trail blanks   */
  If DSDTNUM = 1 then do
     say '  The RACF primary data set is' DSDTPRIM'.'
     say '  The RACF backup  data set is' DSDTBACK'.'
   End
   Else do
     say '  RACF is using a split database. There are' DSDTNUM ,
           'pairs of RACF data sets:'
     RDTOFF = 0                            /* init cur offset to 0 */
     DSDTENTY_SIZE = 352                   /* dsdtenty size        */
     Do RDSNS = 1 to DSDTNUM
       DSDTPRIM  = Storage(D2x(RCVTDSDT+177+RDTOFF),44) /* prim dsn */
       DSDTPRIM  = Strip(DSDTPRIM,'T')                  /* del blnks*/
       DSDTBACK  = Storage(D2x(RCVTDSDT+353+RDTOFF),44) /* bkup dsn */
       DSDTBACK  = Strip(DSDTBACK,'T')                  /* del blnks*/
       RDTOFF = RDTOFF + DSDTENTY_SIZE            /* next tbl entry */
       say '    Primary #'RDSNS' - ' DSDTPRIM
       say '    Backup  #'RDSNS' - ' DSDTBACK
     End  /* do RDSNS = 1 to DSDTNUM */
   End
  RCVTUADS = Strip(Storage(D2x(RCVT + 100),44)) /* UADS dsn          */
  say  '  The UADS dataset is' RCVTUADS'.'
say ""
/* Below section pulls in bit string values for various settings     */
RCVTPRO  = RCVx + 393                          /* point to RCVTPRO   */
RCVTEROP = RCVx + 154                          /* point to RCVTEROP  */
RCVTAUOP = RCVx + 151                          /* point to RCVTAUOP  */
RCVTPROX = X2B(C2X(STORAGE(D2X(RCVTPRO),4)))   /* get the bits       */
RCVTEROX = X2B(C2X(STORAGE(D2X(RCVTEROP),4)))  /* get the bits       */
RCVTAUOX = X2B(C2X(STORAGE(D2X(RCVTAUOP),8)))  /* get the bits       */
if substr(RCVTEROX,3,1) = 0 then
 say "RACF Command violations are logged"
 else say "RACF Command violations are not logged"
if SUBSTR(RCVTPROX,1,1) = 1 then do
  say "PROTECT-ALL is on"
  if SUBSTR(RCVTPROX,2,1) = 1 then say " PROTECT-ALL WARNING mode"
    else say " PROTECT-ALL FAILURE mode"
  end
 else say "PROTECT-ALL is off"
if SUBSTR(RCVTPROX,3,1) = 1 then do
  say "ERASE-ON-SCRATCH is active, current options:"
  if SUBSTR(RCVTPROX,4,1) = 1 then say " ERASE-ON-SCRATCH BY SECLEVEL is on"
    else say " ERASE-ON-SCRATCH BY SECLEVEL is off"
  if SUBSTR(RCVTPROX,5,1) = 1 then say " ERASE-ON-SCRATCH for all",
     "datasets is on"
    else say " ERASE-ON-SCRATCH for all datasets is off"
 end
 else say "ERASE-ON-SCRATCH is off"
if SUBSTR(RCVTAUOX,2,1) = 1 then say "GROUP changes are audited"
 else say "GROUP changes are not audited"
if SUBSTR(RCVTAUOX,3,1) = 1 then say "USER changes are audited"
 else say "USER changes are not audited"
if SUBSTR(RCVTAUOX,4,1) = 1 then say "DATASET changes are audited"
 else say "DATASET changes are not audited"
if SUBSTR(RCVTAUOX,5,1) = 1 then say "DASDVOL changes are audited"
 else say "DASDVOL changes are not audited"
if SUBSTR(RCVTAUOX,6,1) = 1 then say "TAPEVOL changes are audited"
 else say "TAPEVOL changes are not audited"
if SUBSTR(RCVTAUOX,7,1) = 1 then say "TERMINAL changes are audited"
 else say "TERMINAL changes are not audited"
if substr(RCVTEROX,4,1) = 0 then say "SPECIAL users are audited"
 else say "SPECIAL users are not audited"
if SUBSTR(RCVTAUOX,8,1) = 1 then say "OPERATIONS users are audited"
 else say "OPERATIONS users are NOT audited"
say ""
/* Get the RVARY password info */
RCVTSWPW = Strip(Storage(D2x(RCVT + 440),8))  /* rvary switch pw     */
if c2x(RCVTSWPW) = "0000000000000000" then
 say "RVARY SWITCH password is set to default value of YES"
 else say "RVARY SWITCH password DES hash:" c2x(RCVTSWPW)
RCVTINPW = Strip(Storage(D2x(RCVT + 448),8))  /* rvary status pw     */
if c2x(RCVTINPW) = "0000000000000000" then
 say "RVARY STATUS password is set to default value of YES"
 else say "RVARY STATUS password DES hash:" c2x(RCVTINPW)
say ""
/* Get password and other related settings */
RCVTPINV  = C2d(Storage(D2x(RCVT + 155),1))  /* point to RCVTPINV   */
say "Global password change interval:" RCVTPINV "days"
RCVTPMIN  = C2d(Storage(D2x(RCVT + 634),1))  /* point to RCVTPMIN   */
say "Minimum password change interval:" RCVTPMIN "days"
/* Note that if a rule is set to 8 "*"s then it defaults to "0"s    */
/* which means the rule appears blank.                              */
/* Workaround for this is to look at the max length of each rule to */
/* see if it is truly a blank rule line or not!                     */
RCVTSNT1 = Strip(Storage(D2x(RCVT + 246),8))  /* PW syntax rule 1    */
RCVTSNT1S = Strip(Storage(D2x(RCVT + 244),1)) /* rule 1 min          */
RCVTSNT1E = Strip(Storage(D2x(RCVT + 245),1)) /* rule 1 max          */
 RCVTSNT1 = pwcheck(RCVTSNT1,RCVTSNT1E)       /* check rule 1        */
RCVTSNT2 = Strip(Storage(D2x(RCVT + 256),8))  /* PW syntax rule 2    */
RCVTSNT2S = Strip(Storage(D2x(RCVT + 254),1)) /* rule 2 min          */
RCVTSNT2E = Strip(Storage(D2x(RCVT + 255),1)) /* rule 2 max          */
 RCVTSNT2 = pwcheck(RCVTSNT2,RCVTSNT2E)       /* check rule 2        */
RCVTSNT3 = Strip(Storage(D2x(RCVT + 266),8))  /* PW syntax rule 3    */
RCVTSNT3S = Strip(Storage(D2x(RCVT + 264),1)) /* rule 3 min          */
RCVTSNT3E = Strip(Storage(D2x(RCVT + 265),1)) /* rule 3 max          */
 RCVTSNT3 = pwcheck(RCVTSNT3,RCVTSNT3E)       /* check rule 3        */
RCVTSNT4 = Strip(Storage(D2x(RCVT + 276),8))  /* PW syntax rule 4    */
RCVTSNT4S = Strip(Storage(D2x(RCVT + 274),1)) /* rule 4 min          */
RCVTSNT4E = Strip(Storage(D2x(RCVT + 275),1)) /* rule 4 max          */
 RCVTSNT4 = pwcheck(RCVTSNT4,RCVTSNT4E)       /* check rule 4        */
RCVTSNT5 = Strip(Storage(D2x(RCVT + 286),8))  /* PW syntax rule 5    */
RCVTSNT5S = Strip(Storage(D2x(RCVT + 284),1)) /* rule 5 min          */
RCVTSNT5E = Strip(Storage(D2x(RCVT + 285),1)) /* rule 5 max          */
 RCVTSNT5 = pwcheck(RCVTSNT5,RCVTSNT5E)       /* check rule 5        */
RCVTSNT6 = Strip(Storage(D2x(RCVT + 296),8))  /* PW syntax rule 6    */
RCVTSNT6S = Strip(Storage(D2x(RCVT + 294),1)) /* rule 6 min          */
RCVTSNT6E = Strip(Storage(D2x(RCVT + 295),1)) /* rule 6 max          */
 RCVTSNT6 = pwcheck(RCVTSNT6,RCVTSNT6E)       /* check rule 6        */
RCVTSNT7 = Strip(Storage(D2x(RCVT + 306),8))  /* PW syntax rule 7    */
RCVTSNT7S = Strip(Storage(D2x(RCVT + 304),1)) /* rule 7 min          */
RCVTSNT7E = Strip(Storage(D2x(RCVT + 305),1)) /* rule 7 max          */
 RCVTSNT7 = pwcheck(RCVTSNT7,RCVTSNT7E)       /* check rule 7        */
RCVTSNT8 = Strip(Storage(D2x(RCVT + 316),8))  /* PW syntax rule 8    */
RCVTSNT8S = Strip(Storage(D2x(RCVT + 314),1)) /* rule 8 min          */
RCVTSNT8E = Strip(Storage(D2x(RCVT + 315),1)) /* rule 8 max          */
 RCVTSNT8 = pwcheck(RCVTSNT8,RCVTSNT8E)       /* check rule 8        */
say "Password syntax rules:"
if c2x(RCVTSNT1E) <> "00" then do
  say " Rule 1:" RCVTSNT1
  Say "    Min length:" c2x(RCVTSNT1S)
  Say "    Max length:" c2x(RCVTSNT1E)
  end
if c2x(RCVTSNT2E) <> "00" then do
  say " Rule 2:" RCVTSNT2
  Say "    Min length:" c2x(RCVTSNT2S)
  Say "    Max length:" c2x(RCVTSNT2E)
  end
if c2x(RCVTSNT3E) <> "00" then do
  say " Rule 3:" RCVTSNT3
  Say "    Min length:" c2x(RCVTSNT3S)
  Say "    Max length:" c2x(RCVTSNT3E)
  end
if c2x(RCVTSNT4E) <> "00" then do
  say " Rule 4:" RCVTSNT4
  Say "    Min length:" c2x(RCVTSNT4S)
  Say "    Max length:" c2x(RCVTSNT4E)
  end
if c2x(RCVTSNT5E) <> "00" then do
  say " Rule 5:" RCVTSNT5
  Say "    Min length:" c2x(RCVTSNT5S)
  Say "    Max length:" c2x(RCVTSNT5E)
  end
if c2x(RCVTSNT6E) <> "00" then do
  say " Rule 6:" RCVTSNT6
  Say "    Min length:" c2x(RCVTSNT6S)
  Say "    Max length:" c2x(RCVTSNT6E)
  end
if c2x(RCVTSNT7E) <> "00" then do
  say " Rule 7:" RCVTSNT7
  Say "    Min length:" c2x(RCVTSNT7S)
  Say "    Max length:" c2x(RCVTSNT7E)
  end
if c2x(RCVTSNT8E) <> "00" then do
  say " Rule 8:" RCVTSNT8
  Say "    Min length:" c2x(RCVTSNT8S)
  Say "    Max length:" c2x(RCVTSNT8E)
  end
if c2x(RCVTSNT1E) = "00" & c2x(RCVTSNT2E) = "00",
   & c2x(RCVTSNT3E) = "00" & c2x(RCVTSNT4E) = "00",
   & c2x(RCVTSNT5E) = "00" & c2x(RCVTSNT6E) = "00",
   & c2x(RCVTSNT7E) = "00" & c2x(RCVTSNT8E) = "00",
   then  say " ** No password rules defined! **"
else say " LEGEND:",
    "A-ALPHA C-CONSONANT L-ALPHANUM N-NUMERIC V-VOWEL W-NOVOWEL" ,
    "*-ANYTHING  c-MIXED CONSONANT m-MIXED NUMERIC v-MIXED VOWEL",
    "$-NATIONAL s-SPECIAL"
RCVTSLEN = C2D(Strip(Storage(D2x(RCVT + 244),1))) /* min possible    */
if RCVTSLEN = 0 then RCVTSLEN = 1                 /* password length */
Say "Minimum possible password length:" RCVTSLEN
RCVTELEN = C2D(Strip(Storage(D2x(RCVT + 245),1))) /* max possible    */
if RCVTELEN = 0 then RCVTELEN = 8                 /* password length */
Say "Maximum possible password length:" RCVTELEN
RCVTRVOK = C2D(Strip(Storage(D2x(RCVT + 241),1))) /* logon attempts  */
if RCVTRVOK = 0 then RCVTRVOK = "unlimited"
Say "Invalid logon attempts allowed:" RCVTRVOK
RCVTINAC = C2D(Strip(Storage(D2x(RCVT + 243),1))) /* inactive intvl  */
if RCVTINAC = "0" then
 say "No inactive interval"
 else say "Inactive interval:" RCVTINAC "days"
RCVTHIST = C2D(Strip(Storage(D2x(RCVT + 240),1))) /* pw generations  */
if RCVTHIST = "0" then
 say "No password history in use"
 else say "Password history:" RCVTHIST "generations"
/* Misc password related bit string flags */
RCVTFLG3 = RCVx + 633                          /* point to RCVTFLG3  */
RCVTFLGX = X2B(C2X(STORAGE(D2X(RCVTFLG3),8)))  /* get the bits       */
if SUBSTR(RCVTFLGX,2,1) = 1 then say "Mixed case passwords enabled"
 else say "Mixed case passwords disabled"
if SUBSTR(RCVTFLGX,5,1) = 1 then
 say "Special characters are allowed in passwords"
 else say "Special characters are not allowed in passwords"
if SUBSTR(RCVTFLGX,6,1) = 1 then
 say "Enhanced password options under OA43999 are available"
 else say "Enhanced password options under OA43999 are not available"
if SUBSTR(RCVTFLGX,7,1) = 1 then say "Multi factor auth is available"
 else say "Multi factor auth is not available"
RCVTFLG4 = RCVx + 640                          /* point to RCVTFLG4  */
RCVTFLGY = X2B(C2X(STORAGE(D2X(RCVTFLG4),8)))  /* get the bits       */
if SUBSTR(RCVTFLGY,2,1) = 1 then say " MFA3 is available (OA50930)"
 else say " MFA3 is not available (OA50930)"
/* Checks for new password encryption */
RCVTPALG = C2D(Strip(Storage(D2x(RCVT + 635),1))) /* pw encryption   */
if RCVTPALG = "1" then say "KDFAES encryption is active"
 else say "Legacy encryption is active"
/* ----------------------------------------------------------------- */
/* See if new password exit is active.                               */
/* ----------------------------------------------------------------- */
pwx01hex = Storage(D2x(RCVT + 236),4)
RCVTPWDX = C2d(BITAND(pwx01hex,'7FFFFFFF'x))
If RCVTPWDX = 0 Then
  YesOrNo = 'is NOT'
else
  YesOrNo = 'IS'
say "There" YesOrNo "a new password exit (ICHPWX01) installed."
RCVTRIX = c2d(Storage(D2x(RCVT + 24),4)) /* ICHRIX? */
 If RCVTRIX <> 0 Then
  say "There IS a VERIFY post-processing exit (ICHRIX01) installed."
 else
  say "There is NOT a VERIFY post-processing exit (ICHRIX01) installed."
RCVTRCX = c2d(Storage(D2x(RCVT + 28),4)) /* ICHRCX? */
 If RCVTRCX <> 0 Then
   say "There IS an AUTH post-processing exit (ICHRCX01) installed."
 else
   say "There is NOT an AUTH post-processing exit (ICHRCX01) installed."
RCVTRDX = c2d(Storage(D2x(RCVT + 32),4)) /* ICHRDX? */
 If RCVTRDX <> 0 Then
   say "There IS a DEFINE post-processing exit (ICHRDX02) installed."
 else
   say "There is NOT a DEFINE post-processing exit (ICHRDX02) installed."
RCVTNCX = c2d(Storage(D2x(RCVT + 180),4)) /* ICHNCX? */
 If RCVTNCX <> 0 Then
   say "There IS a naming convention exit (ICHNCV00) installed."
 else
   say "There is NOT a naming convention exit (ICHNCV00) installed."
RCVTDESX = c2d(Storage(D2x(RCVT + 416),4)) /* ICHDEX? */
 If RCVTDESX <> 0 Then
   say "There IS a password encryption exit (ICHDEX01) installed."
 else
   say "There is NOT a password encryption exit (ICHDEX01) installed."
exit

/* pwcheck function to check for an empty rule but with a max length */
pwcheck: parse arg pw length
if c2x(pw) = "0000000000000000" & c2x(length) <> "00" then
 return "********"
 else return pw

./ ADD NAME=SPACERPT
/* REXX    SPACERPT   produce a report showing the allocation status of
                      classes of libraries.

                      The caller of SPACERPT will be expected to provide
                      either a single catalog level as the first parm,
                      or a dataset which specifies the catalog level(s)
                      to be examined, or both.  SPACERPT will obtain the
                      list of dataset names and the allocation data for
                      each, formatting them as appropriate.

           Written by Frank Clarke, Oldsmar FL

     Impact Analysis
.    SYSPROC   TRAPOUT

     Modification History
     ........ ... ........
                  ....

*/ arg argline
address TSO                            /* REXXSKEL ver.19991109      */
arg parms "((" opts

signal on syntax
signal on novalue

call TOOLKIT_INIT                      /* conventional start-up     -*/
rc     = trace(tv)
info   = parms                         /* to enable parsing          */

if parms  = "" then call HELP          /* ...and don't come back     */

call A_INIT                            /*                           -*/
call B_RUN_LIST                        /*                           -*/
call E_WRITE                           /*                           -*/

call ZB_SAVELOG                        /*                           -*/
if ^sw.nested then call DUMP_QUEUE     /*                           -*/
exit                                   /*@ SPACERPT                  */
/*
.  ----------------------------------------------------------------- */
A_INIT:                                /*@                           */
   if branch then call BRANCH
   address TSO
                                       /*                            */
   call A0_SETUP_LOG                   /*                           -*/

   call AA_KEYWDS                      /*                           -*/

   call AB_LOAD_LEVELS                 /*                           -*/

   msg.      = "??"
   msg.0000  = "OK"
   msg.0005  = "NC"
   msg.0009  = "MI"

return                                 /*@ A_INIT                    */
/*
.  ----------------------------------------------------------------- */
A0_SETUP_LOG:                          /*@                           */
   if branch then call BRANCH
   address TSO

   parse value "0" with,
               log£    log.
   parse value Date("S")  Time("S")  Time("N")  with,
               yyyymmdd   sssss      hhmmss  .
   parse var yyyymmdd  4 yrdigit 5 mm 7 dd          /* 9 12 14 maybe */
   if Pos(yrdigit,"13579") > 0 then mm = mm + 12       /* mm=24      */
   logtag = Substr("ABCDEFGHIJKLMNOPQRSTUVWX",mm,1)    /* logtag=X   */
   subid  = logtag""dd""Right(sssss,5,0)               /* X1423722 ? */
   vb4k.0    = "NEW CATALOG UNIT(SYSDA) SPACE(1 5) TRACKS",
               "RECFM(V B) LRECL(4096) BLKSIZE(0)"
   vb4k.1    = "SHR"                   /* if it already exists...    */
   logdsn = "$LOG."exec_name"."subid".LIST"

   call ZL_LOGMSG("Log started by" Userid()  yyyymmdd  hhmmss)
   call ZL_LOGMSG("Arg:" argline)

return                                 /*@ A0_SETUP_LOG              */
/*
.  ----------------------------------------------------------------- */
AA_KEYWDS:                             /*@                           */
   if branch then call BRANCH
   address TSO

   outdsn    = KEYWD("OUTPUT")
   dsni      = KEYWD("LEVELS")
   parse var info single_lvl           /* if LEVELS not specified    */
   if Words(dsni single_lvl) < 1 then,
      helpmsg = "Either OUTPUT or a catalog level must be specified. ",
                "Both MAY be specified. "

   if outdsn = "" then,
      helpmsg = helpmsg "OUTPUT is a required keyword."

   if helpmsg <> "" then,
      call HELP                        /* ...and don't come back    -*/

return                                 /*@ AA_KEYWDS                 */
/*
   Read <dsni> to populate <info>.
.  ----------------------------------------------------------------- */
AB_LOAD_LEVELS:                        /*@                           */
   if branch then call BRANCH
   address TSO

   info = single_lvl

   if dsni <> "" then do
      "ALLOC FI($LVL) DA("dsni") SHR REU"
      if rc > 4 then do
         helpmsg = dsni "could not be allocated. Make sure this dataset",
                   "exists and is correctly populated."
         call HELP                     /* ...and don't come back    -*/
         end                           /* ALLOC failure              */
      end                              /* dsni                       */

   "NEWSTACK"
   if dsni <> "" then do
      "EXECIO * DISKR $LVL (FINIS"     /* load the queue             */
      "FREE FI($LVL)"
      end                              /* dsni                       */

   do queued()                         /* every line                 */
      pull line
      if Left(line,1) = "*" then iterate    /* ignore comments       */
      info = Space(info line,1)
   end                                 /* queued()                   */

   "DELSTACK"
   call ZL_LOGMSG("Consolidated levels:" info)

return                                 /*@ AB_LOAD_LEVELS            */
/*
   <info> is populated with datasetnames.  Use LISTDSI on each
   datasetname to acquire allocation data.
.  ----------------------------------------------------------------- */
B_RUN_LIST:                            /*@                           */
   if branch then call BRANCH
   address TSO

   call BH_HEADER                      /* initial headers           -*/

   do bx = 1 to Words(info)
      thislvl = Word(info ,bx)
      rc = Outtrap("lc.")
      "LISTC LVL("thislvl")"
      rc = Outtrap("off")

      do bz = 1 to lc.0
         parse var lc.bz lit . dsn .
         if lit ^= "NONVSAM" then iterate
         call BA_LISTDSI
      end                              /* bz                         */
   end                                 /* bx                         */

return                                 /*@ B_RUN_LIST                */
/*
   Format and print allocation data for each dataset.
.  ----------------------------------------------------------------- */
BA_LISTDSI:                            /*@                           */
   if branch then call BRANCH
   address TSO

   ldrc   = Listdsi("'"dsn"'  directory   norecall")    /* sets:     */
   dsstat = msg.sysreason              /*   SYSREASON                */

   if lines//6 = 0 then do; queue " "; lines = lines + 1; end
   if dsstat  = "MI" then do
      queue " "Left(dsn,47) "Migrated"
      lines = lines + 1
      end
   if dsstat ^= "OK" then return

   if sysadirblk = "NO_LIM" then do
      sysdsorg   = "POE"
      sysused    = "---"
      sysadirblk = "N/L"
      sysudirblk = "---"
      end                              /* NO_LIM                     */
   queue " "Left(dsn,47) Left(sysdsorg,3),
                         Left(sysrecfm,3),
                         Right(syslrecl,5),
                         Right(sysblksize,5),
                         Right(sysalloc,5),
                         Right(sysused,5),
                         Right(sysprimary,5),
                         Right(sysseconds,5),
                         Right(sysextents,2),
                         Right(sysadirblk,4),
                         Right(sysudirblk,4),
                         Right(sysmembers,5),
                         sysunits
   lines = lines + 1
   if lines > 53 then call BH_HEADER               /*               -*/

return                                 /*@ BA_LISTDSI                */
/*
   Write a header-line for each page.
.  ----------------------------------------------------------------- */
BH_HEADER: Procedure expose,           /*@                           */
   (tk_globalvars) lines
   if branch then call BRANCH
   address TSO

   lines = 0

   dsn         = "Dataset Name"
   sysdsorg    = "Org"
   sysrecfm    = "Len"
   syslrecl    = "Lrecl"
   sysblksize  = "Blksz"
   sysalloc    = "Alloc"
   sysused     = "Used "
   sysprimary  = "Prim"
   sysseconds  = "2ry"
   sysextents  = "X"
   sysadirblk  = "D/A"
   sysudirblk  = "D/U"
   sysmembers  = "Mbrs "
   sysunits    = "Units"

   queue "1"Left(dsn,47) Left(sysdsorg,3),
                         Left(sysrecfm,3),
                         Right(syslrecl,5),
                         Right(sysblksize,5),
                         Right(sysalloc,5),
                         Right(sysused,5),
                         Right(sysprimary,5),
                         Right(sysseconds,5),
                         Right(sysextents,2),
                         Right(sysadirblk,4),
                         Right(sysudirblk,4),
                         Right(sysmembers,5),
                         sysunits Date("S") Time()

return                                 /*@ BH_HEADER                 */
/*
   Dump the queue.
.  ----------------------------------------------------------------- */
E_WRITE:                               /*@                           */
   if branch then call BRANCH
   address TSO

   call ZL_LOGMSG(queued() "lines written to" outdsn)

   if outdsn = "VIO" then,
      "ALLOC FI($TMP) NEW UNIT(VIO) SPACE(5 15) TRACKS",
               "RECFM(V B A) LRECL(255) BLKSIZE(0)"
   else do
      alloc.0 = "NEW CATALOG UNIT(SYSDA) SPACE(5 15) TRACKS",
                  "RECFM(V B A) LRECL(255) BLKSIZE(0)"
      alloc.1 = "SHR"                  /* if it already exists...    */
      tempstat = Sysdsn(outdsn) = "OK" /* 1=exists, 0=missing        */
      "ALLOC FI($TMP) DA("outdsn") REU" alloc.tempstat
      end
   "EXECIO" queued() "DISKW $TMP (FINIS"
   call EB_BROWSE_OUTPUT               /*                           -*/
   "FREE  FI($TMP)"

return                                 /*@ E_WRITE                   */
/*
.  ----------------------------------------------------------------- */
EB_BROWSE_OUTPUT:                      /*@                           */
   if branch then call BRANCH
   address ISPEXEC

   if sw.batch then return
   if ^sw.inispf then return

   "CONTROL ERRORS RETURN"             /* I'll handle my own         */
   "LMINIT  DATAID(DAID) DDNAME($TMP)"
   "BROWSE  DATAID("daid")"
   "LMFREE  DATAID("daid")"

return                                 /*@ EB_BROWSE_OUTPUT          */
/*
.  ----------------------------------------------------------------- */
LOCAL_PREINIT:                         /*@ customize opts            */
   address TSO


return                                 /*@ LOCAL_PREINIT             */
/*   subroutines below LOCAL_PREINIT are not selected by SHOWFLOW    */
/*
.  ----------------------------------------------------------------- */
ZB_SAVELOG:                            /*@                           */
   if branch then call BRANCH
   address TSO

   if Symbol("LOG£") = "LIT" then return          /* not yet set     */

   "ALLOC FI($LOG) DA("logdsn") REU" vb4k.0
   "EXECIO" log£ "DISKW $LOG (STEM LOG. FINIS"
   "FREE  FI($LOG)"

return                                 /*@ ZB_SAVELOG                */
/*
.  ----------------------------------------------------------------- */
ZL_LOGMSG: Procedure expose,           /*@                           */
   (tk_globalvars)  log. log£
   address TSO

   parse arg msgtext
   parse value  log£+1  msgtext     with,
                zz      log.zz    1  log£   .

   if monitor then say,
      msgtext

return                                 /*@ ZL_LOGMSG                 */
/*
.  ----------------------------------------------------------------- */
HELP:                                  /*@                           */
address TSO;"CLEAR"
if helpmsg <> "" then do ; say helpmsg; say ""; end
ex_nam = Left(exec_name,8)             /* predictable size           */

say " "ex_nam"        produces a printable report showing the allocation       "
say "                status for specified datasets.                            "
say "                                                                          "
say "  Syntax:  "ex_nam"   <single-lvl>                                        "
say "                      <LEVELS dsni>                                       "
say "                      <OUTPUT dsno>       (Required)                      "
say "                                                                          "
say "            <single-lvl>  names a catalog level (or levels) to be         "
say "                          examined.  In operation, any tokens left after  "
say "                          parsing of LEVELS and OUTPUT are treated as     "
say "                          catalog levels to be examined.                  "
say "                                                                          "
say "            <dsni>        names a dataset containing LEVEL data suitable  "
say "                          for use by LISTC.  Each line of this dataset    "
say "                          may contain (0->n) specifications appropriate   "
say "                          for LISTC, but any line which begins with an    "
say "                          asterisk (*) will be ignored.  The contents of  "
say "                          this dataset, if used, will be in addition to   "
say "                          the <single-lvl> specified as a parm, if any.   "
say "                                                                          "
say "      At least one of <single-lvl> and <dsni> must be specified.          "
say "                                                                          "
say "                                                     more.....            "
"NEWSTACK" ; pull ; "CLEAR" ; "DELSTACK"
say "                                                                          "
say "            <dsno>        names a dataset to receive the output, a report "
say "                          showing datasetname and space usage statistics. "
say "                          <dsno> is a required specification, but the name"
say "                          specified does not need to pre-exist.  If <dsno>"
say "                          does not exist, it will be created as PS/VB/255."
say "                                                                          "
say "                          If <dsno> is specified as 'VIO' it will be      "
say "                          created as a VIO dataset and purged at CLOSE.   "
say "                          The VIO dataset used may be printed via any     "
say "                          appropriate facility during the final BROWSE    "
say "                          session.                                        "
say "                                                                          "
"NEWSTACK" ; pull ; "CLEAR" ; "DELSTACK"
say "   Debugging tools provided include:                                      "
say "                                                                          "
say "        MONITOR:  displays key information throughout processing.         "
say "                  Displays most paragraph names upon entry.               "
say "                                                                          "
say "        BRANCH:   show all paragraph entries.                             "
say "                                                                          "
say "        TRACE tv: will use value following TRACE to place the execution   "
say "                  in REXX TRACE Mode.                                     "
say "                                                                          "
say "                                                                          "
say "   Debugging tools can be accessed in the following manner:               "
say "                                                                          "
say "        TSO "ex_nam"  parameters     ((  debug-options                    "
say "                                                                          "
say "   For example:                                                           "
say "                                                                          "
say "        TSO "ex_nam"  (( MONITOR TRACE ?R                                 "

address ISPEXEC "CONTROL DISPLAY REFRESH"
exit                                   /*@ HELP                      */
/*  REXXSKEL back-end removed for space    */

./ ADD NAME=SSXTINFO
/* SSXTINFO - REXX EXEC to display  information about                 */
/*            tasks in the EBCX SSTX chain                            */
/*            or                                                      */
/*            Display the address of a XMS SUBSYS-id in               */
/*            the SSCT chain                                          */
/*                                                                    */
/*   Enter DLVR to display SSXT task information for                  */
/*   CA-Deliver and SARXTD intercepts.                                */
/*                                                                    */
/*   Enter XMS  and you will be prompted for a subsys id.             */
/*              After entering the XMS subsys id, information         */
/*              regarding corresponding XMS regions will be           */
/*              listed.                                               */
/*                                                                    */
/*                                                                    */
/*                    SAMPLE SSXT Task Information                    */
/*                    ============================                    */
/*                                                                    */
/*SSRT found at 6C2C320                                               */
/*                                                                    */
/*A(SSXT):  05D26A00    JOBNAME:  RMOSTCMR    SYSID=$    Active       */
/*NAME=RABHE01.DLVR16                            NETCLSL=N/P          */
/*JOBCLSL=W                                      NETDEST=U1/U2        */
/*SYSCLSL=                                       NETFORM=NF1/NF2      */
/*BNDLCLS=V   BNDLDEST=                          NETONLY=NO           */
/*--------------------------------------------------------------------*/
/*A(SSXT):  05F983A0    JOBNAME:  RMORSIX     SYSID=A    Active       */
/*NAME=SIXRO01.XPRREL61                          NETCLSL=             */
/*JOBCLSL=A                                      NETDEST=             */
/*SYSCLSL=A                                      NETFORM=             */
/*BNDLCLS=9   BNDLDEST=                          NETONLY=NO           */
/*--------------------------------------------------------------------*/
/*A(SSXT):  0650C418    SSID=SAR$    RELEASE=                         */
/*Security_Status=Inactive   Acct_Status=Inactive   ARA_Status=Inactiv*/
/*ACCT_DSN=      Security_HLQ=                                        */
/*JOB_CLASS(1)=A            SYS_CLASS(1)=1            ARCH_MEDIA(1)=D */
/*  ARCH_CLASS(1)=A     ARCH_DEST(1)=LOCAL        ARCH_FORM(1)=GARY   */
/*JOB_CLASS(2)=             SYS_CLASS(2)=             ARCH_MEDIA(2)=  */
/*  ARCH_CLASS(2)=      ARCH_DEST(2)=             ARCH_FORM(2)=       */
/*JOB_CLASS(3)=             SYS_CLASS(3)=             ARCH_MEDIA(3)=  */
/*  ARCH_CLASS(3)=      ARCH_DEST(3)=             ARCH_FORM(3)=       */
/*JOB_CLASS(4)=             SYS_CLASS(4)=             ARCH_MEDIA(4)=  */
/*  ARCH_CLASS(4)=      ARCH_DEST(4)=             ARCH_FORM(4)=       */
/*--------------------------------------------------------------------*/
/*A(SSXT):  0600AE78    SSID=SAR2    RELEASE=                         */
/*Security_Status=Inactive   Acct_Status=Inactive   ARA_Status=Inactiv*/
/*ACCT_DSN=      Security_HLQ=                                        */
/*JOB_CLASS(1)=A            SYS_CLASS(1)=1            ARCH_MEDIA(1)=D */
/*  ARCH_CLASS(1)=A     ARCH_DEST(1)=LOCAL        ARCH_FORM(1)=GARY   */
/*JOB_CLASS(2)=             SYS_CLASS(2)=             ARCH_MEDIA(2)=  */
/*  ARCH_CLASS(2)=      ARCH_DEST(2)=             ARCH_FORM(2)=       */
/*JOB_CLASS(3)=             SYS_CLASS(3)=             ARCH_MEDIA(3)=  */
/*  ARCH_CLASS(3)=      ARCH_DEST(3)=             ARCH_FORM(3)=       */
/*JOB_CLASS(4)=             SYS_CLASS(4)=             ARCH_MEDIA(4)=  */
/*  ARCH_CLASS(4)=      ARCH_DEST(4)=             ARCH_FORM(4)=       */
/*--------------------------------------------------------------------*/
  "clear"
  say "REXX exec to display EBCX SSTX chain for Deliver and SARXTD",
      "or the SUBSYS-ID address for an XMS region"
  say
  say "Enter DLVR  to display the SSTX chain for Deliver and SARXTD"
  say "Enter XMS   to display a SUBSYS-ID address"
  say "Enter ?     to display REXX exec information"
  pull help_arg

  If help_arg='?'!help_arg='HELP' Then Do
    line_index=1
    Do While SUBSTR(SOURCELINE(line_index),1,2)='/*'
      display_len=POS('*/',SOURCELINE(line_index),3)-3
      Say SUBSTR(SOURCELINE(line_index),3,display_len)
      line_index=line_index+1
    End
    Exit
  End

  If help_arg='XMS' Then Do
     Call DISP_XMS
     Exit
  End

  msg='EBCX SSCVT not found.'                             /*assume msg*/
  Say
  Say COPIES(' ',27)!!'SSXT Task Information'
  Say COPIES(' ',27)!!COPIES('=',21)
  Say
/*                                                             */
/*  CVT -> JESCT -> SSCVT ... EBCX                             */
/*  Find SSCVT+8 = 'EBCX'                                      */
/*                                                             */
  cvt=C2D(STORAGE(00000010,4))
  jesct=C2D(STORAGE(D2X(cvt+X2D('0128')),4))
  sscvt=C2D(STORAGE(D2X(jesct+X2D('18')),4))
  Do Forever
    If sscvt=0 Then
      Leave
    If STORAGE(D2X(sscvt+X2D('08')),4)='EBCX' Then
      Call DISP_EBCX
    sscvt=C2D(STORAGE(D2X(sscvt+X2D('04')),4))
  End
  If msg<>'' Then
    Say 'No RMO info--'msg
  Exit
/*-------------------*/
DISP_EBCX:
  Say "SSCVT found at" D2X(sscvt)
  msg='SSXT not found.'                                   /*assume msg*/
  ssrt=C2D(STORAGE(D2X(sscvt+X2D('14')),4))    /* user1 field address */
  c_ssxt=STORAGE(D2X(ssrt+X2D('40')),4)
  Say "SSRT found at" D2X(ssrt)
  Say " "
  Do Forever
    ssxt=C2D(c_ssxt)
    If ssxt=0 Then
      Leave
    ssxtname=STORAGE(D2X(ssxt+X2D('8')),4)
    ssxtrlse=STORAGE(d2x(ssxt+X2D('50')),4)
    If SUBSTR(ssxtname,1,3)='RMO' Then Do
      msg=''
      assxt=C2X(c_ssxt)
      sysid=SUBSTR(ssxtname,4,1)
      ssxtstat=C2D(STORAGE(D2X(ssxt+X2D('16')),1))
      If ssxtstat=X2D('80') Then
        status='Active    '
      Else If ssxtstat=X2D('0') Then
        status='Inactive  '
      Else
        status='Unexpected'
      ssxtjnam=STORAGE(D2X(ssxt+X2D('80')),8)
      ssxtncls=STORAGE(D2X(ssxt+X2D('100')),8)
      ssxtnfrm=STORAGE(D2X(ssxt+X2D('108')),8)
      ssxtndst=STORAGE(D2X(ssxt+X2D('110')),8)
      ssxtocls=STORAGE(D2X(ssxt+X2D('118')),8)
      ssxtofrm=STORAGE(D2X(ssxt+X2D('120')),8)
      ssxtodst=STORAGE(D2X(ssxt+X2D('128')),8)
      ssxtswt2=STORAGE(D2X(ssxt+X2D('1BC')),1)
      netclsl=STRIP(ssxtncls)
      If ssxtocls<>' ' Then
        netclsl=netclsl'/'ssxtocls
      netform=STRIP(ssxtnfrm)
      If ssxtofrm<>' ' Then
        netform=netform'/'ssxtofrm
      netdest=STRIP(ssxtndst)
      If ssxtodst<>' ' Then
        netdest=netdest'/'ssxtodst
      If BITOR(ssxtswt2,'02'X) == ssxtswt2 Then
        netonly = 'YES'
      Else
        netonly = 'NO '
      ssxtdbix=STORAGE(D2X(ssxt+X2D('18c')),17)
      ssxtjcls=STORAGE(D2X(ssxt+X2D('140')),38)
      ssxtscls=STORAGE(D2X(ssxt+X2D('168')),36)
      ssxtbhcl=STORAGE(D2X(ssxt+X2D('1b9')),1)
      ssxtbhds=STORAGE(D2X(ssxt+X2D('130')),8)
      Say 'A(SSXT): ' assxt '    JOBNAME:' ssxtjnam '   SYSID='sysid '  ' status
      Say 'NAME='ssxtdbix 'RELEASE:' ssxtrlse,
        '          NETCLSL='netclsl
      Say 'JOBCLSL='ssxtjcls 'NETDEST='netdest
      Say 'SYSCLSL='ssxtscls '  NETFORM='netform
      Say 'BNDLCLS='ssxtbhcl '  BNDLDEST='ssxtbhds,
        COPIES(' ',14) '  NETONLY='netonly
      Call PQES "SSXT("D2X(ssxt)")"
      Say COPIES('-',77)
    End
    Else If SUBSTR(ssxtname,1,3)='SAR' Then Do
      msg=''
      assxt=C2X(c_ssxt)
      sysid=SUBSTR(ssxtname,4,1)
      ssxtstat=STORAGE(D2X(ssxt+X2D('C4')),1)
      If BITOR(ssxtstat,'80'X) == ssxtstat Then
        sec_status='Active    '
      Else
        sec_status='Inactive  '
      If BITOR(ssxtstat,'40'X) == ssxtstat Then
        act_status='Active    '
      Else
        act_status='Inactive  '
      If BITOR(ssxtstat,'20'X) == ssxtstat Then
        ara_status='Active    '
      Else
        ara_status='Inactive  '
      ssxtadsn=STORAGE(D2X(ssxt+X2D('98')),44)
      ssxtadsn=STRIP(TRANSLATE(ssxtadsn,' ','00'X))
      If LENGTH(ssxtadsn) = 0 Then
        ssxtadsn = COPIES(' ',5)
      If LENGTH(ssxtadsn) > 30 Then
        ssxtadsn = "..."RIGHT(ssxtadsn,30)
      ssxtidx =STORAGE(D2X(ssxt+X2D('C6')),18)
      ssxtarat=STORAGE(D2X(ssxt+X2D('D8')),34*4)
      Do i = 1 To 4
        Parse Var ssxtarat,
          001 ssxtjcls.i +8,
          ssxtscls.i +8,
          ssxtacls.i +1,
          ssxtadst.i +8,
          ssxtafrm.i +8,
          ssxtamed.i +1,
          ssxtarat
      End

      Say 'A(SSXT): ' assxt '   SSID=SAR'sysid '   RELEASE='ssxtrlse
      Say 'Security_Status='sec_status  'Acct_Status='act_status,
        'ARA_Status='ara_status
      Say 'ACCT_DSN='ssxtadsn 'Security_HLQ='ssxtidx
      Do i=1 To 4
        Say "JOB_CLASS("i")="ssxtjcls.i "   ",
          "SYS_CLASS("i")="ssxtscls.i "   ",
          "ARCH_MEDIA("i")="ssxtamed.i "   "
        Say "  ARCH_CLASS("i")="ssxtacls.i "   ",
          "ARCH_DEST("i")="ssxtadst.i "   ",
          "ARCH_FORM("i")="ssxtafrm.i "   "
      End
      Say COPIES('-',77)
    End
    Else Do
      Say 'UNKNOWN Subsystem_id='ssxtname
      Say COPIES('-',77)
    End
    c_ssxt=STORAGE(D2X(ssxt+X2D('c')),4)
  End
  Return
PQES: Procedure
  Numeric Digits 10
  Parse Upper Arg "SSXT(" ssxt ")" .
  ssxt = X2D(ssxt)
/*                                                             */
/*  SSXT -> ASB -> PQE ...                                     */
/*                                                             */
  asb=C2D(STORAGE(D2X(ssxt+X2D('004C')),4))

  asbnqreq = c2d(storage(d2x(asb+x2d('003C')),4))
  asbhwreq = c2d(storage(d2x(asb+x2d('0040')),4))
  SAy "Number of requests queued:" asbnqreq
  SAy "Highest no. reqs.  queued:" asbhwreq
  say ""

  Call RUN_PQES C2D(STORAGE(D2X(asb+X2D('0008')),4))
  reqq_count = result
  Call RUN_PQES C2D(STORAGE(D2X(asb+X2D('000C')),4))
  lifo_count = result
  Call RUN_PQES C2D(STORAGE(D2X(asb+X2D('0010')),4))
  fifo_count = result
  Call RUN_PQES C2D(STORAGE(D2X(asb+X2D('0014')),4))
  obtn_count = result
  Call RUN_PQES C2D(STORAGE(D2X(asb+X2D('0018')),4))
  free_count = result
  Call RUN_PQES C2D(STORAGE(D2X(asb+X2D('001C')),4))
  errq_count = result
  Say "REQUEST    LIFO    FIFO  OBTAIN    FREE   ERROR"
  Say RIGHT(reqq_count,7),
    RIGHT(lifo_count,7),
    RIGHT(fifo_count,7),
    RIGHT(obtn_count,7),
    RIGHT(free_count,7),
    RIGHT(errq_count,7)
  Return
RUN_PQES:
  Arg pqe_addr
  pqe_count = 0
  Do While pqe_addr Á= 0
    pqe_count = pqe_count+1
    pqe = STORAGE(D2X(pqe_addr),128)
    pqe_addr = C2D(STORAGE(D2X(pqe_addr+X2D('0008')),4))
  End
  Return pqe_count
/*-------------------*/
DISP_XMS:
say "Please enter a XMS region SUBSYS-ID"
pull subsys_id
  cvt=C2D(STORAGE(00000010,4))
  jesct=C2D(STORAGE(D2X(cvt+X2D('0128')),4))
  sscvt=C2D(STORAGE(D2X(jesct+X2D('18')),4))
  Do Forever
    If sscvt=0 Then
      Leave
    If STORAGE(D2X(sscvt+X2D('08')),4)=subsys_id Then do
      subsys_addr=sscvt+8
      Say "SUBSYS-ID address for "!! subsys_id !!" found at" D2X(subsys_addr)
      CALL XMS_INFO (sscvt subsys_id)
      Return
    End
    sscvt=C2D(STORAGE(D2X(sscvt+X2D('04')),4))
  End
  If msg<>'' Then
    Say subsys_id!!" Not found in SSCT chain"
Return
/*-----------------------*/
XMS_INFO:
Arg sscvt_addr subsysid
xmct_addr=C2D(STORAGE(D2X(sscvt_addr+X2D('14')),4))
  say "                          "
  say "XMS regions found for " !! subsysid
  say "=========================="
  say "                          "
  Do Forever
     if xmct_addr=0 Then
        Leave
     xmct_region=STORAGE(D2X(xmct_addr+X2D('08')),8)
     xmct_applid=STORAGE(D2X(xmct_addr+X2D('7C')),8)
     xmct_asid=C2D(STORAGE(D2X(xmct_addr+X2D('5C')),2))
     say "Regionid: "!! xmct_region
     if xmct_asid = 0 Then
         say "Asid:     Region Not Active"
     else
          say "Asid:     "!! D2X(xmct_asid)
     say "Applid:   "!! xmct_applid
     say "--------------------------"
     xmct_addr=C2D(STORAGE(D2X(xmct_addr+X2D('48')),4))
   End
Return

./ ADD NAME=SYSAMON
/* REXX    SYSAMON    Maintain the SYSUMON VSAM file.

           Written by Frank Clarke 20040607

     Impact Analysis
.    SYSEXEC   TRAPOUT
.    SYSEXEC   WHOIS

     Modification History
     20040709 fxc move OPENs and CLOSEs within the range of use;
     20041117 fxc update ImpAnal;
     20050216 fxc list 92 bytes only;
     20061205 fxc add Grand Total counts;
     20070212 fxc make it work for a DUMP dataset as input;
     20080111 fxc correct reporting for detailed request;
     20090102 fxc fix problem with calculation of DSMO at
                  change-of-year;

*/ arg argline
address TSO                            /* REXXSKEL ver.20040227      */
arg parms "((" opts

signal on syntax
signal on novalue

call TOOLKIT_INIT                      /* conventional start-up     -*/
rc = Trace("O"); rc = Trace(tv)
info   = parms                         /* to enable parsing          */

call A_INIT                            /*                           -*/

if dumpin = "" then,
   call B_VSAM_OPS                     /*                           -*/
else,
   call C_DUMP_OPS                     /*                           -*/

if sw.0SaveLog then,
   call ZB_SAVELOG                     /*                           -*/


if ^sw.nested then call DUMP_QUEUE     /*                           -*/
exit                                   /*@ SYSAMON                   */
/*
   Initialization
.  ----------------------------------------------------------------- */
A_INIT:                                /*@                           */
   if branch then call BRANCH
   address TSO

   call AA_SETUP_LOG                   /* sets yyyymmdd, mm, dd     -*/
   parse value yyyymmdd Date("B") with yy4 5  .  b_date
   parse value "0 0 0 0 0 0 0 0 0 0 0" with,
         byuser.   byitem.  ,
         gt     sum.      ct.      .
   parse value "" with,
         altname.  dumpmo   vskey    rxvsam_vsamerrormsg ,
         altulist  items     uidlist  record   prevuser  previtem  ,
         keyorig   name.    userkeylist   itemkeylist ,
         .
   call AB_LAST_MONTH                  /*                           -*/
   call AK_KEYWDS                      /*                           -*/

return                                 /*@ A_INIT                    */
/*
   Prep progress-log dataset
.  ----------------------------------------------------------------- */
AA_SETUP_LOG:                          /*@                           */
   if branch then call BRANCH
   address TSO

   parse value "0" with,
               log#    log.
   parse value Date("S")  Time("S")  Time("N")  with,
               yyyymmdd   sssss      hhmmss  .
   parse var yyyymmdd  4 yrdigit 5 mm 7 dd          /* 9 12 14 maybe */
   if Pos(yrdigit,"13579") > 0 then mm = mm + 12       /* mm=24      */
   logtag = Substr("ABCDEFGHIJKLMNOPQRSTUVWX",mm,1)    /* logtag=X   */
   subid  = logtag""dd""Right(sssss,5,0)               /* X1423722 ? */
   vb4k.0    = "NEW CATALOG UNIT(SYSDA) SPACE(1 5) TRACKS",
               "RECFM(V B) LRECL(4096) BLKSIZE(0)"
   vb4k.1    = "SHR"                   /* if it already exists...    */
   logdsn = "@@LOG."exec_name"."subid".#CILIST"

   call ZL_LOGMSG(exec_name "started by" Userid()  yyyymmdd  hhmmss)
   call ZL_LOGMSG("Arg:" argline)

return                                 /*@ AA_SETUP_LOG              */
/*
   Determine the prior month
.  ----------------------------------------------------------------- */
AB_LAST_MONTH:                         /*@                           */
   if branch then call BRANCH
   address TSO

   lastmoend = Date("S",b_date-dd,"B")   /* last day of prev month   */
   parse var lastmoend  5 lastmo 7 3 dsmo 7
   call ZL_LOGMSG( "("BRANCH("ID")")" ,
                   "DSMO set to" dsmo)

return                                 /*@ AB_LAST_MONTH             */
/*
   Parse out TOOL and USER
.  ----------------------------------------------------------------- */
AK_KEYWDS:                             /*@                           */
   if branch then call BRANCH
   address TSO

   caller = KEYWD("USER")              /* particular userid          */
   tool   = KEYWD("TOOL")              /* particular tool            */
   dumpin = KEYWD("INDUMP")            /* DUMP dataset as input      */

   sw.0Clear = SWITCH("CLEAR")         /* placed last in case there are
                                          ever tools with these names*/
   sw.0List  = SWITCH("LIST")
   sw.0Sum   = SWITCH("SUMMARY")       /* valid only for LIST        */
   if Space(caller tool,0) <> "" then, /* specific                   */
      parse value "1 1 0" with sw.0Detail sw.0List sw.0Sum

   if dumpin <> "" then,               /* using DUMP for input       */
      do
      parse value 0 with sw.0Clear     /* nothing else needed        */
      opts = ""
      if sw.0List + sw.0Sum = 0 then   /* both off                   */
         parse value "1 1" with sw.0List sw.0Sum
      end

   sw.0Trim  = SWITCH("TRIM")
   dumpds    = KEYWD("DUMPTO")         /* DUMP output                */

   parse var yyyymmdd       5 mm 7     /* reset mm to original value */
             /* parse this dead-last........                         */
   if WordPos("DUMP",info) > 0 then do
      parse value KEYWD("DUMP")  lastmo   with,
                  dumpmo .             /* pick up dump-month: nn     */
      dumpmo = Right(dumpmo,2,0)
      if dumpmo > mm then do           /* must be last year!         */
         yy4 = yy4 - 1
         end                           /* last year                  */
      dsmo = Right(yy4 !! dumpmo,4)
      if dumpmo <> lastmo then,
         call ZL_LOGMSG( "("BRANCH("ID")")" ,
                         "DSMO reset to" dsmo)

      if dumpmo = "" then sw.0Clear = 0 /* CLEAR only if DUMP        */

      if dumpds = "" then return
      if dumpds = "DEFAULT" then,
         dumpds = "'NTIN.TS.D822.SYSUMON.DUMP"dsmo"'"
      end                              /* DUMP                       */

   if sw.0Clear then,                  /* do everything              */
      parse value "" with caller tool

return                                 /*@ AK_KEYWDS                 */
/*
   LIBDEF to 'NTIN.TS.D822.LIB.ISPLLIB' to enable calls to RXVSAM.
.  ----------------------------------------------------------------- */
B_VSAM_OPS:                            /*@                           */
   if branch then call BRANCH
   address TSO

   if sw.inispf then,
      address ISPEXEC "LIBDEF ISPLLIB DATASET" ,
                      "ID('NTIN.TS.D822.LIB.ISPLLIB') STACK"

   "ALLOC FI($VS) DA("vsamksds") SHR REU"

   if sw.0List ! dumpmo <> "" then,    /* list or dump               */
      call BD_DUMP_DATA                /*                           -*/

   if sw.0Trim then do                 /* reduce wasted lines        */
      call BT_TRIM_DATA                /*                           -*/
      end

   "FREE  FI($VS)"

   if sw.inispf then,
      address ISPEXEC "LIBDEF ISPLLIB"

return                                 /*@ B_VSAM_OPS                */
/*
   List selected records.  Full listing or selected month?
.  ----------------------------------------------------------------- */
BD_DUMP_DATA:                          /*@                           */
   if branch then call BRANCH
   address TSO

   if dumpmo <> "" then,               /* one month                  */
      call BDM_SPILL_MONTH             /*                           -*/
   else,                               /* general list               */
      call BDQ_GENL_LIST               /*                           -*/

return                                 /*@ BD_DUMP_DATA              */
/*
   Process specific month.
.  ----------------------------------------------------------------- */
BDM_SPILL_MONTH:                       /*@                           */
   if branch then call BRANCH
   address TSO

   call BDMA_ACQUIRE_CTS               /* spin VSAM and get counts  -*/

   if sw.0List + sw.0Sum > 0 then,
      call BDMU_GET_NAMES              /* identify users            -*/

   if sw.0List then do
      call BDMB_USERLIST               /* list sorted by user       -*/
      call BDMC_ITEMLIST               /* list sorted by tool       -*/
      end                              /* sw.0list                   */

   if sw.0Sum  then do
      call BDMS_SUMMARY                /* summary counts only       -*/
      end                              /* sw.0list                   */

   if dumpds <> "" then do
      call BDMD_DUMP_DATA              /* spill to DASD             -*/
      end                              /* dumpds                     */

return                                 /*@ BDM_SPILL_MONTH           */
/*
   Find the usage counts for the selected (or all) categories.
.  ----------------------------------------------------------------- */
BDMA_ACQUIRE_CTS:                      /*@                           */
   if branch then call BRANCH
   address TSO

   if sw.0Clear then do
      rxv_rc = RXVSAM("OPENIO","$VS","KSDS")
      sw.0SaveLog = 1
      call ZL_LOGMSG( "("BRANCH("ID")")" ,
                      vsamksds "opened for UPDATE")
      end
   else do
      rxv_rc = RXVSAM("OPENINPUT","$VS","KSDS")
      call ZL_LOGMSG( "("BRANCH("ID")")" ,
                      vsamksds "opened for INPUT")
      end

   do forever
      rxv_rc = RXVSAM("READNEXT","$VS",,"RECORD")
      if rxv_rc > 0 then leave

      parse var record user . 9 item . 17,
                ct.01 ct.02 ct.03 ct.04 ct.05 ct.06,
                ct.07 ct.08 ct.09 ct.10 ct.11 ct.12,
                keyorig  rowname

      if altname.user = "" then,
      if rowname     <> "" then do
         altname.user = SHIFT( rowname )
         altulist  = altulist user
         end

      if WordPos(user,uidlist) = 0 then ,
         uidlist = uidlist user
      if WordPos(item,items  ) = 0 then ,
         items   = items   item

      if caller <> "" & caller <> user then iterate
      if tool   <> "" & tool   <> item then iterate
      if ct.dumpmo = 0                 then iterate
      ct.dumpmo = ct.dumpmo + 0

      userkey = user"."item
      userkeylist = userkeylist userkey
      byuser.userkey = ct.dumpmo
      byuser.user    = byuser.user + ct.dumpmo

      itemkey = item"."user
      itemkeylist = itemkeylist itemkey
      byitem.itemkey = ct.dumpmo
      byitem.item    = byitem.item + ct.dumpmo

      if noupdt = 0 then,              /* OK to update               */
      if sw.0Clear then do             /* zap counts                 */
         call ZL_LOGMSG( "("BRANCH("ID")")" ,
                         "Rewriting" user item ct.dumpmo)
         ct.dumpmo = 0
         call BDMAP_PUT_KEY            /*                           -*/
         end                           /* sw.0Clear                  */
   end                                 /* forever                    */
   rxv_rc = RXVSAM("CLOSE","$VS")

   userkeylist = STRSORT(userkeylist)
   itemkeylist = STRSORT(itemkeylist)

return                                 /*@ BDMA_ACQUIRE_CTS          */
/*
.  ----------------------------------------------------------------- */
SHIFT: Procedure                       /*@                           */
   address TSO

   shifted = ""
   arg wordlist
   do Words( wordlist )
      parse var wordlist  word  wordlist
      low = Translate(word,,
                  "abcdefghijklmnopqrstuvwxyz",,
                  "ABCDEFGHIJKLMNOPQRSTUVWXYZ")
      word  = Left(word,1)Substr(low,2)
      shifted = shifted  word
   end                                 /* wordlist                   */

return( shifted )                      /*@ SHIFT                     */
/*
   Write-with-key the updated record.  Clearing out a column.
.  ----------------------------------------------------------------- */
BDMAP_PUT_KEY:                         /*@                           */
   if branch then call BRANCH
   address TSO

   record = Left(user,8)Left(item,8),
            Right(ct.01,5,0),
            Right(ct.02,5,0),
            Right(ct.03,5,0),
            Right(ct.04,5,0),
            Right(ct.05,5,0),
            Right(ct.06,5,0),
            Right(ct.07,5,0),
            Right(ct.08,5,0),
            Right(ct.09,5,0),
            Right(ct.10,5,0),
            Right(ct.11,5,0),
            Right(ct.12,5,0),
            keyorig "          "rowname

   key = Left(user,8)Left(item,8)
   rxv_rc = RXVSAM("REWRITE","$VS","KEY","RECORD")

return                                 /*@ BDMAP_PUT_KEY             */
/*
   List usage by user
.  ----------------------------------------------------------------- */
BDMB_USERLIST:                         /*@                           */
   if branch then call BRANCH
   address TSO

   "CLEAR"                             /* ... the screen             */
   say  "- User - - Tool - - Ct-   Month="dumpmo
   say  "-------- -------- -----"

   do bz = 1 to Words(userkeylist)     /* each key                   */
      ukey = Word(userkeylist,bz)      /* get key                    */
      parse var ukey user "." item
      if user <> prevuser then do
         if byuser.prevuser <> 0 then do
            say   Left(' ' ,8) Left(' ' ,8) Right(byuser.prevuser,5),
                                            Space( name.prevuser,1 )
            end
         say; prevuser = user
         end
      say   Left(user,8) Left(item,8) Right(byuser.ukey,5)
      byuser.tot = byuser.tot + byuser.ukey
   end                                 /* bz                         */
   if byuser.prevuser <> 0 then,
      say   Left(' ' ,8) Left(' ' ,8) Right(byuser.prevuser,5),
                                      Space( name.prevuser,1 )

   say   Left(' ' ,8) Left(' ' ,8) Right(byuser.tot     ,5),
                          "All users, all tools"

   "NEWSTACK" ; pull ; "DELSTACK"
   call ZL_LOGMSG( "("BRANCH("ID")")" ,
                   "Counted" byuser.tot "usage by-user.")

return                                 /*@ BDMB_USERLIST             */
/*
   List usage by item
.  ----------------------------------------------------------------- */
BDMC_ITEMLIST:                         /*@                           */
   if branch then call BRANCH
   address TSO

   "CLEAR"                             /* ... the screen             */
   say  "- User - - Tool - - Ct-   Month="dumpmo
   say  "-------- -------- -----"

   do bz = 1 to Words(itemkeylist)     /* each key                   */
      ikey = Word(itemkeylist,bz)      /* get key                    */
      parse var ikey item "." user
      if item <> previtem then do
         if byitem.previtem <> 0 then,
            say   Left(' ' ,8) Left(' ' ,8) Right(byitem.previtem,5)
         say; previtem = item
         end
      say   Left(user,8) Left(item,8) Right(byitem.ikey,5)
      byitem.tot = byitem.tot + byitem.ikey
   end                                 /* bz                         */
   if byitem.previtem <> 0 then,
      say   Left(' ' ,8) Left(' ' ,8) Right(byitem.previtem,5)

   say   Left(' ' ,8) Left(' ' ,8) Right(byitem.tot     ,5),
                          "All users, all tools"

   "NEWSTACK" ; pull ; "DELSTACK"
   call ZL_LOGMSG( "("BRANCH("ID")")" ,
                   "Counted" byitem.tot "usage by-item.")

return                                 /*@ BDMC_ITEMLIST             */
/*
   Dump to DASD using USERKEYLIST.
.  ----------------------------------------------------------------- */
BDMD_DUMP_DATA:                        /*@                           */
   if branch then call BRANCH
   address TSO

   alloc.0   = "NEW CATALOG UNIT(SYSDA) SPACE(5 5) TRACKS",
               "RECFM(V B) LRECL(255) BLKSIZE(0)"
   alloc.1   = "MOD"                   /* if it already exists...    */
   tempstat = Sysdsn(dumpds) = "OK" !, /* 1=exists, 0=missing        */
              Sysdsn(dumpds) = "MEMBER NOT FOUND"
   "ALLOC FI($TMP) DA("dumpds") REU" alloc.tempstat

   "NEWSTACK"
   do bz = 1 to Words(userkeylist)     /* each key                   */
      ukey = Word(userkeylist,bz)      /* get key                    */
      parse var ukey user "." item

      queue Left(user,8) Left(item,8) Right(byuser.ukey,5) altname.user
   end                                 /* bz                         */

   sw.0SaveLog = 1
   call ZL_LOGMSG( "("BRANCH("ID")")" ,
                   "Writing" queued() "lines to" dumpds)
   "EXECIO" queued() "DISKW $TMP (FINIS"
   "FREE  FI($TMP)"
   "DELSTACK"

return                                 /*@ BDMD_DUMP_DATA            */
/*
   Summary by user and by tool.  If there are too many of one kind or
   the other (total count > scrnlen) and there is room on the screen
   (total count < scrnlen*2), the excess items can be folded into the
   other column at the bottom.
.  ----------------------------------------------------------------- */
BDMS_SUMMARY:                          /*@                           */
   if branch then call BRANCH
   address TSO

   parse value "" with prt.  uslot. islot.
   uidlist = STRSORT(uidlist)
   items   = STRSORT(items)
   call BDMSI_ITEMLIST
   call BDMSU_USERLIST
   parse value Words(uidlist) Words(items) with,
               uidct          itemct  .

   scrnlen = Sysvar("SYSLTERM") - 2    /* usable lines on screen     */
   if (uidct + itemct) < (scrnlen*2) then,       /* 40+9 < 26*2      */
   if uidct > scrnlen then do          /* 40 > 26                    */
      excess_items = uidct - scrnlen   /* 40 - 26 = 14               */
      other_col_start = scrnlen - excess_items + 1     /* 26-14+1=13 */
      uidct = scrnlen                  /* 26                         */
      end
   else if itemct > scrnlen then do
      excess_items = itemct - scrnlen
      other_col_start = scrnlen - excess_items + 1
      itemct = scrnlen
      end

   /* Build the print lines                                          */
   do bx = 1 to uidct                  /* each uid                   */
      parse var uidlist   uid uidlist
      name    = Space(name.uid,1)
      prt.bx  = " ",                   /* 01 - 01                    */
                uid,                   /* 02 - 08                    */
                Right(byuser.uid,5),   /* 09 - 13                    */
                " ",                   /* 14 - 16                    */
                Left(name    ,23)      /* 17 - 39                    */
   end                                 /* bx                         */
   prt.0 = uidct

   do bx = 1 to itemct                 /* each uid                   */
      parse var items  item items
      prt.bx  = Left(prt.bx,48),       /* 01 - 48                    */
             !! Left(item,8),          /* 49 - 56                    */
                Right(byitem.item,5)   /* 57 - 61                    */
      gt      = gt + byitem.item
   end                                 /* bx                         */
   prt.0  = Max( uidct, itemct )

   if uidlist <> "" then do            /* excess items               */
      do bx = other_col_start to scrnlen
         parse var uidlist   uid uidlist
         name    = Space(name.uid,1)
         prt.bx  = Left(prt.bx,47),
                   uid,
                   Right(byuser.uid,5),
                   " ",
                   Left(name    ,23)
      end                              /* bx                         */
      prt.0 = scrnlen
      end                              /* uidlist                    */

   if items <> "" then do              /* excess items               */
      do bx = other_col_start to scrnlen
         slug = Left(item,8),
                Right(byitem.item,5)
         prt.bx = Overlay(slug,prt.bx,2)
      end                              /* bx                         */
      prt.0 = scrnlen
      end                              /* items                      */

   "CLEAR"
   do bx = 1 to prt.0                  /* each uid                   */
      say prt.bx
   end                                 /* bx                         */
   say  Left(" ",8),
        Right(gt,5) "  Grand Total   ",
               uidct "users     " itemct "tools"

return                                 /*@ BDMS_SUMMARY              */
/*
   Eliminate any items with a zero use-count
.  ----------------------------------------------------------------- */
BDMSI_ITEMLIST:                        /*@                           */
   if branch then call BRANCH
   address TSO

   w1 = ""                             /* init                       */
   do Words(items)
      parse value items w1  with  w1 items
      if byitem.w1   = 0 then w1 = ""
   end                                 /* items                      */
   items = items w1

return                                 /*@ BDMSI_ITEMLIST            */
/*
   Eliminate any users with a zero use-count
.  ----------------------------------------------------------------- */
BDMSU_USERLIST:                        /*@                           */
   if branch then call BRANCH
   address TSO

   w1 = ""                             /* init                       */
   do Words(uidlist)
      parse value uidlist w1 with w1 uidlist
      if byuser.w1   = 0 then w1 = ""
   end                                 /* uidlist                    */
   uidlist = uidlist w1

return                                 /*@ BDMSU_USERLIST            */
/*
   Connect name to userid
.  ----------------------------------------------------------------- */
BDMU_GET_NAMES:                        /*@                           */
   if branch then call BRANCH
   address TSO

   replist = ""                        /* init                       */
   "NEWSTACK"
   "WHOIS" uidlist                     /* get user names             */
   do queued()
      pull uid name.uid
      if name.uid = "?" then,
      if altname.uid <> "" then do
         replist  = replist uid
         name.uid = altname.uid
         end
   end                                 /* queued                     */
   "DELSTACK"

return                                 /*@ BDMU_GET_NAMES            */
/*
   sw.0Sum may be set.
.  ----------------------------------------------------------------- */
BDQ_GENL_LIST:                         /*@                           */
   bdq_tv = trace()                    /* what setting at entry ?    */
   if branch then call BRANCH
   address TSO

   rxv_rc = RXVSAM("OPENINPUT","$VS","KSDS")
   call ZL_LOGMSG( "("BRANCH("ID")")" ,
                   vsamksds "opened for INPUT")
   if sw.0Sum then parse value "" with,
                        caller tool    /* invalid for summary        */

   do forever
      rxv_rc = RXVSAM("READNEXT","$VS",,"RECORD")
      if rxv_rc > 0 then leave

      parse var record user . 9 item . 17,
                ct.01 ct.02 ct.03 ct.04 ct.05 ct.06,
                ct.07 ct.08 ct.09 ct.10 ct.11 ct.12,
                keyorig  .

      /* Produce totals for this data                                */
      call BDQC_SUMMARIZE              /*                           -*/
      if sw.0Sum then iterate

      if caller <> "" & caller <> user then iterate
      if tool   <> "" & tool   <> item then iterate
      queue Left(record,132)
   end                                 /* forever                    */
                                    rc = Trace("O"); rc = trace(bdq_tv)
   rxv_rc = RXVSAM("CLOSE","$VS")

   if sw.0Sum then,
      call BDQS_PRINT_SUM              /*                           -*/
   else do
      call BDQL_LIST_HDRS              /*                           -*/
      if sw.0Detail then,
         call BDQT_TOTALS              /*                           -*/
      end

return                                 /*@ BDQ_GENL_LIST             */
/*
   Foot and crossfoot
.  ----------------------------------------------------------------- */
BDQC_SUMMARIZE:                        /*@                           */
   if branch then call BRANCH
   address TSO

   rowsum = ct.01 + ct.02 + ct.03 + ct.04 + ct.05 + ct.06 +,
            ct.07 + ct.08 + ct.09 + ct.10 + ct.11 + ct.12

   sum.01 = sum.01 + ct.01
   sum.02 = sum.02 + ct.02
   sum.03 = sum.03 + ct.03
   sum.04 = sum.04 + ct.04
   sum.05 = sum.05 + ct.05
   sum.06 = sum.06 + ct.06
   sum.07 = sum.07 + ct.07
   sum.08 = sum.08 + ct.08
   sum.09 = sum.09 + ct.09
   sum.10 = sum.10 + ct.10
   sum.11 = sum.11 + ct.11
   sum.12 = sum.12 + ct.12

   if WordPos(user,userkeylist) = 0 then,
      userkeylist = userkeylist user   /* add it                     */
   sum.user = sum.user + rowsum

   if WordPos(item,itemkeylist) = 0 then,
      itemkeylist = itemkeylist item   /* add it                     */
   sum.item = sum.item + rowsum
   sum.gt   = sum.gt   + rowsum        /* grand total                */

return                                 /*@ BDQC_SUMMARIZE            */
/*
   The detailed records have already been queued.  PUSH the headers
   onto the top of the stack.
.  ----------------------------------------------------------------- */
BDQL_LIST_HDRS:                        /*@                           */
   if branch then call BRANCH
   address TSO

   push "------  -------- ----- ----- ----- ----- ----- -----",
                        "----- ----- ----- ----- ----- -----"
   push "-User   - Tool - -Jan- -Feb- -Mar- -Apr- -May- -Jun-",
                         "-Jul- -Aug- -Sep- -Oct- -Nov- -Dec-"

return                                 /*@ BDQL_LIST_HDRS            */
/*
.  ----------------------------------------------------------------- */
BDQS_PRINT_SUM:                        /*@                           */
   if branch then call BRANCH
   address TSO

   "CLEAR"
   say  "-User   - Tool - -Jan- -Feb- -Mar- -Apr- -May- -Jun-",
                         "-Jul- -Aug- -Sep- -Oct- -Nov- -Dec-"
   say  "------  -------- ----- ----- ----- ----- ----- -----",
                        "----- ----- ----- ----- ----- -----"
   say  "------  --------",
        Right(sum.01,5) ,
        Right(sum.02,5) ,
        Right(sum.03,5) ,
        Right(sum.04,5) ,
        Right(sum.05,5) ,
        Right(sum.06,5) ,
        Right(sum.07,5) ,
        Right(sum.08,5) ,
        Right(sum.09,5) ,
        Right(sum.10,5) ,
        Right(sum.11,5) ,
        Right(sum.12,5)

   say  "     Grand Total",
        Right(sum.gt,5)
   "NEWSTACK"; pull ; "CLEAR" ; "DELSTACK"

   scrnlen = Sysvar("SYSLTERM")        /* lines on screen            */
   scrnwid = Sysvar("SYSWTERM")        /* columns on screen          */
   max_entries = (scrnwid%16) * (scrnlen-3)
   userkeylist = STRSORT(userkeylist)  /*                           -*/
   itemkeylist = STRSORT(itemkeylist)  /*                           -*/

   say "       Usage by user "

return                                 /*@ BDQS_PRINT_SUM            */
/*
   Queue totals for the detail request.
.  ----------------------------------------------------------------- */
BDQT_TOTALS:                           /*@                           */
   if branch then call BRANCH
   address TSO

   queue  "--      --      ",
          Right(sum.01,5) ,
          Right(sum.02,5) ,
          Right(sum.03,5) ,
          Right(sum.04,5) ,
          Right(sum.05,5) ,
          Right(sum.06,5) ,
          Right(sum.07,5) ,
          Right(sum.08,5) ,
          Right(sum.09,5) ,
          Right(sum.10,5) ,
          Right(sum.11,5) ,
          Right(sum.12,5)

return                                 /*@ BDQT_TOTALS               */
/*
   Find and delete all lines whose counters are uniformly zero.  If
   necessary, the VSAM file was closed and reopened to reposition it
   to the beginning.
.  ----------------------------------------------------------------- */
BT_TRIM_DATA:                          /*@                           */
   if branch then call BRANCH
   address TSO

   rxv_rc = RXVSAM("OPENIO","$VS","KSDS")
   sw.0SaveLog = 1
   call ZL_LOGMSG( "("BRANCH("ID")")" ,
                   vsamksds "opened for UPDATE")

   do forever
      rxv_rc = RXVSAM("READNEXT","$VS",,"RECORD")
      if rxv_rc > 0 then leave

      parse var record user . 9 item . 17,
                ct.01 ct.02 ct.03 ct.04 ct.05 ct.06,
                ct.07 ct.08 ct.09 ct.10 ct.11 ct.12,
                keyorig  .

      if ct.01 + ct.02 + ct.03 + ct.04 + ct.05 + ct.06 +,
         ct.07 + ct.08 + ct.09 + ct.10 + ct.11 + ct.12 = 0 then do
         if noupdt = 0 then,           /* OK to update               */
            key = Left(user,8)Left(item,8)
            rxv_rc = RXVSAM("DELETE","$VS","KEY")
            call ZL_LOGMSG( "("BRANCH("ID")")" ,
                            "KEY:"user"."item "was trimmed.")
         end

   end                                 /* forever                    */
   rxv_rc = RXVSAM("CLOSE","$VS")

return                                 /*@ BT_TRIM_DATA              */
/*
   A one-month DUMP file has been specified for input.
   The input is a flatfile with 3 tokens per line: user, item, count.
.  ----------------------------------------------------------------- */
C_DUMP_OPS:                            /*@                           */
   c_tv = trace()                      /* what setting at entry ?    */
   if branch then call BRANCH
   address TSO

   call CA_LOAD_COUNTS                 /* byuser. and byitem.       -*/

   call BDMU_GET_NAMES                 /* identify users            -*/

   if sw.0List then do
      call BDMB_USERLIST               /* list sorted by user       -*/
      call BDMC_ITEMLIST               /* list sorted by tool       -*/
      end                              /* sw.0list                   */

   if sw.0Sum  then do
      call BDMS_SUMMARY                /* summary counts only       -*/
      end                              /* sw.0list                   */
                                     rc = Trace("O"); rc = trace(c_tv)
   if replist <> "" then do
      do Words( replist )
         parse var replist  uid replist
         wc = Words( name.uid )
         ln = Word( name.uid,wc )
         fn = Subword( name.uid,1,wc-1 )
         queue Left( uid,9 ) Left( fn,13 ) ln
      end
      if noupdt = 0 then,              /* OK to update               */
         "WHOIS (( ADD"                /* add these to WHOIS         */
      end

return                                 /*@ C_DUMP_OPS                */
/*
   Parse DUMPIN.  It may be a full DSN or just 'DUMPyymm'.
.  ----------------------------------------------------------------- */
CA_LOAD_COUNTS:                        /*@                           */
   if branch then call BRANCH
   address TSO

   If Length(dumpin) = 8 then do       /* DUMP0701 maybe             */
      indsn = "'NTIN.TS.D822.SYSUMON."dumpin"'"
      dumpmo = dumpin
      end
   else do                             /* full DSN ?                 */
      if Left(dumpin,1) = "'" then,    /* quoted                     */
         indsn = dumpin                /* take it as-is              */
      else,
         indsn = "'"dumpin"'"          /* add quotes                 */
      parse value Strip(Reverse(indsn),,"'")  with,
                  dumpmo "."
      dumpmo = Reverse(dumpmo)
      end
   /* INDSN is now a real DSN...                                     */
   if Sysdsn(indsn) <> "OK" then,      /* bad DSN                    */
      do
      say "Unable to resolve" dumpin "to a real dataset name."
      exit                             /* we're done.                */
      end
   /* If you get here, you have a valid DSN...                       */
   "ALLOC FI($TMP) DA("indsn") SHR REU"
   "NEWSTACK"                          /* isolate the queue          */
   "EXECIO * DISKR $TMP (FINIS"        /* load the queue             */
   "FREE  FI($TMP)"

   do queued()                         /* process the queue          */
      parse pull user item count altname.user

      if WordPos(user,uidlist) = 0 then ,
         uidlist = uidlist user
      if WordPos(item,items  ) = 0 then ,
         items   = items   item

      if caller <> "" & caller <> user then iterate
      if tool   <> "" & tool   <> item then iterate

      userkey = user"."item
      userkeylist = userkeylist userkey
      byuser.userkey = count
      byuser.user    = byuser.user + count

      itemkey = item"."user
      itemkeylist = itemkeylist itemkey
      byitem.itemkey = count
      byitem.item    = byitem.item + count
   end                                 /* queued                     */

   userkeylist = STRSORT(userkeylist)
   itemkeylist = STRSORT(itemkeylist)

return                                 /*@ CA_LOAD_COUNTS            */
/*
.  ----------------------------------------------------------------- */
LOCAL_PREINIT:                         /*@ customize opts            */
   address TSO

   sw.0SaveLog = SWITCH("SAVELOG")
   parse value  KEYWD("VSAMIN") "'NTIV.TS.D822.SYSUMON.KSD'" with,
                vsamksds   .

return                                 /*@ LOCAL_PREINIT             */
/*   subroutines below LOCAL_PREINIT are not selected by SHOWFLOW    */
/*
.  ----------------------------------------------------------------- */
ZB_SAVELOG:                            /*@                           */
   if branch then call BRANCH
   address TSO

   if Symbol("LOG#") = "LIT" then return          /* not yet set     */

   "ALLOC FI($LOG) DA("logdsn") REU" vb4k.0
   "EXECIO" log# "DISKW $LOG (STEM LOG. FINIS"
   "FREE  FI($LOG)"

return                                 /*@ ZB_SAVELOG                */
/*
.  ----------------------------------------------------------------- */
ZL_LOGMSG: Procedure expose,           /*@                           */
   (tk_globalvars)  log. log#
   rc = Trace("O")
   address TSO

   parse arg msgtext
   parse value  log#+1  msgtext     with,
                zz      log.zz    1  log#   .

   if monitor then say,
      msgtext

return                                 /*@ ZL_LOGMSG                 */
/*
.  ----------------------------------------------------------------- */
HELP:                                  /*@                           */
address TSO;"CLEAR" ; say ""
if helpmsg <> "" then do ; say helpmsg; say ""; end
ex_nam = Left(exec_name,8)             /* predictable size           */

say "  "ex_nam"      prints and displays selected tool-usage.                  "
say "                                                                          "
say "  Syntax:   "ex_nam"  <USER uid>                                          "
say "                      <TOOL toolname>                                     "
say "                      <LIST>                                              "
say "                      <SUMMARY>                       (valid only if LIST)"
say "                      <INDUMP  dumpid >                                   "
say "                      <DUMP   < nn >>                                     "
say "                      <DUMPTO  dsn ! 'DEFAULT'>                           "
say "                      <CLEAR>                                             "
say "                      <TRIM>                                              "
say "                 ((   <VSAMIN vdsn>                             (Defaults)"
say "                      <SAVELOG>                                           "
say "                                                                          "
say "                                                                          "
say "            uid       identifies a user for whom usage is to be displayed "
say "                                                                          "
say "            toolname  identifies a piece of software for which usage is to"
say "                      be counted.                                         "
say "                                                                          "
say "                                                         more...          "
"NEWSTACK"; pull ; "CLEAR" ; "DELSTACK"
say "                                                                          "
say "            LIST      indicates that a display of usage is to shown.      "
say "                                                                          "
say "            SUMMARY   cause a report by-user and by-tool to be produced   "
say "                                                                          "
say "            dumpid    identifies a SYSUMON dumpfile to be used as input.  "
say "                      It may be specified as only the last node           "
say "                      (e.g.:  DUMP0701) or as the entire DSN, e.g.:       "
say "                      'NTIN.TS.D822.SYSUMON.DUMP0701'.  If INDUMP is      "
say "                      specified, DUMP, DUMPTO, CLEAR, TRIM, and VSAMIN are"
say "                      ignored.                                            "
say "                                                                          "
say "            nn        specifies a month which is to be dumped.  If not    "
say "                      specified, nn defaults to the prior month.          "
say "                                                                          "
say "            dsn       specifies a dataset to receive the dumped data.     "
say "                      You may specify 'DEFAULT' and a name will be built  "
say "                      as 'NTIN.TS.D822.SYSUMON.DUMPyymm'.  If DUMPTO is   "
say "                      not specified, the data will not be cleared from the"
say "                      dataset regardless of any other setting.            "
say "                                                                          "
say "                                                         more...          "
"NEWSTACK"; pull ; "CLEAR" ; "DELSTACK"
say "                                                                          "
say "            CLEAR     causes the column for the specified or defaulted    "
say "                      dump-month to be zeroed after dumping.  This is only"
say "                      valid if DUMP has been specified.                   "
say "                                                                          "
say "            TRIM      purges any row for which all counters are zero.     "
say "                                                                          "
say "            vdsn      specifies a VSAM KSDS which contains the usage data."
say "                      If not specified, it defaults to                    "
say "                               "'NTIV.TS.D822.SYSUMON.KSD'"               "
say "                                                                          "
say "            SAVELOG   causes the progress log to be saved at termination. "
say "                      The default behavior is to purge the log unless it  "
say "                      reports updates to the VSAM file, in which case it  "
say "                      is preserved.                                       "
say "                                                                          "
say "                                                         more...          "
"NEWSTACK"; pull ; "CLEAR" ; "DELSTACK"
say "   Debugging tools provided include:                                      "
say "                                                                          "
say "        MONITOR:  displays key information throughout processing.         "
say "                                                                          "
say "        NOUPDT:   by-pass all update logic.                               "
say "                                                                          "
say "        BRANCH:   show all paragraph entries.                             "
say "                                                                          "
say "        TRACE tv: will use value following TRACE to place the             "
say "                  execution in REXX TRACE Mode.                           "
say "                                                                          "
say "                                                                          "
say "   Debugging tools can be accessed in the following manner:               "
say "                                                                          "
say "        TSO "ex_nam"  parameters     ((  debug-options                    "
say "                                                                          "
say "   For example:                                                           "
say "                                                                          "
say "        TSO "ex_nam"  (( MONITOR TRACE ?R                                 "

if sw.inispf then,
   address ISPEXEC "CONTROL DISPLAY REFRESH"
exit                                   /*@ HELP                      */
/*
.  ----------------------------------------------------------------- */
BRANCH: Procedure expose,              /*@                           */
        sigl exec_name
   rc = trace("O")                     /* we do not want to see this */
   arg brparm .

   origin = sigl                       /* where was I called from ?  */
   do currln = origin to 1 by -1       /* inch backward to label     */
      if Right(Word(Sourceline(currln),1),1) = ":" then do
         parse value sourceline(currln) with pgfname ":" .  /* Label */
         leave ; end                   /*                name        */
   end                                 /* currln                     */

   select
      when brparm = "NAME" then return(pgfname) /* Return full name  */
      when brparm = "ID"      then do           /* wants the prefix  */
         parse var pgfname pgfpref "_" .        /* get the prefix    */
         return(pgfpref)
         end                           /* brparm = "ID"              */
      otherwise
         say left(sigl,6) left(pgfname,40) exec_name "Time:" time("L")
   end                                 /* select                     */

return                                 /*@ BRANCH                    */
/*
.  ----------------------------------------------------------------- */
DUMP_QUEUE:                            /*@ Take whatever is in stack */
   rc = trace("O")                     /*  and write to the screen   */
   address TSO
   arg mode .

   "QSTACK"                            /* how many stacks?           */
   stk2dump    = rc - tk_init_stacks   /* remaining stacks           */
   if stk2dump = 0 & queued() = 0 then return
   if mode <> "QUIET" then,
   say "Total Stacks" rc ,             /* rc = #of stacks            */
    "   Begin Stacks" tk_init_stacks , /* Stacks present at start    */
    "   Excess Stacks to dump" stk2dump

   do dd = rc to tk_init_stacks by -1  /* empty each one.            */
      if mode <> "QUIET" then,
      say "Processing Stack #" dd "   Total Lines:" queued()
      do queued();parse pull line;say line;end /* pump to the screen */
      "DELSTACK"                       /* remove stack               */
   end                                 /* dd = 1 to rc               */

return                                 /*@ DUMP_QUEUE                */
/* Handle CLIST-form keywords             added 20020513
.  ----------------------------------------------------------------- */
CLKWD: Procedure expose info           /*@ hide all except info      */
   arg kw
   kw = kw"("                          /* form is 'KEY(DATA)'        */
   kw_pos = Pos(kw,info)               /* find where it is, maybe    */
   if kw_pos = 0 then return ""        /* send back a null, not found*/
   rtpt   = Pos(") ",info" ",kw_pos)   /* locate end-paren           */
   slug   = Substr(info,kw_pos,rtpt-kw_pos+1)     /* isolate         */
   info   = Delstr(info,kw_pos,rtpt-kw_pos+1)     /* excise          */
   parse var slug (kw)     slug        /* drop kw                    */
   slug   = Reverse(Substr(Reverse(Strip(slug)),2))
return slug                            /*@CLKWD                      */
/* Handle multi-word keys 20020513
.  ----------------------------------------------------------------- */
KEYWD: Procedure expose info           /*@ hide all vars, except info*/
   arg kw                              /* form is 'KEY DATA'         */
   kw_pos = wordpos(kw,info)           /* find where it is, maybe    */
   if kw_pos = 0 then return ""        /* send back a null, not found*/
   kw_val = word(info,kw_pos+Words(kw))/* get the next word          */
   info   = Delword(info,kw_pos,2)     /* remove both                */
return kw_val                          /*@ KEYWD                     */
/*
.  ----------------------------------------------------------------- */
KEYPHRS: Procedure expose,             /*@                           */
         info helpmsg exec_name        /*  except these three        */
   arg kp                              /* form is 'KEY ;: DATA ;:'   */
   wp    = wordpos(kp,info)            /* where is it?               */
   if wp = 0 then return ""            /* not found                  */
   front = subword(info,1,wp-1)        /* everything before kp       */
   back  = subword(info,wp+1)          /* everything after kp        */
   parse var back dlm back             /* 1st token must be 2 bytes  */
   if length(dlm) <> 2 then            /* Must be two bytes          */
      helpmsg = helpmsg "Invalid length for delimiter("dlm") with KEYPHRS("kp")"
   if wordpos(dlm,back) = 0 then       /* search for ending delimiter*/
      helpmsg = helpmsg "No matching second delimiter("dlm") with KEYPHRS("kp")"
   if helpmsg <> "" then call HELP     /* Something is wrong         */
   parse var back kpval (dlm) back     /* get everything b/w delim   */
   info =  front back                  /* restore remainder          */
return Strip(kpval)                    /*@ KEYPHRS                   */
/*
.  ----------------------------------------------------------------- */
NOVALUE:                               /*@                           */
   say exec_name "raised NOVALUE at line" sigl
   say " "
   say "The referenced variable is" condition("D")
   say " "
   zsigl = sigl
   signal SHOW_SOURCE                  /*@ NOVALUE                   */
/*
.  ----------------------------------------------------------------- */
SHOW_SOURCE:                           /*@                           */
   call DUMP_QUEUE                     /* Spill contents of stacks  -*/
   if sourceline() <> "0" then         /* to screen                  */
      say sourceline(zsigl)
   rc =  trace("?R")
   nop
   exit                                /*@ SHOW_SOURCE               */
/*
.  ----------------------------------------------------------------- */
SS: Procedure                          /*@ Show Source               */
   arg  ssbeg  ssct   .                /* 'call ss 122 6' maybe      */
   if ssct  = "" then ssct  = 10
   if ^datatype(ssbeg,"W") ! ^datatype(ssct,"W") then return
   ssend = ssbeg + ssct
   do ssii = ssbeg to ssend ; say Strip(sourceline(ssii),'T') ; end
return                                 /*@ SS                        */
/*
.  ----------------------------------------------------------------- */
SWITCH: Procedure expose info          /*@                           */
   arg kw                              /* form is 'KEY'              */
   sw_val = Wordpos(kw,info) > 0       /* exists = 1; not found = 0  */
   if sw_val then                      /* exists                     */
      info = Delword(info,Wordpos(kw,info),1) /* remove it           */
return sw_val                          /*@ SWITCH                    */
/*
.  ----------------------------------------------------------------- */
SYNTAX:                                /*@                           */
   errormsg = exec_name "encountered REXX error" rc "in line" sigl":",
                        errortext(rc)
   say errormsg
   zsigl = sigl
   signal SHOW_SOURCE                  /*@ SYNTAX                    */
/*
   Can call TRAPOUT.
.  ----------------------------------------------------------------- */
TOOLKIT_INIT:                          /*@                           */
   address TSO
   info = Strip(opts,"T",")")          /* clip trailing paren        */

   parse source  sys_id  how_invokt  exec_name  DD_nm  DS_nm,
                     as_invokt  cmd_env  addr_spc  usr_tokn

   parse value "" with  tv  helpmsg  .
   parse value 0   "ISR00000  YES"     "Error-Press PF1"    with,
               sw.  zerrhm    zerralrm  zerrsm

   if SWITCH("TRAPOUT") then do
      "TRAPOUT" exec_name parms "(( TRACE R" info
      exit
      end                              /* trapout                    */

   sw.nested    = sysvar("SYSNEST") = "YES"
   sw.batch     = sysvar("SYSENV")  = "BACK"
   sw.inispf    = sysvar("SYSISPF") = "ACTIVE"

   if Word(parms,1) = "?" then call HELP /* I won't be back          */

   "QSTACK" ; tk_init_stacks = rc      /* How many stacks?           */

   parse value SWITCH("BRANCH") SWITCH("MONITOR") SWITCH("NOUPDT") with,
               branch           monitor           noupdt    .

   parse value mvsvar("SYSNAME") sysvar("SYSNODE") with,
               #tk_cpu           node          .

   parse value KEYWD("TRACE")  "O"    with   tv  .
   tk_globalvars = "exec_name  tv  helpmsg  sw.  zerrhm  zerralrm ",
                   "zerrsm  zerrlm  tk_init_stacks  branch  monitor ",
                   "noupdt"

   call LOCAL_PREINIT                  /* for more opts             -*/

return                                 /*@ TOOLKIT_INIT              */

./ ADD NAME=SYSUMON
/* REXX    SYSUMON    Replicate the function of the original SYSUMON
                      which counts usage of tools by userid.  Use
                      RXVSAM to open the VSAM KSDS, fetch the proper
                      record, update it, and rewrite.  Any routine
                      which calls SYSUMON must pass <userid> and
                      <toolname>.

           Written by Frank Clarke 20040426

     Impact Analysis
.    SYSEXEC   TRAPOUT

     Modification History
     20040914 fxc mark new records with an "R";
     20090803 fxc keep user's real name;

*/ arg argline
address TSO                            /* REXXSKEL ver.20040227      */
arg parms "((" opts

signal on syntax
signal on novalue

call TOOLKIT_INIT                      /* conventional start-up     -*/
rc = Trace("O"); rc = Trace(tv)
info   = parms                         /* to enable parsing          */

call A_INIT                            /*                           -*/
call B_VSAM_OPS                        /*                           -*/

if  sw.nested then call DUMP_QUEUE     /*                           -*/
exit                                   /*@ SYSUMON                   */
/*
   Initialization
.  ----------------------------------------------------------------- */
A_INIT:                                /*@                           */
   if branch then call BRANCH
   address TSO

   parse value Date("S") Date("B") with yy4 5 mm 7 dd . 1 s_date b_date
   parse value "0 0 0 0 0 0 0 0 0 0 0" with,
         ct.  .
   parse value "" with,
         dumpmo  vskey  rxvsam_vsamerrormsg ,
         keyorig  prevuser  previtem  ,
         byuser.  userkeylist   byitem.  itemkeylist ,
         .
   call AK_KEYWDS                      /*                           -*/

return                                 /*@ A_INIT                    */
/*
   Parse out TOOL and USER
.  ----------------------------------------------------------------- */
AK_KEYWDS:                             /*@                           */
   if branch then call BRANCH
   address TSO

   caller = KEYWD("USER")
   tool   = KEYWD("TOOL")
   uname  = GETNAME()                  /*                           -*/

      vsksds = "SYSUMON.KSD"
      vsksds = "'NTIV.TS.D822.SYSUMON.KSD'"

return                                 /*@ AK_KEYWDS                 */
/*
   LIBDEF to 'NTIN.TS.D822.LIB.ISPLLIB' to enable calls to RXVSAM.
.  ----------------------------------------------------------------- */
B_VSAM_OPS:                            /*@                           */
   if branch then call BRANCH
   address TSO

   if sw.inispf then,
      address ISPEXEC "LIBDEF ISPLLIB DATASET" ,
                      "ID('NTIN.TS.D822.LIB.ISPLLIB') STACK"

   call BA_PROLOG                      /*                           -*/
   call BG_GET_KEY                     /* fetch record              -*/
   call BP_PUT_KEY                     /* replace record            -*/
   call BZ_EPILOG                      /*                           -*/

   if sw.inispf then,
      address ISPEXEC "LIBDEF ISPLLIB"

return                                 /*@ B_VSAM_OPS                */
/*
   Allocate and open the KSDS
.  ----------------------------------------------------------------- */
BA_PROLOG:                             /*@                           */
   if branch then call BRANCH
   address TSO

   "ALLOC FI($VS) DA("vsksds") SHR REU"
   if sw.0List then,
      rxv_rc = RXVSAM("OPENINPUT","$VS","KSDS")
   else,
      rxv_rc = RXVSAM("OPENIO","$VS","KSDS")

return                                 /*@ BA_PROLOG                 */
/*
   Read-with-key.  If key not present, build a new record with a count
   of 0.
   Each record is keyed with 8 characters for the user and 8 characters
   for the tool.  There follow 12 counters, one for each month, the key
   origin (generally 'R'), and the user's name found in storage via
   GETNAME().
.  ----------------------------------------------------------------- */
BG_GET_KEY:                            /*@                           */
   if branch then call BRANCH
   address TSO

   /* read record */
   key = Left(caller,8)Left(tool,8)
   rxv_rc = RXVSAM("READ","$VS",key,"RECORD")

   if rxv_rc > 0 then,                 /* read error - dummy record  */
      parse value 1 Left(caller,8)Left(tool,8) ,
                    0 0 0  0 0 0  0 0 0  0 0 0 "R" with,
                  sw.0read_err  record

   parse var record user . 9 tool . 17,
             ct.01 ct.02 ct.03 ct.04 ct.05 ct.06,
             ct.07 ct.08 ct.09 ct.10 ct.11 ct.12   keyorig .

return                                 /*@ BG_GET_KEY                */
/*
   Increment the counter or this month for this user and this tool.
   Write-with-key the updated record.
.  ----------------------------------------------------------------- */
BP_PUT_KEY:                            /*@                           */
   if branch then call BRANCH
   address TSO

   ct.mm = ct.mm + 1                   /* bump ctr for this month    */
   record = Left(user,8)Left(tool,8),
            Right(ct.01,5,0),
            Right(ct.02,5,0),
            Right(ct.03,5,0),
            Right(ct.04,5,0),
            Right(ct.05,5,0),
            Right(ct.06,5,0),
            Right(ct.07,5,0),
            Right(ct.08,5,0),
            Right(ct.09,5,0),
            Right(ct.10,5,0),
            Right(ct.11,5,0),
            Right(ct.12,5,0),
            keyorig "          "uname

   if sw.0read_err then,               /* REWRITE not allowed        */
      rxv_rc = RXVSAM("WRITE","$VS",,"RECORD")
   else,
      rxv_rc = RXVSAM("REWRITE","$VS",key,"RECORD")

return                                 /*@ BP_PUT_KEY                */
/*
   Close the VSAM file and FREE the dataset.
.  ----------------------------------------------------------------- */
BZ_EPILOG:                             /*@                           */
   if branch then call BRANCH
   address TSO

   rxv_rc = RXVSAM("CLOSE","$VS")
   "FREE  FI($VS)"

return                                 /*@ BZ_EPILOG                 */
/*
.  ----------------------------------------------------------------- */
LOCAL_PREINIT:                         /*@ customize opts            */
   address TSO


return                                 /*@ LOCAL_PREINIT             */
/*   subroutines below LOCAL_PREINIT are not selected by SHOWFLOW    */
/*
.  ----------------------------------------------------------------- */
GETNAME: Procedure expose,             /*@                           */
         (tk_globalvars)
   address TSO

   ASCBASXB = d2x(c2d(Storage(224,4))+108)
   ASXBSENV = d2x(c2d(Storage(ASCBASXB,4))+200)
   ACEEUNAM = d2x(c2d(Storage(ASXBSENV,4))+100)
   Adr = c2x(Storage(ACEEUNAM,4))
   Name = Storage(d2x(c2d(Storage(ACEEUNAM,4))+1),c2d(Storage(Adr,1))-1)
   uname = Strip(Name,"B"," ")

return( name )                         /*@ GETNAME                   */
/*
.  ----------------------------------------------------------------- */
HELP:                                  /*@                           */
address TSO;"CLEAR" ; say ""
if helpmsg <> "" then do ; say helpmsg; say ""; end
ex_nam = Left(exec_name,8)             /* predictable size           */

say "  "ex_nam"      tracks tool-usage.                                        "
say "                                                                          "
say "  Syntax:   "ex_nam"  <USER uid>                                          "
say "                      <TOOL toolname>                                     "
say "                                                                          "
say "            uid       identifies a user for whom usage is to be counted.  "
say "                                                                          "
say "            toolname  identifies a piece of software for which usage is to"
say "                      be counted.                                         "
say "                                                                          "
"NEWSTACK"; pull ; "CLEAR" ; "DELSTACK"
say "   Debugging tools provided include:                                      "
say "                                                                          "
say "        MONITOR:  displays key information throughout processing.         "
say "                                                                          "
say "        NOUPDT:   by-pass all update logic.                               "
say "                                                                          "
say "        BRANCH:   show all paragraph entries.                             "
say "                                                                          "
say "        TRACE tv: will use value following TRACE to place the             "
say "                  execution in REXX TRACE Mode.                           "
say "                                                                          "
say "                                                                          "
say "   Debugging tools can be accessed in the following manner:               "
say "                                                                          "
say "        TSO "ex_nam"  parameters     ((  debug-options                    "
say "                                                                          "
say "   For example:                                                           "
say "                                                                          "
say "        TSO "ex_nam"  (( MONITOR TRACE ?R                                 "

if sw.inispf then,
   address ISPEXEC "CONTROL DISPLAY REFRESH"
exit                                   /*@ HELP                      */
/*
.  ----------------------------------------------------------------- */
BRANCH: Procedure expose,              /*@                           */
        sigl exec_name
   rc = trace("O")                     /* we do not want to see this */
   arg brparm .

   origin = sigl                       /* where was I called from ?  */
   do currln = origin to 1 by -1       /* inch backward to label     */
      if Right(Word(Sourceline(currln),1),1) = ":" then do
         parse value sourceline(currln) with pgfname ":" .  /* Label */
         leave ; end                   /*                name        */
   end                                 /* currln                     */

   select
      when brparm = "NAME" then return(pgfname) /* Return full name  */
      when brparm = "ID"      then do           /* wants the prefix  */
         parse var pgfname pgfpref "_" .        /* get the prefix    */
         return(pgfpref)
         end                           /* brparm = "ID"              */
      otherwise
         say left(sigl,6) left(pgfname,40) exec_name "Time:" time("L")
   end                                 /* select                     */

return                                 /*@ BRANCH                    */
/*
.  ----------------------------------------------------------------- */
DUMP_QUEUE:                            /*@ Take whatever is in stack */
   rc = trace("O")                     /*  and write to the screen   */
   address TSO
   arg mode .

   "QSTACK"                            /* how many stacks?           */
   stk2dump    = rc - tk_init_stacks   /* remaining stacks           */
   if stk2dump = 0 & queued() = 0 then return
   if mode <> "QUIET" then,
   say "Total Stacks" rc ,             /* rc = #of stacks            */
    "   Begin Stacks" tk_init_stacks , /* Stacks present at start    */
    "   Excess Stacks to dump" stk2dump

   do dd = rc to tk_init_stacks by -1  /* empty each one.            */
      if mode <> "QUIET" then,
      say "Processing Stack #" dd "   Total Lines:" queued()
      do queued();parse pull line;say line;end /* pump to the screen */
      "DELSTACK"                       /* remove stack               */
   end                                 /* dd = 1 to rc               */

return                                 /*@ DUMP_QUEUE                */
/* Handle CLIST-form keywords             added 20020513
.  ----------------------------------------------------------------- */
CLKWD: Procedure expose info           /*@ hide all except info      */
   arg kw
   kw = kw"("                          /* form is 'KEY(DATA)'        */
   kw_pos = Pos(kw,info)               /* find where it is, maybe    */
   if kw_pos = 0 then return ""        /* send back a null, not found*/
   rtpt   = Pos(") ",info" ",kw_pos)   /* locate end-paren           */
   slug   = Substr(info,kw_pos,rtpt-kw_pos+1)     /* isolate         */
   info   = Delstr(info,kw_pos,rtpt-kw_pos+1)     /* excise          */
   parse var slug (kw)     slug        /* drop kw                    */
   slug   = Reverse(Substr(Reverse(Strip(slug)),2))
return slug                            /*@CLKWD                      */
/* Handle multi-word keys 20020513
.  ----------------------------------------------------------------- */
KEYWD: Procedure expose info           /*@ hide all vars, except info*/
   arg kw                              /* form is 'KEY DATA'         */
   kw_pos = wordpos(kw,info)           /* find where it is, maybe    */
   if kw_pos = 0 then return ""        /* send back a null, not found*/
   kw_val = word(info,kw_pos+Words(kw))/* get the next word          */
   info   = Delword(info,kw_pos,2)     /* remove both                */
return kw_val                          /*@ KEYWD                     */
/*
.  ----------------------------------------------------------------- */
KEYPHRS: Procedure expose,             /*@                           */
         info helpmsg exec_name        /*  except these three        */
   arg kp                              /* form is 'KEY ;: DATA ;:'   */
   wp    = wordpos(kp,info)            /* where is it?               */
   if wp = 0 then return ""            /* not found                  */
   front = subword(info,1,wp-1)        /* everything before kp       */
   back  = subword(info,wp+1)          /* everything after kp        */
   parse var back dlm back             /* 1st token must be 2 bytes  */
   if length(dlm) <> 2 then            /* Must be two bytes          */
      helpmsg = helpmsg "Invalid length for delimiter("dlm") with KEYPHRS("kp")"
   if wordpos(dlm,back) = 0 then       /* search for ending delimiter*/
      helpmsg = helpmsg "No matching second delimiter("dlm") with KEYPHRS("kp")"
   if helpmsg <> "" then call HELP     /* Something is wrong         */
   parse var back kpval (dlm) back     /* get everything b/w delim   */
   info =  front back                  /* restore remainder          */
return Strip(kpval)                    /*@ KEYPHRS                   */
/*
.  ----------------------------------------------------------------- */
NOVALUE:                               /*@                           */
   say exec_name "raised NOVALUE at line" sigl
   say " "
   say "The referenced variable is" condition("D")
   say " "
   zsigl = sigl
   signal SHOW_SOURCE                  /*@ NOVALUE                   */
/*
.  ----------------------------------------------------------------- */
SHOW_SOURCE:                           /*@                           */
   call DUMP_QUEUE                     /* Spill contents of stacks  -*/
   if sourceline() <> "0" then         /* to screen                  */
      say sourceline(zsigl)
   rc =  trace("?R")
   nop
   exit                                /*@ SHOW_SOURCE               */
/*
.  ----------------------------------------------------------------- */
SS: Procedure                          /*@ Show Source               */
   arg  ssbeg  ssct   .                /* 'call ss 122 6' maybe      */
   if ssct  = "" then ssct  = 10
   if ^datatype(ssbeg,"W") ! ^datatype(ssct,"W") then return
   ssend = ssbeg + ssct
   do ssii = ssbeg to ssend ; say Strip(sourceline(ssii),'T') ; end
return                                 /*@ SS                        */
/*
.  ----------------------------------------------------------------- */
SWITCH: Procedure expose info          /*@                           */
   arg kw                              /* form is 'KEY'              */
   sw_val = Wordpos(kw,info) > 0       /* exists = 1; not found = 0  */
   if sw_val then                      /* exists                     */
      info = Delword(info,Wordpos(kw,info),1) /* remove it           */
return sw_val                          /*@ SWITCH                    */
/*
.  ----------------------------------------------------------------- */
SYNTAX:                                /*@                           */
   errormsg = exec_name "encountered REXX error" rc "in line" sigl":",
                        errortext(rc)
   say errormsg
   zsigl = sigl
   signal SHOW_SOURCE                  /*@ SYNTAX                    */
/*
   Can call TRAPOUT.
.  ----------------------------------------------------------------- */
TOOLKIT_INIT:                          /*@                           */
   address TSO
   info = Strip(opts,"T",")")          /* clip trailing paren        */

   parse source  sys_id  how_invokt  exec_name  DD_nm  DS_nm,
                     as_invokt  cmd_env  addr_spc  usr_tokn

   parse value "" with  tv  helpmsg  .
   parse value 0   "ISR00000  YES"     "Error-Press PF1"    with,
               sw.  zerrhm    zerralrm  zerrsm

   if SWITCH("TRAPOUT") then do
      "TRAPOUT" exec_name parms "(( TRACE R" info
      exit
      end                              /* trapout                    */

   sw.nested    = sysvar("SYSNEST") = "YES"
   sw.batch     = sysvar("SYSENV")  = "BACK"
   sw.inispf    = sysvar("SYSISPF") = "ACTIVE"

   if Word(parms,1) = "?" then call HELP /* I won't be back          */

   "QSTACK" ; tk_init_stacks = rc      /* How many stacks?           */

   parse value SWITCH("BRANCH") SWITCH("MONITOR") SWITCH("NOUPDT") with,
               branch           monitor           noupdt    .

   parse value mvsvar("SYSNAME") sysvar("SYSNODE") with,
               #tk_cpu           node          .

   parse value KEYWD("TRACE")  "O"    with   tv  .
   tk_globalvars = "exec_name  tv  helpmsg  sw.  zerrhm  zerralrm ",
                   "zerrsm  zerrlm  tk_init_stacks  branch  monitor ",
                   "noupdt"

   call LOCAL_PREINIT                  /* for more opts             -*/

return                                 /*@ TOOLKIT_INIT              */

./ ADD NAME=SYSVAR
/* REXX    SYSVARS
*/
address TSO
"CLEAR"

sysvars = "SYSPREF SYSPROC SYSUID SYSLTERM SYSWTERM SYSENV SYSICMD",
          "SYSISPF SYSNEST SYSPCMD SYSSCMD SYSCPU SYSHSM SYSJES",
          "SYSLRACF SYSNODE SYSRACF SYSSRV SYSTERMID SYSTSOE"
/*svars = "SYSAPPCLU SYSDFP SYSMVS SYSNAME SYSSMFID SYSSMS",
          "SYSCLONE SYSPLEX" */
mvsvars = "SYSDFP SYSMVS SYSNAME SYSSMFID SYSSMS",
          "SYSCLONE"

say
say "SYSVARS:"
do zz = 1 to words(sysvars) by 2
   var = Word(sysvars,zz)
   nxt = Word(sysvars,zz+1)
   say Left(Right(var":",15) SYSVAR(var) ,38) ,
       Right(nxt":",15) SYSVAR(nxt)
end

say
say "MVSVARS:"
do zz = 1 to words(mvsvars) by 2
   var = Word(mvsvars,zz)
   nxt = Word(mvsvars,zz+1)
   say Left(Right(var":",15) MVSVAR(var) ,38) ,
       Right(nxt":",15) MVSVAR(nxt)
end

jbnm     = MVSVAR('SYMDEF',JOBNAME)
say
say "JOBNAME:" jbnm
exit                                   /*@ SYSVARS                   */
/* rexx */

./ ADD NAME=SYSVAR$
/* rexx */
node      = sysvar('sysnode')
env       = sysvar('sysenv')
srv       = sysvar('syssrv')
say "node " node
say "env "  node
say "srv "  srv
User Information
Argument Value Description
SYSPREF 0re¬Æx as de¬Æned in user pro¬Æle
SYSPROC SYSPROC returns the current procedure name (either the LOGON
SYSUID User ID of current session
Terminal Information
Argument Value Description
SYSLTERM Number of lines available on screen
SYSWTERM Width of screen
Language Information
Argument Value Description
SYSPLANG Primary language for translated messages
SYSSLANG Secondary language for translated messages
SYSDTERM Whether DBCS is supported for this terminal
SYSKTERM Whether Katakana is supported for this terminal
TSO/E External Functions
Argument Value Description
SYSENV Whether exec is running in foreground or background
SYSICMD Name by which exec was implicitly invoked
SYSISPF Whether ISPF is available for exec
SYSNEST Whether exec was invoked from another exec or CLIST.
SYSPCMD Name of most recently executed command
SYSSCMD Name of most recently executed subcommand
System Information
Argument Value Description
SYSCPU Number of CPU seconds used during session in the form:
SYSHSM Level of Data Facility Hierarchical Storage Manager (DFHSM)
SYSJES Name and level of JES installed
SYSLRACF Level of RACF installed
SYSRACF Whether RACF is available
SYSNODE Network node name of the installation's JES
SYSSRV Number of system resource manager (SRM) service units used
SYSTERMID Terminal ID of the terminal where the REXX exec was started
SYSTSOE Level of TSO/E installed in the form:
version release mod¬ÆctonMnumbe
Console Session Information
Argument Value Description
SOLDISP Whether solicited messages (command responses) should be
UNSDISP Whether unsolicited messages should be displayed at terminal
SOLNUM The number of solicited messages (command responses) to be held
UNSNUM The number of unsolicited messages to be held in message table
MFTIME Whether time stamp should be displayed with messages
MFOSNM Whether originating system name should be displayed with
MFJOB Whether originating job name or job ID should be displayed with
MFSNMJBX Whether system name and job name should be excluded from

./ ADD NAME=SYSVAR1
/* rexx */
node = sysvar('sysnode')
env  = sysvar('sysenv')
srv  = sysvar('syssrv')
say "node " node
say "env "  node
say "srv "  srv

./ ADD NAME=TABLE
/******************************* REXX *********************************/
ADDRESS ISPEXEC
"LIBDEF ISPTABL DATASET ID ('RACFID.REXX.TABLES')"
"TBERASE REXXTAB1"
"TBCREATE REXXTAB1 KEYS (RNO) NAMES (NAME, GRADE, STATUS) WRITE"
"TBCLOSE REXXTAB1"

I = 0
SAY 'HOW MANY RECORDS NEED TO PROCESS'
PULL I
J = 1
DO J = 1 TO I BY 1
    SAY'ENTER THE VALUES NAME GRADE (A OR B OR C OR D)'
    PULL INAME IGRADE
    IF IGRADE = 'D' THEN
        ISTATUS = 'FAIL'
    ELSE IF IGRADE = 'A'| IGRADE = 'B' | IGRADE = 'C' THEN
        ISTATUS = 'PASS'
    ELSE
        ISTATUS ='INVALID GRADE'

    * RECORD VALUES ADD TO TABLE */
    RNO	= J
    NAME	= STRIP (INAME)
    GRADE	= STRIP (IGRADE)
    STATUS = STRIP (ISTATUS)

    "TBOPEN REXXTAB1" "TBADD REXXTAB1"
    IF RC /= 0 THEN
    SAY 'THE RECORD 'RNO'ADD TO TABLE FAILED'
    "TBCLOSE REXXTAB1"
END

DO J = 1 TO I BY 1
    RNO = J
    /* SCANNING FOR RECORD VALUES FROM TABLE */
    "TBOPEN REXXTAB1"
    "TBSCAN REXXTAB1 ARGLIST (RNO)"
    "TBCLOSE REXXTAB1"
    SAY'STATUS OF 'NAME' IS:'STATUS
END

EXIT

./ ADD NAME=TESTCAVX
        /* --------------------  rexx procedure  -------------------- *
         * Name:      testcavx                                        *
         *                                                            *
         * Function:  Test CAVXTRT Defaults                           *
         *                                                            *
         * Syntax:    %testcavx                                       *
         *                                                            *
         * Author:    Lionel B. Dyck                                  *
         *            Kaiser Permanente Information Technology        *
         *            Walnut Creek, CA 94598                          *
         *            (925) 926-5332                                  *
         *            Internet: lionel.b.dyck‡kp.org                  *
         *                                                            *
         * History:                                                   *
         *            02/25/02 - Creation                             *
         *                                                            *
         * ---------------------------------------------------------- */

         ispf = sysvar('sysispf')

         call cavxtrtd
         c = queued()

         do i = 1 to c
            parse pull in
            in.i = in
            end
         in.0 = c

         do i = 1 to in.0
            test = word(in.i,1)
            Select
            When test = "DB" then do
                 parse var in.i  x db desc
                 if sysdsn("'"db".SARDBASE.D0000001'") <> "OK" then do
                    c = in.0 + 1
                    in.c = "Database" db "is not a valid database."
                    in.0 = 1
                    end
                 end
            When test = "PANELS" then do
                 parse var in.i  x dsn
                 if sysdsn(dsn) <> "OK" then do
                    c = in.0 + 1
                    in.c = "Panel Library" panels sysdsn(dsn)
                    in.0 = 1
                    end
                 end
            When test = "TABLES" then do
                 parse var in.i  x dsn
                 if sysdsn(dsn) <> "OK" then do
                    c = in.0 + 1
                    in.c = "Table Library" tables sysdsn(dsn)
                    in.0 = 1
                    end
                 end
             Otherwise nop
            end
            end

         if sysvar('sysispf') = "ACTIVE" then do
            cavx_dd = "C"random()
            "allocate file("cavx_dd") reuse unit(sysda) space(1 1)" ,
                     "tr dsorg(ps) recfm(v b) lrecl(255)"
            "execio * diskw" cavx_dd "(finis stem in.)"
            Address ISPEXEC "LMINIT DATAID(DATAID) DDNAME("cavx_dd")"
            Address ISPEXEC "BROWSE DATAID("dataid")"
            Address ISPEXEC "LMFREE DATAID("dataid")"
            "FREE FILE("cavx_dd")"
            end
         else do i = 1 to in.0
              say in.i
              end

./ ADD NAME=TRMDSTAT
/* rexx */
/*                                                                 */
ADDRESS TSO
"ALTLIB ACT APPLICATION(CLIST) DA('STE58.TRMDSTAT.REXX')"
addRESS ISPEXEC
"LIBDEF ISPPLIB DATASET ID('STE58.TRMDSTAT.PANELS')"
"SELECT cmdEL(GIM‡PRIM))"
ISPEXEC LIBDEF ISPPLIB /* free plib */
ADDRESS TSO
"ALTLIB DEA APPLICATION(REXX)" /* deactivate clist library */
"END"

./ ADD NAME=VSPACE
/* REXX    VSPACE     computes %-used from LISTCSUM output and
                      recommends primary space allocation if different.

           Written by Frank Clarke 20070619

     Impact Analysis
.    SYSEXEC   TRAPOUT
.    ISPLLIB   SYSPMON

     Modification History
     20070723 fxc handle "not found";
     20070731 fxc report over-allocated;
     20090309 fxc monitor with SYSPMON;

*/ arg argline
address TSO                            /* REXXSKEL ver.20040227      */
arg parms "((" opts

signal on syntax
signal on novalue

call TOOLKIT_INIT                      /* conventional start-up     -*/
rc = Trace("O"); rc = Trace(tv)
info   = parms                         /* to enable parsing          */

call A_INIT                            /*                           -*/
call B_LISTCAT                         /*                           -*/
                                    if ^sw.0error_found then,
call C_COMPUTE                         /*                           -*/

if ^sw.nested then call DUMP_QUEUE     /*                           -*/
exit                                   /*@ VSPACE                    */
/*
   Initialization
.  ----------------------------------------------------------------- */
A_INIT:                                /*@                           */
   if branch then call BRANCH
   address TSO

   call AA_SETUP_LOG                   /*                            */
   call AK_KEYWDS                      /* parse parms               -*/
   parse value "0" with ,
         chunktot   data.   dsn ,
         chunk   chunklist  minsize
   msg. = "??"                         /*                            */
   msg.0000 = "OK"                     /* exists                     */
   msg.0005 = "NC"                     /* not catalogued             */
   msg.0009 = "MI"                     /* migrated                   */

   if sw.0UseFile = 0 then,            /* not a LIST                 */
      parse var info   dsn info

   monparm = "/USER" Userid() "TOOL" exec_name
   if tv = "O" then,
   "CALL 'NTIN.TS.D822.LIB.ISPLLIB(SYSPMON)'"  "'" monparm"'"

return                                 /*@ A_INIT                    */
/*
.  ----------------------------------------------------------------- */
AA_SETUP_LOG:                          /*@                           */
   if branch then call BRANCH
   address TSO

   parse value "0" with,
               log#    log.
   parse value Date("S")  Time("S")  Time("N")  with,
               yyyymmdd   sssss      hhmmss  .
   parse var yyyymmdd  4 yrdigit 5 mm 7 dd          /* 9 12 14 maybe */
   if Pos(yrdigit,"13579") > 0 then mm = mm + 12       /* mm=24      */
   logtag = Substr("ABCDEFGHIJKLMNOPQRSTUVWX",mm,1)    /* logtag=X   */
   subid  = logtag""dd""Right(sssss,5,0)               /* X1423722 ? */
   vb4k.0    = "NEW CATALOG UNIT(SYSDA) SPACE(1 5) TRACKS",
               "RECFM(V B) LRECL(4096) BLKSIZE(0)"
   vb4k.1    = "SHR"                   /* if it already exists...    */
   logdsn = "@@LOG."exec_name"."subid".#CILIST"

   call ZL_LOGMSG(exec_name "started by" Userid()  yyyymmdd  hhmmss)
   call ZL_LOGMSG("Arg:" argline)

return                                 /*@ AA_SETUP_LOG              */
/*
   Parse parms
.  ----------------------------------------------------------------- */
AK_KEYWDS:                             /*@                           */
   if branch then call BRANCH
   address TSO

/* sw.0clear = SWITCH("CLEAR") */
   sw.0Terse = SWITCH("TERSE")
   parse value KEYWD("INCR") "20"  with ,
               uplift     .
   dispupl = uplift
   ldrc      = LISTDSI("DSLIST FILE")
   sw.0UseFile = ldrc = 0
   uplift    = ( 100 + uplift ) / 100  /* 100+20/100 = 1.2           */
   zerrlm = exec_name "("BRANCH("ID")")" ,
               "Using uplift of" uplift
   call ZL_LOGMSG(zerrlm)

return                                 /*@ AK_KEYWDS                 */
/*
   Get catalog information
.  ----------------------------------------------------------------- */
B_LISTCAT:                             /*@                           */
   if branch then call BRANCH
   address TSO

   if sw.0Terse then do
   say,
      Left( " ",52 ) "Primary  Current  Recommended"
   say,
      Left( " ",52 ) "                 (uplift" dispupl"%)"
      end
   if sw.0UseFile   then do            /* it's a list of names       */
      call D_DO_LIST                   /*                           -*/
      sw.0error_found = 1
      return                           /* we're done                 */
      end                              /* sw.0UseFile                */

   call BL_LOAD_STACK                  /*                           -*/

return                                 /*@ B_LISTCAT                 */
/*
   Run LISTCSUM; load data strings from stack
.  ----------------------------------------------------------------- */
BL_LOAD_STACK:                         /*@                           */
   if branch then call BRANCH
   address TSO

   if Left( dsn,1 ) <> "'" then,       /* unquoted                   */
      dsn = "'"Strip( dsn )"'"

   zerrlm = exec_name "("BRANCH("ID")")" ,
               "Processing DSN" dsn
   call ZL_LOGMSG(zerrlm)
   data.  = ""                         /* purge any existing         */
   "NEWSTACK"
   "LISTCSUM" dsn "STACK"
   do queued()
      parse pull  id ":"  data.id
   end
   "DELSTACK"

return                                 /*@ BL_LOAD_STACK             */
/*
   Manipulate SPACE information to produce a report
.  ----------------------------------------------------------------- */
C_COMPUTE:                             /*@                           */
   if branch then call BRANCH
   address TSO

   numeric digits 14
   zerrlm = exec_name "("BRANCH("ID")")" ,
               "DATA.dataallocation="data.dataallocation
   call ZL_LOGMSG(zerrlm)
   if data.dataallocation = "" then do
      call CL_LISTDSI                  /*                           -*/
      return
      end

   if sw.0clear then "CLEAR"

   parse value "0" with chunktot  chunklist
   dataassoc = Strip( data.dataassociations )
   if sw.0Terse = 0 then,
   say "Information for" dataassoc

   info =    data.dataallocation
   hiurba = KEYWD("HI U RBA")
   hiarba = KEYWD("HI A RBA")
   spacep = KEYWD("SPACE PRI")
   spacet = KEYWD("SPACE TYPE")
   fragused = (hiurba / hiarba) * 100
   if sw.0Terse = 0 then,
   say "HI-U-RBA" hiurba ,
     "  HI-A-RBA" hiarba  "  " Format( fragused,3,2 )"%"
   if spacet = "CYLINDER" then facs   = "15 c c"; else facs = "1 t t"
   parse var facs   factor typinit  typinitr .

   info =    data.datavolume
   zerrlm = exec_name "("BRANCH("ID")")" ,
               "DATA.datavolume="info
   call ZL_LOGMSG(zerrlm)
   do until chunk = ""
      chunk = KEYWD("TRACKS")
      if chunk <> "" then do
         chunklist = chunklist chunk
         chunktot = chunktot + chunk
         end
   end

   parse value "0 0" with,
               sw.0Small  sw.0TooBig
   if chunktot > 0 then do
      if sw.0Terse = 0 then,
      say "Total tracks:" chunktot "in" Words(chunklist),
          "fragments"
      if chunktot > (spacep*factor) then do
         if sw.0Terse = 0 then,
         say "This is larger than the PRIMARY allocation of",
             spacet spacep
         minsize = Format( (chunktot/factor) * uplift , 6,0 ) + 0
         if sw.0Terse = 0 then,
         say "Increase to at least" spacet minsize
         sw.0Small = 1
         end
      else
      if fragused < 7.1 then do
         sw.0TooBig = 1
         sw.0Footnote = 1
         minsize  = Format(( chunktot * hiurba / hiarba ) , 6,0 ) + 0
         typinitr = "t *"
         end

      if sw.0Terse = 0 & sw.0Small = 0 then,
      say "PRIMARY allocation is",
          spacep spacet
      end

   if chunktot%factor <> chunktot/factor then,
      chunkadj = chunktot%factor + 1
   else,
      chunkadj = chunktot%factor

   if sw.0Small ! sw.0TooBig then,
   if sw.0Terse then say ,
      Left( dataassoc,52 ) Right( spacep,5 )typinit,
                           Right( chunkadj,7 )typinit,
                           Right( minsize,9 )typinitr
return                                 /*@ C_COMPUTE                 */
/*
   It's non-VSAM; use LISTDSI to acquire info
.  ----------------------------------------------------------------- */
CL_LISTDSI:                            /*@                           */
   if branch then call BRANCH
   address TSO

   s. = ""

   if Left( dsn,1 ) <> "'" then,       /* unquoted                   */
      dsn = "'"Strip( dsn )"'"

   ldrc       = LISTDSI(dsn "DIRECTORY NORECALL")
   if ldrc > 4 then do
      say dsn "not found"
      sw.0error_found = 1
      return
      end
   if sw.0Terse then return            /* no report for non-VSAM     */
   s.dset     = SYSDSNAME
   s.alloc    = SYSALLOC
   s.used     = SYSUSED
   s.pri      = SYSPRIMARY
   s.sec      = SYSSECONDS
   s.unit     = SYSUNITS
   s.ext      = SYSEXTENTS
   dsstat     = msg.sysreason
   s.m1       = SYSMSGLVL1
   s.m2       = SYSMSGLVL2
   if s.ext > 1 then extsuff = "s"
                else extsuff = "";
   say "Dataset" s.dset "is allocated in" s.unit"s."
   if s.used = "N/A" then,
   say "It is a LIBRARY with a total of" s.alloc,
       "allocated" s.unit"s and is in" s.ext,
       "extent"extsuff"."
   else,
   say "It is currently using" s.used "of" s.alloc,
       "allocated" s.unit"s and is in" s.ext,
       "extent"extsuff"."

return                                 /*@ CL_LISTDSI                */
/*
   Input is a list of DSNs; process each
.  ----------------------------------------------------------------- */
D_DO_LIST:                             /*@                           */
   if branch then call BRANCH
   address TSO

   dsl. = ""
   "EXECIO  *  DISKR  DSLIST ( STEM DSL. FINIS"
   zerrlm = exec_name "("BRANCH("ID")")" ,
               "FILE DSLIST held" dsl.0 "lines."
   do dx = 1 to dsl.0
      dsn = dsl.dx                     /* unquoted                   */
      call BL_LOAD_STACK               /*                           -*/
      call C_COMPUTE                   /*                           -*/
      if sw.0Terse = 0 then,
      say " "
   end                                 /* queued                     */

   if sw.0Footnote & sw.0Terse then do
      say
      say "( * = over-allocated, uplift not applied )"
      end

return                                 /*@ D_DO_LIST                 */
/*
.  ----------------------------------------------------------------- */
LOCAL_PREINIT:                         /*@ customize opts            */
   address TSO


return                                 /*@ LOCAL_PREINIT             */
/*   subroutines below LOCAL_PREINIT are not selected by SHOWFLOW    */
/*
.  ----------------------------------------------------------------- */
ZB_SAVELOG:                            /*@                           */
   if branch then call BRANCH
   address TSO

   if Symbol("LOG#") = "LIT" then return          /* not yet set     */

   "ALLOC FI($LOG) DA("logdsn") REU" vb4k.0
   "EXECIO" log# "DISKW $LOG (STEM LOG. FINIS"
   "FREE  FI($LOG)"

return                                 /*@ ZB_SAVELOG                */
/*
.  ----------------------------------------------------------------- */
ZL_LOGMSG: Procedure expose,           /*@                           */
   (tk_globalvars)  log. log#
   rc = Trace("O")
   address TSO

   parse arg msgtext
   parse value  log#+1  msgtext     with,
                zz      log.zz    1  log#   .

   if monitor then say,
      msgtext

return                                 /*@ ZL_LOGMSG                 */
/*
.  ----------------------------------------------------------------- */
HELP:                                  /*@                           */
address TSO;"CLEAR" ; say ""
if helpmsg <> "" then do ; say helpmsg; say ""; end
ex_nam = Left(exec_name,8)             /* predictable size           */

say "  "ex_nam"      computes %-used from LISTCSUM output and recommends       "
say "                primary space allocation if different.  Both VSAM and     "
say "                non-VSAM datasets can be processed unless TERSE is        "
say "                specified.                                                "
say "                                                                          "
say "                                                                          "
say "  Syntax:   "ex_nam"  <dsn>                                     (Optional)"
say "                      <TERSE>                                             "
say "                      <INCR uplift>                                       "
say "                                                                          "
say "            dsn       names the dataset entry to be analyzed.  If it is a "
say "                      non-data entry, the associated data part will be    "
say "                      analyzed.  If FILE DSLIST is provided, <dsn> is     "
say "                      ignored in favor of DSLIST's fully-qualified        "
say "                      unquoted DSNs.                                      "
say "                                                                          "
say "            TERSE     produces a report only for those VSAM clusters which"
say "                      are candidates for expansion.                       "
say "                                                                          "
say "            uplift    specifies a percentage value to be used in          "
say "                      calculating the recommended primary allocation.  If "
say "                      not specified, it defaults to '20'.                 "
say "                                                                          "
"NEWSTACK"; pull ; "CLEAR" ; "DELSTACK"
say "   Debugging tools provided include:                                      "
say "                                                                          "
say "        BRANCH:   show all paragraph entries.                             "
say "                                                                          "
say "        TRACE tv: will use value following TRACE to place the             "
say "                  execution in REXX TRACE Mode.                           "
say "                                                                          "
say "                                                                          "
say "   Debugging tools can be accessed in the following manner:               "
say "                                                                          "
say "        TSO "ex_nam"  parameters     ((  debug-options                    "
say "                                                                          "
say "   For example:                                                           "
say "                                                                          "
say "        TSO "ex_nam"  (( TRACE ?R                                 "

if sw.inispf then,
   address ISPEXEC "CONTROL DISPLAY REFRESH"
exit                                   /*@ HELP                      */
/*
.  ----------------------------------------------------------------- */
BRANCH: Procedure expose,              /*@                           */
        sigl exec_name
   rc = trace("O")                     /* we do not want to see this */
   arg brparm .

   origin = sigl                       /* where was I called from ?  */
   do currln = origin to 1 by -1       /* inch backward to label     */
      if Right(Word(Sourceline(currln),1),1) = ":" then do
         parse value sourceline(currln) with pgfname ":" .  /* Label */
         leave ; end                   /*                name        */
   end                                 /* currln                     */

   select
      when brparm = "NAME" then return(pgfname) /* Return full name  */
      when brparm = "ID"      then do           /* wants the prefix  */
         parse var pgfname pgfpref "_" .        /* get the prefix    */
         return(pgfpref)
         end                           /* brparm = "ID"              */
      otherwise
         say left(sigl,6) left(pgfname,40) exec_name "Time:" time("L")
   end                                 /* select                     */

return                                 /*@ BRANCH                    */
/*
.  ----------------------------------------------------------------- */
DUMP_QUEUE:                            /*@ Take whatever is in stack */
   rc = trace("O")                     /*  and write to the screen   */
   address TSO
   arg mode .

   "QSTACK"                            /* how many stacks?           */
   stk2dump    = rc - tk_init_stacks   /* remaining stacks           */
   if stk2dump = 0 & queued() = 0 then return
   if mode <> "QUIET" then,
   say "Total Stacks" rc ,             /* rc = #of stacks            */
    "   Begin Stacks" tk_init_stacks , /* Stacks present at start    */
    "   Excess Stacks to dump" stk2dump

   do dd = rc to tk_init_stacks by -1  /* empty each one.            */
      if mode <> "QUIET" then,
      say "Processing Stack #" dd "   Total Lines:" queued()
      do queued();parse pull line;say line;end /* pump to the screen */
      "DELSTACK"                       /* remove stack               */
   end                                 /* dd = 1 to rc               */

return                                 /*@ DUMP_QUEUE                */
/* Handle CLIST-form keywords             added 20020513
.  ----------------------------------------------------------------- */
CLKWD: Procedure expose info           /*@ hide all except info      */
   arg kw
   kw = kw"("                          /* form is 'KEY(DATA)'        */
   kw_pos = Pos(kw,info)               /* find where it is, maybe    */
   if kw_pos = 0 then return ""        /* send back a null, not found*/
   rtpt   = Pos(") ",info" ",kw_pos)   /* locate end-paren           */
   slug   = Substr(info,kw_pos,rtpt-kw_pos+1)     /* isolate         */
   info   = Delstr(info,kw_pos,rtpt-kw_pos+1)     /* excise          */
   parse var slug (kw)     slug        /* drop kw                    */
   slug   = Reverse(Substr(Reverse(Strip(slug)),2))
return slug                            /*@CLKWD                      */
/* Handle multi-word keys 20020513
.  ----------------------------------------------------------------- */
KEYWD: Procedure expose info           /*@ hide all vars, except info*/
   arg kw                              /* form is 'KEY DATA'         */
   kw_pos = wordpos(kw,info)           /* find where it is, maybe    */
   if kw_pos = 0 then return ""        /* send back a null, not found*/
   kw_val = word(info,kw_pos+Words(kw))/* get the next word          */
   info   = Delword(info,kw_pos,2)     /* remove both                */
return kw_val                          /*@ KEYWD                     */
/*
.  ----------------------------------------------------------------- */
KEYPHRS: Procedure expose,             /*@                           */
         info helpmsg exec_name        /*  except these three        */
   arg kp                              /* form is 'KEY ;: DATA ;:'   */
   wp    = wordpos(kp,info)            /* where is it?               */
   if wp = 0 then return ""            /* not found                  */
   front = subword(info,1,wp-1)        /* everything before kp       */
   back  = subword(info,wp+1)          /* everything after kp        */
   parse var back dlm back             /* 1st token must be 2 bytes  */
   if length(dlm) <> 2 then            /* Must be two bytes          */
      helpmsg = helpmsg "Invalid length for delimiter("dlm") with KEYPHRS("kp")"
   if wordpos(dlm,back) = 0 then       /* search for ending delimiter*/
      helpmsg = helpmsg "No matching second delimiter("dlm") with KEYPHRS("kp")"
   if helpmsg <> "" then call HELP     /* Something is wrong         */
   parse var back kpval (dlm) back     /* get everything b/w delim   */
   info =  front back                  /* restore remainder          */
return Strip(kpval)                    /*@ KEYPHRS                   */
/*
.  ----------------------------------------------------------------- */
NOVALUE:                               /*@                           */
   say exec_name "raised NOVALUE at line" sigl
   say " "
   say "The referenced variable is" condition("D")
   say " "
   zsigl = sigl
   signal SHOW_SOURCE                  /*@ NOVALUE                   */
/*
.  ----------------------------------------------------------------- */
SHOW_SOURCE:                           /*@                           */
   call DUMP_QUEUE                     /* Spill contents of stacks  -*/
   if sourceline() <> "0" then         /* to screen                  */
      say sourceline(zsigl)
   rc =  trace("?R")
   nop
   exit                                /*@ SHOW_SOURCE               */
/*
.  ----------------------------------------------------------------- */
SS: Procedure                          /*@ Show Source               */
   arg  ssbeg  ssct   .                /* 'call ss 122 6' maybe      */
   if ssct  = "" then ssct  = 10
   if ^datatype(ssbeg,"W") ! ^datatype(ssct,"W") then return
   ssend = ssbeg + ssct
   do ssii = ssbeg to ssend ; say Strip(sourceline(ssii),'T') ; end
return                                 /*@ SS                        */
/*
.  ----------------------------------------------------------------- */
SWITCH: Procedure expose info          /*@                           */
   arg kw                              /* form is 'KEY'              */
   sw_val = Wordpos(kw,info) > 0       /* exists = 1; not found = 0  */
   if sw_val then                      /* exists                     */
      info = Delword(info,Wordpos(kw,info),1) /* remove it           */
return sw_val                          /*@ SWITCH                    */
/*
.  ----------------------------------------------------------------- */
SYNTAX:                                /*@                           */
   errormsg = exec_name "encountered REXX error" rc "in line" sigl":",
                        errortext(rc)
   say errormsg
   zsigl = sigl
   signal SHOW_SOURCE                  /*@ SYNTAX                    */
/*
   Can call TRAPOUT.
.  ----------------------------------------------------------------- */
TOOLKIT_INIT:                          /*@                           */
   address TSO
   info = Strip(opts,"T",")")          /* clip trailing paren        */

   parse source  sys_id  how_invokt  exec_name  DD_nm  DS_nm,
                     as_invokt  cmd_env  addr_spc  usr_tokn

   parse value "" with  tv  helpmsg  .
   parse value 0   "ISR00000  YES"     "Error-Press PF1"    with,
               sw.  zerrhm    zerralrm  zerrsm

   if SWITCH("TRAPOUT") then do
      "TRAPOUT" exec_name parms "(( TRACE R" info
      exit
      end                              /* trapout                    */

   sw.nested    = sysvar("SYSNEST") = "YES"
   sw.batch     = sysvar("SYSENV")  = "BACK"
   sw.inispf    = sysvar("SYSISPF") = "ACTIVE"

   if Word(parms,1) = "?" then call HELP /* I won't be back          */

   "QSTACK" ; tk_init_stacks = rc      /* How many stacks?           */

   parse value SWITCH("BRANCH") SWITCH("MONITOR") SWITCH("NOUPDT") with,
               branch           monitor           noupdt    .

   parse value mvsvar("SYSNAME") sysvar("SYSNODE") with,
               #tk_cpu           node          .

   parse value KEYWD("TRACE")  "O"    with   tv  .
   tk_globalvars = "exec_name  tv  helpmsg  sw.  zerrhm  zerralrm ",
                   "zerrsm  zerrlm  tk_init_stacks  branch  monitor ",
                   "noupdt"

   call LOCAL_PREINIT                  /* for more opts             -*/

return                                 /*@ TOOLKIT_INIT              */

./ ADD NAME=ZFSTOOLS
/* rexx */
trace all
/*zfstools lyonel b dick                                           */
ADDRESS TSO
"ALTLIB ACT APPLICATION(EXEC) DA('STE58.ZFSTOOLS.EXEC')"
ADDRESS ISPEXEC
"LIBDEF ISPPLIB DATASET ID('STE58.ZFSTOOLS.PANELS') UNCOND"
"SELECT CMD(ZFSMENU) NEWAPPL(IST) PASSLIB"
ISPEXEC LIBDEF ISPMLIB /* FREE MLIB */
ADDRESS TSO
"ALTLIB DEA APPLICATION(EXEC)" /* DEACTIVATE CLIST LIBRARY */
"END"
./ ENDUP
!!
//
//* END \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
